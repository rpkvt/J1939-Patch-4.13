From 9ca0c066cf0dd0d08a91e8b2861b9247edb2aec4 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sat, 29 Jul 2017 11:51:01 +0200
Subject: [PATCH 001/113] can: af_can: can_pernet_init(): add missing error
 handling for kzalloc returning NULL

This patch adds the missing check and error handling for out-of-memory
situations, when kzalloc cannot allocate memory.

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/af_can.c | 18 +++++++++++++++---
 1 file changed, 15 insertions(+), 3 deletions(-)

diff --git a/net/can/af_can.c b/net/can/af_can.c
index 88edac0..0896e2f 100644
--- a/net/can/af_can.c
+++ b/net/can/af_can.c
@@ -875,9 +875,14 @@ static int can_pernet_init(struct net *net)
 	spin_lock_init(&net->can.can_rcvlists_lock);
 	net->can.can_rx_alldev_list =
 		kzalloc(sizeof(struct dev_rcv_lists), GFP_KERNEL);
-
-	net->can.can_stats = kzalloc(sizeof(struct s_stats), GFP_KERNEL);
-	net->can.can_pstats = kzalloc(sizeof(struct s_pstats), GFP_KERNEL);
+	if (!net->can.can_rx_alldev_list)
+		goto out;
+	net->can.can_stats = kzalloc(sizeof(struct can_stats), GFP_KERNEL);
+	if (!net->can.can_stats)
+		goto out_free_alldev_list;
+	net->can.can_pstats = kzalloc(sizeof(struct can_pstats), GFP_KERNEL);
+	if (!net->can.can_pstats)
+		goto out_free_can_stats;
 
 	if (IS_ENABLED(CONFIG_PROC_FS)) {
 		/* the statistics are updated every second (timer triggered) */
@@ -892,6 +897,13 @@ static int can_pernet_init(struct net *net)
 	}
 
 	return 0;
+
+ out_free_can_stats:
+	kfree(net->can.can_stats);
+ out_free_alldev_list:
+	kfree(net->can.can_rx_alldev_list);
+ out:
+	return -ENOMEM;
 }
 
 static void can_pernet_exit(struct net *net)
-- 
1.9.1


From 5b7baa35d270712eb9bdc8badadb45c97e48d852 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sat, 3 Jun 2017 20:01:51 +0200
Subject: [PATCH 002/113] can: give structs holding the CAN statistics a
 sensible name

This patch renames both "struct s_stats" and "struct s_pstats" by
replacing the leading "s" by "can" to better reflect their meaning and
improve code readability.

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 include/net/netns/can.h |  8 ++++----
 net/can/af_can.c        | 18 +++++++++---------
 net/can/af_can.h        |  4 ++--
 net/can/proc.c          | 16 ++++++++--------
 4 files changed, 23 insertions(+), 23 deletions(-)

diff --git a/include/net/netns/can.h b/include/net/netns/can.h
index b106e6a..5ee0f88 100644
--- a/include/net/netns/can.h
+++ b/include/net/netns/can.h
@@ -8,8 +8,8 @@
 #include <linux/spinlock.h>
 
 struct dev_rcv_lists;
-struct s_stats;
-struct s_pstats;
+struct can_stats;
+struct can_pstats;
 
 struct netns_can {
 #if IS_ENABLED(CONFIG_PROC_FS)
@@ -30,8 +30,8 @@ struct netns_can {
 	struct dev_rcv_lists *can_rx_alldev_list;
 	spinlock_t can_rcvlists_lock;
 	struct timer_list can_stattimer;/* timer for statistics update */
-	struct s_stats *can_stats;	/* packet statistics */
-	struct s_pstats *can_pstats;	/* receive list statistics */
+	struct can_stats *can_stats; /* packet statistics */
+	struct can_pstats *can_pstats; /* receive list statistics */
 
 	/* CAN GW per-net gateway jobs */
 	struct hlist_head cgw_list;
diff --git a/net/can/af_can.c b/net/can/af_can.c
index 0896e2f..bbd8a9b 100644
--- a/net/can/af_can.c
+++ b/net/can/af_can.c
@@ -217,7 +217,7 @@ int can_send(struct sk_buff *skb, int loop)
 {
 	struct sk_buff *newskb = NULL;
 	struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
-	struct s_stats *can_stats = dev_net(skb->dev)->can.can_stats;
+	struct can_stats *can_stats = dev_net(skb->dev)->can.can_stats;
 	int err = -EINVAL;
 
 	if (skb->len == CAN_MTU) {
@@ -321,8 +321,8 @@ int can_send(struct sk_buff *skb, int loop)
  * af_can rx path
  */
 
-static struct dev_rcv_lists *find_dev_rcv_lists(struct net *net,
-						struct net_device *dev)
+static struct dev_rcv_lists *can_dev_rcv_lists_find(struct net *net,
+						    struct net_device *dev)
 {
 	if (!dev)
 		return net->can.can_rx_alldev_list;
@@ -465,7 +465,7 @@ int can_rx_register(struct net *net, struct net_device *dev, canid_t can_id,
 	struct receiver *r;
 	struct hlist_head *rl;
 	struct dev_rcv_lists *d;
-	struct s_pstats *can_pstats = net->can.can_pstats;
+	struct can_pstats *can_pstats = net->can.can_pstats;
 	int err = 0;
 
 	/* insert new receiver  (dev,canid,mask) -> (func,data) */
@@ -482,7 +482,7 @@ int can_rx_register(struct net *net, struct net_device *dev, canid_t can_id,
 
 	spin_lock(&net->can.can_rcvlists_lock);
 
-	d = find_dev_rcv_lists(net, dev);
+	d = can_dev_rcv_lists_find(net, dev);
 	if (d) {
 		rl = find_rcv_list(&can_id, &mask, d);
 
@@ -541,7 +541,7 @@ void can_rx_unregister(struct net *net, struct net_device *dev, canid_t can_id,
 {
 	struct receiver *r = NULL;
 	struct hlist_head *rl;
-	struct s_pstats *can_pstats = net->can.can_pstats;
+	struct can_pstats *can_pstats = net->can.can_pstats;
 	struct dev_rcv_lists *d;
 
 	if (dev && dev->type != ARPHRD_CAN)
@@ -552,7 +552,7 @@ void can_rx_unregister(struct net *net, struct net_device *dev, canid_t can_id,
 
 	spin_lock(&net->can.can_rcvlists_lock);
 
-	d = find_dev_rcv_lists(net, dev);
+	d = can_dev_rcv_lists_find(net, dev);
 	if (!d) {
 		pr_err("BUG: receive list not found for "
 		       "dev %s, id %03X, mask %03X\n",
@@ -684,7 +684,7 @@ static void can_receive(struct sk_buff *skb, struct net_device *dev)
 {
 	struct dev_rcv_lists *d;
 	struct net *net = dev_net(dev);
-	struct s_stats *can_stats = net->can.can_stats;
+	struct can_stats *can_stats = net->can.can_stats;
 	int matches;
 
 	/* update statistics */
@@ -701,7 +701,7 @@ static void can_receive(struct sk_buff *skb, struct net_device *dev)
 	matches = can_rcv_filter(net->can.can_rx_alldev_list, skb);
 
 	/* find receive list for this device */
-	d = find_dev_rcv_lists(net, dev);
+	d = can_dev_rcv_lists_find(net, dev);
 	if (d)
 		matches += can_rcv_filter(d, skb);
 
diff --git a/net/can/af_can.h b/net/can/af_can.h
index d0ef45b..4e2cb14 100644
--- a/net/can/af_can.h
+++ b/net/can/af_can.h
@@ -78,7 +78,7 @@ struct dev_rcv_lists {
 /* statistic structures */
 
 /* can be reset e.g. by can_init_stats() */
-struct s_stats {
+struct can_stats {
 	unsigned long jiffies_init;
 
 	unsigned long rx_frames;
@@ -103,7 +103,7 @@ struct s_stats {
 };
 
 /* persistent statistics */
-struct s_pstats {
+struct can_pstats {
 	unsigned long stats_reset;
 	unsigned long user_reset;
 	unsigned long rcv_entries;
diff --git a/net/can/proc.c b/net/can/proc.c
index 83045f0..559fca8 100644
--- a/net/can/proc.c
+++ b/net/can/proc.c
@@ -77,14 +77,14 @@
 
 static void can_init_stats(struct net *net)
 {
-	struct s_stats *can_stats = net->can.can_stats;
-	struct s_pstats *can_pstats = net->can.can_pstats;
+	struct can_stats *can_stats = net->can.can_stats;
+	struct can_pstats *can_pstats = net->can.can_pstats;
 	/*
 	 * This memset function is called from a timer context (when
 	 * can_stattimer is active which is the default) OR in a process
 	 * context (reading the proc_fs when can_stattimer is disabled).
 	 */
-	memset(can_stats, 0, sizeof(struct s_stats));
+	memset(can_stats, 0, sizeof(struct can_stats));
 	can_stats->jiffies_init = jiffies;
 
 	can_pstats->stats_reset++;
@@ -118,7 +118,7 @@ static unsigned long calc_rate(unsigned long oldjif, unsigned long newjif,
 void can_stat_update(unsigned long data)
 {
 	struct net *net = (struct net *)data;
-	struct s_stats *can_stats = net->can.can_stats;
+	struct can_stats *can_stats = net->can.can_stats;
 	unsigned long j = jiffies; /* snapshot */
 
 	/* restart counting in timer context on user request */
@@ -211,8 +211,8 @@ static void can_print_recv_banner(struct seq_file *m)
 static int can_stats_proc_show(struct seq_file *m, void *v)
 {
 	struct net *net = m->private;
-	struct s_stats *can_stats = net->can.can_stats;
-	struct s_pstats *can_pstats = net->can.can_pstats;
+	struct can_stats *can_stats = net->can.can_stats;
+	struct can_pstats *can_pstats = net->can.can_pstats;
 
 	seq_putc(m, '\n');
 	seq_printf(m, " %8ld transmitted frames (TXF)\n", can_stats->tx_frames);
@@ -286,8 +286,8 @@ static int can_stats_proc_open(struct inode *inode, struct file *file)
 static int can_reset_stats_proc_show(struct seq_file *m, void *v)
 {
 	struct net *net = m->private;
-	struct s_pstats *can_pstats = net->can.can_pstats;
-	struct s_stats *can_stats = net->can.can_stats;
+	struct can_pstats *can_pstats = net->can.can_pstats;
+	struct can_stats *can_stats = net->can.can_stats;
 
 	user_reset = 1;
 
-- 
1.9.1


From 085ef9e02512ef13f81f5b1ed8e08e17a6b13b69 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sat, 3 Jun 2017 20:10:03 +0200
Subject: [PATCH 003/113] can: af_can: give struct holding the CAN per device
 receive lists a sensible name

This patch adds a "can_" prefix to the "struct dev_rcv_lists" to better
reflect the meaning and improbe code readability.

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 include/net/netns/can.h |  4 ++--
 net/can/af_can.c        | 22 +++++++++++-----------
 net/can/af_can.h        |  2 +-
 net/can/proc.c          |  8 ++++----
 4 files changed, 18 insertions(+), 18 deletions(-)

diff --git a/include/net/netns/can.h b/include/net/netns/can.h
index 5ee0f88..0594d9e 100644
--- a/include/net/netns/can.h
+++ b/include/net/netns/can.h
@@ -7,7 +7,7 @@
 
 #include <linux/spinlock.h>
 
-struct dev_rcv_lists;
+struct can_dev_rcv_lists;
 struct can_stats;
 struct can_pstats;
 
@@ -27,7 +27,7 @@ struct netns_can {
 #endif
 
 	/* receive filters subscribed for 'all' CAN devices */
-	struct dev_rcv_lists *can_rx_alldev_list;
+	struct can_dev_rcv_lists *can_rx_alldev_list;
 	spinlock_t can_rcvlists_lock;
 	struct timer_list can_stattimer;/* timer for statistics update */
 	struct can_stats *can_stats; /* packet statistics */
diff --git a/net/can/af_can.c b/net/can/af_can.c
index bbd8a9b..2b12f71 100644
--- a/net/can/af_can.c
+++ b/net/can/af_can.c
@@ -321,13 +321,13 @@ int can_send(struct sk_buff *skb, int loop)
  * af_can rx path
  */
 
-static struct dev_rcv_lists *can_dev_rcv_lists_find(struct net *net,
-						    struct net_device *dev)
+static struct can_dev_rcv_lists *can_dev_rcv_lists_find(struct net *net,
+							struct net_device *dev)
 {
 	if (!dev)
 		return net->can.can_rx_alldev_list;
 	else
-		return (struct dev_rcv_lists *)dev->ml_priv;
+		return (struct can_dev_rcv_lists *)dev->ml_priv;
 }
 
 /**
@@ -381,7 +381,7 @@ static unsigned int effhash(canid_t can_id)
  *  Reduced can_id to have a preprocessed filter compare value.
  */
 static struct hlist_head *find_rcv_list(canid_t *can_id, canid_t *mask,
-					struct dev_rcv_lists *d)
+					struct can_dev_rcv_lists *d)
 {
 	canid_t inv = *can_id & CAN_INV_FILTER; /* save flag before masking */
 
@@ -464,7 +464,7 @@ int can_rx_register(struct net *net, struct net_device *dev, canid_t can_id,
 {
 	struct receiver *r;
 	struct hlist_head *rl;
-	struct dev_rcv_lists *d;
+	struct can_dev_rcv_lists *d;
 	struct can_pstats *can_pstats = net->can.can_pstats;
 	int err = 0;
 
@@ -542,7 +542,7 @@ void can_rx_unregister(struct net *net, struct net_device *dev, canid_t can_id,
 	struct receiver *r = NULL;
 	struct hlist_head *rl;
 	struct can_pstats *can_pstats = net->can.can_pstats;
-	struct dev_rcv_lists *d;
+	struct can_dev_rcv_lists *d;
 
 	if (dev && dev->type != ARPHRD_CAN)
 		return;
@@ -615,7 +615,7 @@ static inline void deliver(struct sk_buff *skb, struct receiver *r)
 	r->matches++;
 }
 
-static int can_rcv_filter(struct dev_rcv_lists *d, struct sk_buff *skb)
+static int can_rcv_filter(struct can_dev_rcv_lists *d, struct sk_buff *skb)
 {
 	struct receiver *r;
 	int matches = 0;
@@ -682,7 +682,7 @@ static int can_rcv_filter(struct dev_rcv_lists *d, struct sk_buff *skb)
 
 static void can_receive(struct sk_buff *skb, struct net_device *dev)
 {
-	struct dev_rcv_lists *d;
+	struct can_dev_rcv_lists *d;
 	struct net *net = dev_net(dev);
 	struct can_stats *can_stats = net->can.can_stats;
 	int matches;
@@ -829,7 +829,7 @@ static int can_notifier(struct notifier_block *nb, unsigned long msg,
 			void *ptr)
 {
 	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
-	struct dev_rcv_lists *d;
+	struct can_dev_rcv_lists *d;
 
 	if (dev->type != ARPHRD_CAN)
 		return NOTIFY_DONE;
@@ -874,7 +874,7 @@ static int can_pernet_init(struct net *net)
 {
 	spin_lock_init(&net->can.can_rcvlists_lock);
 	net->can.can_rx_alldev_list =
-		kzalloc(sizeof(struct dev_rcv_lists), GFP_KERNEL);
+		kzalloc(sizeof(struct can_dev_rcv_lists), GFP_KERNEL);
 	if (!net->can.can_rx_alldev_list)
 		goto out;
 	net->can.can_stats = kzalloc(sizeof(struct can_stats), GFP_KERNEL);
@@ -920,7 +920,7 @@ static void can_pernet_exit(struct net *net)
 	rcu_read_lock();
 	for_each_netdev_rcu(net, dev) {
 		if (dev->type == ARPHRD_CAN && dev->ml_priv) {
-			struct dev_rcv_lists *d = dev->ml_priv;
+			struct can_dev_rcv_lists *d = dev->ml_priv;
 
 			BUG_ON(d->entries);
 			kfree(d);
diff --git a/net/can/af_can.h b/net/can/af_can.h
index 4e2cb14..4b77c79 100644
--- a/net/can/af_can.h
+++ b/net/can/af_can.h
@@ -67,7 +67,7 @@ struct receiver {
 enum { RX_ERR, RX_ALL, RX_FIL, RX_INV, RX_MAX };
 
 /* per device receive filters linked at dev->ml_priv */
-struct dev_rcv_lists {
+struct can_dev_rcv_lists {
 	struct hlist_head rx[RX_MAX];
 	struct hlist_head rx_sff[CAN_SFF_RCV_ARRAY_SZ];
 	struct hlist_head rx_eff[CAN_EFF_RCV_ARRAY_SZ];
diff --git a/net/can/proc.c b/net/can/proc.c
index 559fca8..b06ea38 100644
--- a/net/can/proc.c
+++ b/net/can/proc.c
@@ -338,7 +338,7 @@ static int can_version_proc_open(struct inode *inode, struct file *file)
 
 static inline void can_rcvlist_proc_show_one(struct seq_file *m, int idx,
 					     struct net_device *dev,
-					     struct dev_rcv_lists *d)
+					     struct can_dev_rcv_lists *d)
 {
 	if (!hlist_empty(&d->rx[idx])) {
 		can_print_recv_banner(m);
@@ -353,7 +353,7 @@ static int can_rcvlist_proc_show(struct seq_file *m, void *v)
 	/* double cast to prevent GCC warning */
 	int idx = (int)(long)PDE_DATA(m->file->f_inode);
 	struct net_device *dev;
-	struct dev_rcv_lists *d;
+	struct can_dev_rcv_lists *d;
 	struct net *net = m->private;
 
 	seq_printf(m, "\nreceive list '%s':\n", rx_list_name[idx]);
@@ -417,7 +417,7 @@ static inline void can_rcvlist_proc_show_array(struct seq_file *m,
 static int can_rcvlist_sff_proc_show(struct seq_file *m, void *v)
 {
 	struct net_device *dev;
-	struct dev_rcv_lists *d;
+	struct can_dev_rcv_lists *d;
 	struct net *net = m->private;
 
 	/* RX_SFF */
@@ -461,7 +461,7 @@ static int can_rcvlist_sff_proc_open(struct inode *inode, struct file *file)
 static int can_rcvlist_eff_proc_show(struct seq_file *m, void *v)
 {
 	struct net_device *dev;
-	struct dev_rcv_lists *d;
+	struct can_dev_rcv_lists *d;
 	struct net *net = m->private;
 
 	/* RX_EFF */
-- 
1.9.1


From a1f3168435d5ff6605b3ea2b99ecbfff20e5a2ca Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 25 Jul 2017 15:30:35 +0200
Subject: [PATCH 004/113] can: af_can: give variable holding the CAN per device
 receive lists a sensible name

This patch gives the variables holding the CAN receive filter lists a
better name by renaming them from "d" to "dev_rcv_lists".

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/af_can.c | 87 ++++++++++++++++++++++++++++----------------------------
 1 file changed, 43 insertions(+), 44 deletions(-)

diff --git a/net/can/af_can.c b/net/can/af_can.c
index 2b12f71..43f4f51 100644
--- a/net/can/af_can.c
+++ b/net/can/af_can.c
@@ -381,7 +381,7 @@ static unsigned int effhash(canid_t can_id)
  *  Reduced can_id to have a preprocessed filter compare value.
  */
 static struct hlist_head *find_rcv_list(canid_t *can_id, canid_t *mask,
-					struct can_dev_rcv_lists *d)
+					struct can_dev_rcv_lists *dev_rcv_lists)
 {
 	canid_t inv = *can_id & CAN_INV_FILTER; /* save flag before masking */
 
@@ -389,7 +389,7 @@ static struct hlist_head *find_rcv_list(canid_t *can_id, canid_t *mask,
 	if (*mask & CAN_ERR_FLAG) {
 		/* clear CAN_ERR_FLAG in filter entry */
 		*mask &= CAN_ERR_MASK;
-		return &d->rx[RX_ERR];
+		return &dev_rcv_lists->rx[RX_ERR];
 	}
 
 	/* with cleared CAN_ERR_FLAG we have a simple mask/value filterpair */
@@ -405,11 +405,11 @@ static struct hlist_head *find_rcv_list(canid_t *can_id, canid_t *mask,
 
 	/* inverse can_id/can_mask filter */
 	if (inv)
-		return &d->rx[RX_INV];
+		return &dev_rcv_lists->rx[RX_INV];
 
 	/* mask == 0 => no condition testing at receive time */
 	if (!(*mask))
-		return &d->rx[RX_ALL];
+		return &dev_rcv_lists->rx[RX_ALL];
 
 	/* extra filterlists for the subscription of a single non-RTR can_id */
 	if (((*mask & CAN_EFF_RTR_FLAGS) == CAN_EFF_RTR_FLAGS) &&
@@ -417,15 +417,15 @@ static struct hlist_head *find_rcv_list(canid_t *can_id, canid_t *mask,
 
 		if (*can_id & CAN_EFF_FLAG) {
 			if (*mask == (CAN_EFF_MASK | CAN_EFF_RTR_FLAGS))
-				return &d->rx_eff[effhash(*can_id)];
+				return &dev_rcv_lists->rx_eff[effhash(*can_id)];
 		} else {
 			if (*mask == (CAN_SFF_MASK | CAN_EFF_RTR_FLAGS))
-				return &d->rx_sff[*can_id];
+				return &dev_rcv_lists->rx_sff[*can_id];
 		}
 	}
 
 	/* default: filter via can_id/can_mask */
-	return &d->rx[RX_FIL];
+	return &dev_rcv_lists->rx[RX_FIL];
 }
 
 /**
@@ -464,7 +464,7 @@ int can_rx_register(struct net *net, struct net_device *dev, canid_t can_id,
 {
 	struct receiver *r;
 	struct hlist_head *rl;
-	struct can_dev_rcv_lists *d;
+	struct can_dev_rcv_lists *dev_rcv_lists;
 	struct can_pstats *can_pstats = net->can.can_pstats;
 	int err = 0;
 
@@ -482,9 +482,9 @@ int can_rx_register(struct net *net, struct net_device *dev, canid_t can_id,
 
 	spin_lock(&net->can.can_rcvlists_lock);
 
-	d = can_dev_rcv_lists_find(net, dev);
-	if (d) {
-		rl = find_rcv_list(&can_id, &mask, d);
+	dev_rcv_lists = can_dev_rcv_lists_find(net, dev);
+	if (dev_rcv_lists) {
+		rl = find_rcv_list(&can_id, &mask, dev_rcv_lists);
 
 		r->can_id  = can_id;
 		r->mask    = mask;
@@ -495,7 +495,7 @@ int can_rx_register(struct net *net, struct net_device *dev, canid_t can_id,
 		r->sk      = sk;
 
 		hlist_add_head_rcu(&r->list, rl);
-		d->entries++;
+		dev_rcv_lists->entries++;
 
 		can_pstats->rcv_entries++;
 		if (can_pstats->rcv_entries_max < can_pstats->rcv_entries)
@@ -542,7 +542,7 @@ void can_rx_unregister(struct net *net, struct net_device *dev, canid_t can_id,
 	struct receiver *r = NULL;
 	struct hlist_head *rl;
 	struct can_pstats *can_pstats = net->can.can_pstats;
-	struct can_dev_rcv_lists *d;
+	struct can_dev_rcv_lists *dev_rcv_lists;
 
 	if (dev && dev->type != ARPHRD_CAN)
 		return;
@@ -552,22 +552,21 @@ void can_rx_unregister(struct net *net, struct net_device *dev, canid_t can_id,
 
 	spin_lock(&net->can.can_rcvlists_lock);
 
-	d = can_dev_rcv_lists_find(net, dev);
-	if (!d) {
+	dev_rcv_lists = can_dev_rcv_lists_find(net, dev);
+	if (!dev_rcv_lists) {
 		pr_err("BUG: receive list not found for "
 		       "dev %s, id %03X, mask %03X\n",
 		       DNAME(dev), can_id, mask);
 		goto out;
 	}
 
-	rl = find_rcv_list(&can_id, &mask, d);
+	rl = find_rcv_list(&can_id, &mask, dev_rcv_lists);
 
 	/*
 	 * Search the receiver list for the item to delete.  This should
 	 * exist, since no receiver may be unregistered that hasn't
 	 * been registered before.
 	 */
-
 	hlist_for_each_entry_rcu(r, rl, list) {
 		if (r->can_id == can_id && r->mask == mask &&
 		    r->func == func && r->data == data)
@@ -586,14 +585,14 @@ void can_rx_unregister(struct net *net, struct net_device *dev, canid_t can_id,
 	}
 
 	hlist_del_rcu(&r->list);
-	d->entries--;
+	dev_rcv_lists->entries--;
 
 	if (can_pstats->rcv_entries > 0)
 		can_pstats->rcv_entries--;
 
 	/* remove device structure requested by NETDEV_UNREGISTER */
-	if (d->remove_on_zero_entries && !d->entries) {
-		kfree(d);
+	if (dev_rcv_lists->remove_on_zero_entries && !dev_rcv_lists->entries) {
+		kfree(dev_rcv_lists);
 		dev->ml_priv = NULL;
 	}
 
@@ -615,19 +614,19 @@ static inline void deliver(struct sk_buff *skb, struct receiver *r)
 	r->matches++;
 }
 
-static int can_rcv_filter(struct can_dev_rcv_lists *d, struct sk_buff *skb)
+static int can_rcv_filter(struct can_dev_rcv_lists *dev_rcv_lists, struct sk_buff *skb)
 {
 	struct receiver *r;
 	int matches = 0;
 	struct can_frame *cf = (struct can_frame *)skb->data;
 	canid_t can_id = cf->can_id;
 
-	if (d->entries == 0)
+	if (dev_rcv_lists->entries == 0)
 		return 0;
 
 	if (can_id & CAN_ERR_FLAG) {
 		/* check for error message frame entries only */
-		hlist_for_each_entry_rcu(r, &d->rx[RX_ERR], list) {
+		hlist_for_each_entry_rcu(r, &dev_rcv_lists->rx[RX_ERR], list) {
 			if (can_id & r->mask) {
 				deliver(skb, r);
 				matches++;
@@ -637,13 +636,13 @@ static int can_rcv_filter(struct can_dev_rcv_lists *d, struct sk_buff *skb)
 	}
 
 	/* check for unfiltered entries */
-	hlist_for_each_entry_rcu(r, &d->rx[RX_ALL], list) {
+	hlist_for_each_entry_rcu(r, &dev_rcv_lists->rx[RX_ALL], list) {
 		deliver(skb, r);
 		matches++;
 	}
 
 	/* check for can_id/mask entries */
-	hlist_for_each_entry_rcu(r, &d->rx[RX_FIL], list) {
+	hlist_for_each_entry_rcu(r, &dev_rcv_lists->rx[RX_FIL], list) {
 		if ((can_id & r->mask) == r->can_id) {
 			deliver(skb, r);
 			matches++;
@@ -651,7 +650,7 @@ static int can_rcv_filter(struct can_dev_rcv_lists *d, struct sk_buff *skb)
 	}
 
 	/* check for inverted can_id/mask entries */
-	hlist_for_each_entry_rcu(r, &d->rx[RX_INV], list) {
+	hlist_for_each_entry_rcu(r, &dev_rcv_lists->rx[RX_INV], list) {
 		if ((can_id & r->mask) != r->can_id) {
 			deliver(skb, r);
 			matches++;
@@ -663,7 +662,7 @@ static int can_rcv_filter(struct can_dev_rcv_lists *d, struct sk_buff *skb)
 		return matches;
 
 	if (can_id & CAN_EFF_FLAG) {
-		hlist_for_each_entry_rcu(r, &d->rx_eff[effhash(can_id)], list) {
+		hlist_for_each_entry_rcu(r, &dev_rcv_lists->rx_eff[effhash(can_id)], list) {
 			if (r->can_id == can_id) {
 				deliver(skb, r);
 				matches++;
@@ -671,7 +670,7 @@ static int can_rcv_filter(struct can_dev_rcv_lists *d, struct sk_buff *skb)
 		}
 	} else {
 		can_id &= CAN_SFF_MASK;
-		hlist_for_each_entry_rcu(r, &d->rx_sff[can_id], list) {
+		hlist_for_each_entry_rcu(r, &dev_rcv_lists->rx_sff[can_id], list) {
 			deliver(skb, r);
 			matches++;
 		}
@@ -682,7 +681,7 @@ static int can_rcv_filter(struct can_dev_rcv_lists *d, struct sk_buff *skb)
 
 static void can_receive(struct sk_buff *skb, struct net_device *dev)
 {
-	struct can_dev_rcv_lists *d;
+	struct can_dev_rcv_lists *dev_rcv_lists;
 	struct net *net = dev_net(dev);
 	struct can_stats *can_stats = net->can.can_stats;
 	int matches;
@@ -701,9 +700,9 @@ static void can_receive(struct sk_buff *skb, struct net_device *dev)
 	matches = can_rcv_filter(net->can.can_rx_alldev_list, skb);
 
 	/* find receive list for this device */
-	d = can_dev_rcv_lists_find(net, dev);
-	if (d)
-		matches += can_rcv_filter(d, skb);
+	dev_rcv_lists = can_dev_rcv_lists_find(net, dev);
+	if (dev_rcv_lists)
+		matches += can_rcv_filter(dev_rcv_lists, skb);
 
 	rcu_read_unlock();
 
@@ -829,7 +828,7 @@ static int can_notifier(struct notifier_block *nb, unsigned long msg,
 			void *ptr)
 {
 	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
-	struct can_dev_rcv_lists *d;
+	struct can_dev_rcv_lists *dev_rcv_lists;
 
 	if (dev->type != ARPHRD_CAN)
 		return NOTIFY_DONE;
@@ -839,23 +838,23 @@ static int can_notifier(struct notifier_block *nb, unsigned long msg,
 	case NETDEV_REGISTER:
 
 		/* create new dev_rcv_lists for this device */
-		d = kzalloc(sizeof(*d), GFP_KERNEL);
-		if (!d)
+		dev_rcv_lists = kzalloc(sizeof(*dev_rcv_lists), GFP_KERNEL);
+		if (!dev_rcv_lists)
 			return NOTIFY_DONE;
 		BUG_ON(dev->ml_priv);
-		dev->ml_priv = d;
+		dev->ml_priv = dev_rcv_lists;
 
 		break;
 
 	case NETDEV_UNREGISTER:
 		spin_lock(&dev_net(dev)->can.can_rcvlists_lock);
 
-		d = dev->ml_priv;
-		if (d) {
-			if (d->entries)
-				d->remove_on_zero_entries = 1;
+		dev_rcv_lists = dev->ml_priv;
+		if (dev_rcv_lists) {
+			if (dev_rcv_lists->entries)
+				dev_rcv_lists->remove_on_zero_entries = 1;
 			else {
-				kfree(d);
+				kfree(dev_rcv_lists);
 				dev->ml_priv = NULL;
 			}
 		} else
@@ -920,10 +919,10 @@ static void can_pernet_exit(struct net *net)
 	rcu_read_lock();
 	for_each_netdev_rcu(net, dev) {
 		if (dev->type == ARPHRD_CAN && dev->ml_priv) {
-			struct can_dev_rcv_lists *d = dev->ml_priv;
+			struct can_dev_rcv_lists *dev_rcv_lists = dev->ml_priv;
 
-			BUG_ON(d->entries);
-			kfree(d);
+			BUG_ON(dev_rcv_lists->entries);
+			kfree(dev_rcv_lists);
 			dev->ml_priv = NULL;
 		}
 	}
-- 
1.9.1


From f6683f3a1772defd9dafdc599fea834aa9b3045d Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 25 Jul 2017 15:30:35 +0200
Subject: [PATCH 005/113] can: proc: give variable holding the CAN per device
 receive lists a sensible name

This patch gives the variables holding the CAN per device receive filter lists
a better name by renaming them from "d" to "dev_rcv_lists".

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/proc.c | 38 ++++++++++++++++++++------------------
 1 file changed, 20 insertions(+), 18 deletions(-)

diff --git a/net/can/proc.c b/net/can/proc.c
index b06ea38..966dd53 100644
--- a/net/can/proc.c
+++ b/net/can/proc.c
@@ -338,11 +338,11 @@ static int can_version_proc_open(struct inode *inode, struct file *file)
 
 static inline void can_rcvlist_proc_show_one(struct seq_file *m, int idx,
 					     struct net_device *dev,
-					     struct can_dev_rcv_lists *d)
+					     struct can_dev_rcv_lists *dev_rcv_lists)
 {
-	if (!hlist_empty(&d->rx[idx])) {
+	if (!hlist_empty(&dev_rcv_lists->rx[idx])) {
 		can_print_recv_banner(m);
-		can_print_rcvlist(m, &d->rx[idx], dev);
+		can_print_rcvlist(m, &dev_rcv_lists->rx[idx], dev);
 	} else
 		seq_printf(m, "  (%s: no entry)\n", DNAME(dev));
 
@@ -353,7 +353,7 @@ static int can_rcvlist_proc_show(struct seq_file *m, void *v)
 	/* double cast to prevent GCC warning */
 	int idx = (int)(long)PDE_DATA(m->file->f_inode);
 	struct net_device *dev;
-	struct can_dev_rcv_lists *d;
+	struct can_dev_rcv_lists *dev_rcv_lists;
 	struct net *net = m->private;
 
 	seq_printf(m, "\nreceive list '%s':\n", rx_list_name[idx]);
@@ -361,8 +361,8 @@ static int can_rcvlist_proc_show(struct seq_file *m, void *v)
 	rcu_read_lock();
 
 	/* receive list for 'all' CAN devices (dev == NULL) */
-	d = net->can.can_rx_alldev_list;
-	can_rcvlist_proc_show_one(m, idx, NULL, d);
+	dev_rcv_lists = net->can.can_rx_alldev_list;
+	can_rcvlist_proc_show_one(m, idx, NULL, dev_rcv_lists);
 
 	/* receive list for registered CAN devices */
 	for_each_netdev_rcu(net, dev) {
@@ -417,7 +417,7 @@ static inline void can_rcvlist_proc_show_array(struct seq_file *m,
 static int can_rcvlist_sff_proc_show(struct seq_file *m, void *v)
 {
 	struct net_device *dev;
-	struct can_dev_rcv_lists *d;
+	struct can_dev_rcv_lists *dev_rcv_lists;
 	struct net *net = m->private;
 
 	/* RX_SFF */
@@ -426,15 +426,16 @@ static int can_rcvlist_sff_proc_show(struct seq_file *m, void *v)
 	rcu_read_lock();
 
 	/* sff receive list for 'all' CAN devices (dev == NULL) */
-	d = net->can.can_rx_alldev_list;
-	can_rcvlist_proc_show_array(m, NULL, d->rx_sff, ARRAY_SIZE(d->rx_sff));
+	dev_rcv_lists = net->can.can_rx_alldev_list;
+	can_rcvlist_proc_show_array(m, NULL, dev_rcv_lists->rx_sff,
+				    ARRAY_SIZE(dev_rcv_lists->rx_sff));
 
 	/* sff receive list for registered CAN devices */
 	for_each_netdev_rcu(net, dev) {
 		if (dev->type == ARPHRD_CAN && dev->ml_priv) {
-			d = dev->ml_priv;
-			can_rcvlist_proc_show_array(m, dev, d->rx_sff,
-						    ARRAY_SIZE(d->rx_sff));
+			dev_rcv_lists = dev->ml_priv;
+			can_rcvlist_proc_show_array(m, dev, dev_rcv_lists->rx_sff,
+						    ARRAY_SIZE(dev_rcv_lists->rx_sff));
 		}
 	}
 
@@ -461,7 +462,7 @@ static int can_rcvlist_sff_proc_open(struct inode *inode, struct file *file)
 static int can_rcvlist_eff_proc_show(struct seq_file *m, void *v)
 {
 	struct net_device *dev;
-	struct can_dev_rcv_lists *d;
+	struct can_dev_rcv_lists *dev_rcv_lists;
 	struct net *net = m->private;
 
 	/* RX_EFF */
@@ -470,15 +471,16 @@ static int can_rcvlist_eff_proc_show(struct seq_file *m, void *v)
 	rcu_read_lock();
 
 	/* eff receive list for 'all' CAN devices (dev == NULL) */
-	d = net->can.can_rx_alldev_list;
-	can_rcvlist_proc_show_array(m, NULL, d->rx_eff, ARRAY_SIZE(d->rx_eff));
+	dev_rcv_lists = net->can.can_rx_alldev_list;
+	can_rcvlist_proc_show_array(m, NULL, dev_rcv_lists->rx_eff,
+				    ARRAY_SIZE(dev_rcv_lists->rx_eff));
 
 	/* eff receive list for registered CAN devices */
 	for_each_netdev_rcu(net, dev) {
 		if (dev->type == ARPHRD_CAN && dev->ml_priv) {
-			d = dev->ml_priv;
-			can_rcvlist_proc_show_array(m, dev, d->rx_eff,
-						    ARRAY_SIZE(d->rx_eff));
+			dev_rcv_lists = dev->ml_priv;
+			can_rcvlist_proc_show_array(m, dev, dev_rcv_lists->rx_eff,
+						    ARRAY_SIZE(dev_rcv_lists->rx_eff));
 		}
 	}
 
-- 
1.9.1


From 8eb4e7326064c1ccaabf77b22e50075b9f44a2b8 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sun, 30 Jul 2017 15:04:13 +0200
Subject: [PATCH 006/113] can: af_can: rename find_rcv_list() to
 can_rcv_list_find()

This patch add the commonly used prefix "can_" to the find_rcv_list()
function and add the "find" to the end, as the function returns a struct
rcv_list. This improves the overall readability of the code.

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/af_can.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/net/can/af_can.c b/net/can/af_can.c
index 43f4f51..0f13348 100644
--- a/net/can/af_can.c
+++ b/net/can/af_can.c
@@ -354,7 +354,7 @@ static unsigned int effhash(canid_t can_id)
 }
 
 /**
- * find_rcv_list - determine optimal filterlist inside device filter struct
+ * can_rcv_list_find - determine optimal filterlist inside device filter struct
  * @can_id: pointer to CAN identifier of a given can_filter
  * @mask: pointer to CAN mask of a given can_filter
  * @d: pointer to the device filter struct
@@ -380,8 +380,8 @@ static unsigned int effhash(canid_t can_id)
  *  Constistency checked mask.
  *  Reduced can_id to have a preprocessed filter compare value.
  */
-static struct hlist_head *find_rcv_list(canid_t *can_id, canid_t *mask,
-					struct can_dev_rcv_lists *dev_rcv_lists)
+static struct hlist_head *can_rcv_list_find(canid_t *can_id, canid_t *mask,
+					    struct can_dev_rcv_lists *dev_rcv_lists)
 {
 	canid_t inv = *can_id & CAN_INV_FILTER; /* save flag before masking */
 
@@ -484,7 +484,7 @@ int can_rx_register(struct net *net, struct net_device *dev, canid_t can_id,
 
 	dev_rcv_lists = can_dev_rcv_lists_find(net, dev);
 	if (dev_rcv_lists) {
-		rl = find_rcv_list(&can_id, &mask, dev_rcv_lists);
+		rl = can_rcv_list_find(&can_id, &mask, dev_rcv_lists);
 
 		r->can_id  = can_id;
 		r->mask    = mask;
@@ -560,7 +560,7 @@ void can_rx_unregister(struct net *net, struct net_device *dev, canid_t can_id,
 		goto out;
 	}
 
-	rl = find_rcv_list(&can_id, &mask, dev_rcv_lists);
+	rl = can_rcv_list_find(&can_id, &mask, dev_rcv_lists);
 
 	/*
 	 * Search the receiver list for the item to delete.  This should
-- 
1.9.1


From ed179089c9035c50c81e04b54edc8df58bd28287 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 25 Jul 2017 15:30:35 +0200
Subject: [PATCH 007/113] can: af_can: give variable holding the CAN receiver
 and the receiver list a sensible name

This patch gives the variables holding the CAN receiver and the receiver
list a better name by renaming them from "r to "rcv" and "rl" to
"recv_list".

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/af_can.c | 101 +++++++++++++++++++++++++++----------------------------
 1 file changed, 50 insertions(+), 51 deletions(-)

diff --git a/net/can/af_can.c b/net/can/af_can.c
index 0f13348..cb079d2 100644
--- a/net/can/af_can.c
+++ b/net/can/af_can.c
@@ -462,8 +462,8 @@ int can_rx_register(struct net *net, struct net_device *dev, canid_t can_id,
 		    canid_t mask, void (*func)(struct sk_buff *, void *),
 		    void *data, char *ident, struct sock *sk)
 {
-	struct receiver *r;
-	struct hlist_head *rl;
+	struct receiver *rcv;
+	struct hlist_head *rcv_list;
 	struct can_dev_rcv_lists *dev_rcv_lists;
 	struct can_pstats *can_pstats = net->can.can_pstats;
 	int err = 0;
@@ -476,32 +476,32 @@ int can_rx_register(struct net *net, struct net_device *dev, canid_t can_id,
 	if (dev && !net_eq(net, dev_net(dev)))
 		return -ENODEV;
 
-	r = kmem_cache_alloc(rcv_cache, GFP_KERNEL);
-	if (!r)
+	rcv = kmem_cache_alloc(rcv_cache, GFP_KERNEL);
+	if (!rcv)
 		return -ENOMEM;
 
 	spin_lock(&net->can.can_rcvlists_lock);
 
 	dev_rcv_lists = can_dev_rcv_lists_find(net, dev);
 	if (dev_rcv_lists) {
-		rl = can_rcv_list_find(&can_id, &mask, dev_rcv_lists);
+		rcv_list = can_rcv_list_find(&can_id, &mask, dev_rcv_lists);
 
-		r->can_id  = can_id;
-		r->mask    = mask;
-		r->matches = 0;
-		r->func    = func;
-		r->data    = data;
-		r->ident   = ident;
-		r->sk      = sk;
+		rcv->can_id = can_id;
+		rcv->mask = mask;
+		rcv->matches = 0;
+		rcv->func = func;
+		rcv->data = data;
+		rcv->ident = ident;
+		rcv->sk = sk;
 
-		hlist_add_head_rcu(&r->list, rl);
+		hlist_add_head_rcu(&rcv->list, rcv_list);
 		dev_rcv_lists->entries++;
 
 		can_pstats->rcv_entries++;
 		if (can_pstats->rcv_entries_max < can_pstats->rcv_entries)
 			can_pstats->rcv_entries_max = can_pstats->rcv_entries;
 	} else {
-		kmem_cache_free(rcv_cache, r);
+		kmem_cache_free(rcv_cache, rcv);
 		err = -ENODEV;
 	}
 
@@ -516,10 +516,10 @@ int can_rx_register(struct net *net, struct net_device *dev, canid_t can_id,
  */
 static void can_rx_delete_receiver(struct rcu_head *rp)
 {
-	struct receiver *r = container_of(rp, struct receiver, rcu);
-	struct sock *sk = r->sk;
+	struct receiver *rcv = container_of(rp, struct receiver, rcu);
+	struct sock *sk = rcv->sk;
 
-	kmem_cache_free(rcv_cache, r);
+	kmem_cache_free(rcv_cache, rcv);
 	if (sk)
 		sock_put(sk);
 }
@@ -539,8 +539,8 @@ void can_rx_unregister(struct net *net, struct net_device *dev, canid_t can_id,
 		       canid_t mask, void (*func)(struct sk_buff *, void *),
 		       void *data)
 {
-	struct receiver *r = NULL;
-	struct hlist_head *rl;
+	struct receiver *rcv = NULL;
+	struct hlist_head *rcv_list;
 	struct can_pstats *can_pstats = net->can.can_pstats;
 	struct can_dev_rcv_lists *dev_rcv_lists;
 
@@ -560,31 +560,30 @@ void can_rx_unregister(struct net *net, struct net_device *dev, canid_t can_id,
 		goto out;
 	}
 
-	rl = can_rcv_list_find(&can_id, &mask, dev_rcv_lists);
+	rcv_list = can_rcv_list_find(&can_id, &mask, dev_rcv_lists);
 
 	/*
 	 * Search the receiver list for the item to delete.  This should
 	 * exist, since no receiver may be unregistered that hasn't
 	 * been registered before.
 	 */
-	hlist_for_each_entry_rcu(r, rl, list) {
-		if (r->can_id == can_id && r->mask == mask &&
-		    r->func == func && r->data == data)
+	hlist_for_each_entry_rcu(rcv, rcv_list, list) {
+		if (rcv->can_id == can_id && rcv->mask == mask &&
+		    rcv->func == func && rcv->data == data)
 			break;
 	}
 
 	/*
 	 * Check for bugs in CAN protocol implementations using af_can.c:
-	 * 'r' will be NULL if no matching list item was found for removal.
+	 * 'rcv' will be NULL if no matching list item was found for removal.
 	 */
-
-	if (!r) {
+	if (!rcv) {
 		WARN(1, "BUG: receive list entry not found for dev %s, "
 		     "id %03X, mask %03X\n", DNAME(dev), can_id, mask);
 		goto out;
 	}
 
-	hlist_del_rcu(&r->list);
+	hlist_del_rcu(&rcv->list);
 	dev_rcv_lists->entries--;
 
 	if (can_pstats->rcv_entries > 0)
@@ -600,23 +599,23 @@ void can_rx_unregister(struct net *net, struct net_device *dev, canid_t can_id,
 	spin_unlock(&net->can.can_rcvlists_lock);
 
 	/* schedule the receiver item for deletion */
-	if (r) {
-		if (r->sk)
-			sock_hold(r->sk);
-		call_rcu(&r->rcu, can_rx_delete_receiver);
+	if (rcv) {
+		if (rcv->sk)
+			sock_hold(rcv->sk);
+		call_rcu(&rcv->rcu, can_rx_delete_receiver);
 	}
 }
 EXPORT_SYMBOL(can_rx_unregister);
 
-static inline void deliver(struct sk_buff *skb, struct receiver *r)
+static inline void deliver(struct sk_buff *skb, struct receiver *rcv)
 {
-	r->func(skb, r->data);
-	r->matches++;
+	rcv->func(skb, rcv->data);
+	rcv->matches++;
 }
 
 static int can_rcv_filter(struct can_dev_rcv_lists *dev_rcv_lists, struct sk_buff *skb)
 {
-	struct receiver *r;
+	struct receiver *rcv;
 	int matches = 0;
 	struct can_frame *cf = (struct can_frame *)skb->data;
 	canid_t can_id = cf->can_id;
@@ -626,9 +625,9 @@ static int can_rcv_filter(struct can_dev_rcv_lists *dev_rcv_lists, struct sk_buf
 
 	if (can_id & CAN_ERR_FLAG) {
 		/* check for error message frame entries only */
-		hlist_for_each_entry_rcu(r, &dev_rcv_lists->rx[RX_ERR], list) {
-			if (can_id & r->mask) {
-				deliver(skb, r);
+		hlist_for_each_entry_rcu(rcv, &dev_rcv_lists->rx[RX_ERR], list) {
+			if (can_id & rcv->mask) {
+				deliver(skb, rcv);
 				matches++;
 			}
 		}
@@ -636,23 +635,23 @@ static int can_rcv_filter(struct can_dev_rcv_lists *dev_rcv_lists, struct sk_buf
 	}
 
 	/* check for unfiltered entries */
-	hlist_for_each_entry_rcu(r, &dev_rcv_lists->rx[RX_ALL], list) {
-		deliver(skb, r);
+	hlist_for_each_entry_rcu(rcv, &dev_rcv_lists->rx[RX_ALL], list) {
+		deliver(skb, rcv);
 		matches++;
 	}
 
 	/* check for can_id/mask entries */
-	hlist_for_each_entry_rcu(r, &dev_rcv_lists->rx[RX_FIL], list) {
-		if ((can_id & r->mask) == r->can_id) {
-			deliver(skb, r);
+	hlist_for_each_entry_rcu(rcv, &dev_rcv_lists->rx[RX_FIL], list) {
+		if ((can_id & rcv->mask) == rcv->can_id) {
+			deliver(skb, rcv);
 			matches++;
 		}
 	}
 
 	/* check for inverted can_id/mask entries */
-	hlist_for_each_entry_rcu(r, &dev_rcv_lists->rx[RX_INV], list) {
-		if ((can_id & r->mask) != r->can_id) {
-			deliver(skb, r);
+	hlist_for_each_entry_rcu(rcv, &dev_rcv_lists->rx[RX_INV], list) {
+		if ((can_id & rcv->mask) != rcv->can_id) {
+			deliver(skb, rcv);
 			matches++;
 		}
 	}
@@ -662,16 +661,16 @@ static int can_rcv_filter(struct can_dev_rcv_lists *dev_rcv_lists, struct sk_buf
 		return matches;
 
 	if (can_id & CAN_EFF_FLAG) {
-		hlist_for_each_entry_rcu(r, &dev_rcv_lists->rx_eff[effhash(can_id)], list) {
-			if (r->can_id == can_id) {
-				deliver(skb, r);
+		hlist_for_each_entry_rcu(rcv, &dev_rcv_lists->rx_eff[effhash(can_id)], list) {
+			if (rcv->can_id == can_id) {
+				deliver(skb, rcv);
 				matches++;
 			}
 		}
 	} else {
 		can_id &= CAN_SFF_MASK;
-		hlist_for_each_entry_rcu(r, &dev_rcv_lists->rx_sff[can_id], list) {
-			deliver(skb, r);
+		hlist_for_each_entry_rcu(rcv, &dev_rcv_lists->rx_sff[can_id], list) {
+			deliver(skb, rcv);
 			matches++;
 		}
 	}
-- 
1.9.1


From d58037a5df7be451ddaf849a285f69b35fc1e9ef Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sun, 4 Jun 2017 13:24:52 +0200
Subject: [PATCH 008/113] can: af_can: can_rx_register(): use max() instead of
 open coding it

This patch replaces an open coded max by the proper kernel define max().

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/af_can.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/net/can/af_can.c b/net/can/af_can.c
index cb079d2..e3df12c 100644
--- a/net/can/af_can.c
+++ b/net/can/af_can.c
@@ -498,8 +498,8 @@ int can_rx_register(struct net *net, struct net_device *dev, canid_t can_id,
 		dev_rcv_lists->entries++;
 
 		can_pstats->rcv_entries++;
-		if (can_pstats->rcv_entries_max < can_pstats->rcv_entries)
-			can_pstats->rcv_entries_max = can_pstats->rcv_entries;
+		can_pstats->rcv_entries_max = max(can_pstats->rcv_entries_max,
+						  can_pstats->rcv_entries);
 	} else {
 		kmem_cache_free(rcv_cache, rcv);
 		err = -ENODEV;
-- 
1.9.1


From d74378fe723567c854548fc987d832c10880e7bb Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sun, 30 Jul 2017 22:01:37 +0200
Subject: [PATCH 009/113] can: raw: use struct sock::sk_bound_dev_if instead of
 struct raw_sock::ifindex

This patch removes the struct raw_sock::ifindex from the CAN raw socket
and uses the already existing sock::sk_bound_dev_if instead.

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/raw.c | 33 +++++++++++++++------------------
 1 file changed, 15 insertions(+), 18 deletions(-)

diff --git a/net/can/raw.c b/net/can/raw.c
index 864c80d..80a1545 100644
--- a/net/can/raw.c
+++ b/net/can/raw.c
@@ -83,7 +83,6 @@ struct uniqframe {
 struct raw_sock {
 	struct sock sk;
 	int bound;
-	int ifindex;
 	struct notifier_block notifier;
 	int loopback;
 	int recv_own_msgs;
@@ -279,7 +278,7 @@ static int raw_notifier(struct notifier_block *nb,
 	if (dev->type != ARPHRD_CAN)
 		return NOTIFY_DONE;
 
-	if (ro->ifindex != dev->ifindex)
+	if (sk->sk_bound_dev_if != dev->ifindex)
 		return NOTIFY_DONE;
 
 	switch (msg) {
@@ -293,7 +292,7 @@ static int raw_notifier(struct notifier_block *nb,
 		if (ro->count > 1)
 			kfree(ro->filter);
 
-		ro->ifindex = 0;
+		sk->sk_bound_dev_if = 0;
 		ro->bound   = 0;
 		ro->count   = 0;
 		release_sock(sk);
@@ -318,7 +317,6 @@ static int raw_init(struct sock *sk)
 	struct raw_sock *ro = raw_sk(sk);
 
 	ro->bound            = 0;
-	ro->ifindex          = 0;
 
 	/* set default filter to single entry dfilter */
 	ro->dfilter.can_id   = 0;
@@ -361,10 +359,10 @@ static int raw_release(struct socket *sock)
 
 	/* remove current filters & unregister */
 	if (ro->bound) {
-		if (ro->ifindex) {
+		if (sk->sk_bound_dev_if) {
 			struct net_device *dev;
 
-			dev = dev_get_by_index(sock_net(sk), ro->ifindex);
+			dev = dev_get_by_index(sock_net(sk), sk->sk_bound_dev_if);
 			if (dev) {
 				raw_disable_allfilters(dev_net(dev), dev, sk);
 				dev_put(dev);
@@ -376,7 +374,7 @@ static int raw_release(struct socket *sock)
 	if (ro->count > 1)
 		kfree(ro->filter);
 
-	ro->ifindex = 0;
+	sk->sk_bound_dev_if = 0;
 	ro->bound   = 0;
 	ro->count   = 0;
 	free_percpu(ro->uniq);
@@ -404,7 +402,7 @@ static int raw_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 
 	lock_sock(sk);
 
-	if (ro->bound && addr->can_ifindex == ro->ifindex)
+	if (ro->bound && addr->can_ifindex == sk->sk_bound_dev_if)
 		goto out;
 
 	if (addr->can_ifindex) {
@@ -438,11 +436,11 @@ static int raw_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 	if (!err) {
 		if (ro->bound) {
 			/* unregister old filters */
-			if (ro->ifindex) {
+			if (sk->sk_bound_dev_if) {
 				struct net_device *dev;
 
 				dev = dev_get_by_index(sock_net(sk),
-						       ro->ifindex);
+						       sk->sk_bound_dev_if);
 				if (dev) {
 					raw_disable_allfilters(dev_net(dev),
 							       dev, sk);
@@ -451,7 +449,7 @@ static int raw_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 			} else
 				raw_disable_allfilters(sock_net(sk), NULL, sk);
 		}
-		ro->ifindex = ifindex;
+		sk->sk_bound_dev_if = ifindex;
 		ro->bound = 1;
 	}
 
@@ -472,14 +470,13 @@ static int raw_getname(struct socket *sock, struct sockaddr *uaddr,
 {
 	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
 	struct sock *sk = sock->sk;
-	struct raw_sock *ro = raw_sk(sk);
 
 	if (peer)
 		return -EOPNOTSUPP;
 
 	memset(addr, 0, sizeof(*addr));
 	addr->can_family  = AF_CAN;
-	addr->can_ifindex = ro->ifindex;
+	addr->can_ifindex = sk->sk_bound_dev_if;
 
 	*len = sizeof(*addr);
 
@@ -524,8 +521,8 @@ static int raw_setsockopt(struct socket *sock, int level, int optname,
 
 		lock_sock(sk);
 
-		if (ro->bound && ro->ifindex)
-			dev = dev_get_by_index(sock_net(sk), ro->ifindex);
+		if (ro->bound && sk->sk_bound_dev_if)
+			dev = dev_get_by_index(sock_net(sk), sk->sk_bound_dev_if);
 
 		if (ro->bound) {
 			/* (try to) register the new filters */
@@ -578,8 +575,8 @@ static int raw_setsockopt(struct socket *sock, int level, int optname,
 
 		lock_sock(sk);
 
-		if (ro->bound && ro->ifindex)
-			dev = dev_get_by_index(sock_net(sk), ro->ifindex);
+		if (ro->bound && sk->sk_bound_dev_if)
+			dev = dev_get_by_index(sock_net(sk), sk->sk_bound_dev_if);
 
 		/* remove current error mask */
 		if (ro->bound) {
@@ -743,7 +740,7 @@ static int raw_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 
 		ifindex = addr->can_ifindex;
 	} else
-		ifindex = ro->ifindex;
+		ifindex = sk->sk_bound_dev_if;
 
 	if (ro->fd_frames) {
 		if (unlikely(size != CANFD_MTU && size != CAN_MTU))
-- 
1.9.1


From 0dced6eee159f3cc5cddabeb21f411d42c983a8c Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sun, 30 Jul 2017 23:51:01 +0200
Subject: [PATCH 010/113] can: raw: raw_bind: bail out if can_family is not
 AF_CAN

Until now CAN raw's bind() doesn't check if the can_familiy in the
struct sockaddr_can is set to AF_CAN. This patch adds the missing check.

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/raw.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/net/can/raw.c b/net/can/raw.c
index 80a1545..014874b 100644
--- a/net/can/raw.c
+++ b/net/can/raw.c
@@ -399,6 +399,8 @@ static int raw_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 
 	if (len < sizeof(*addr))
 		return -EINVAL;
+	if (addr->can_family != AF_CAN)
+		return -EINVAL;
 
 	lock_sock(sk);
 
-- 
1.9.1


From 9bf121e24d857a195588bd5da9601ef56cb40f57 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 6 Jun 2017 15:47:48 +0200
Subject: [PATCH 011/113] can: af_can: can_pernet_exit(): no need to iterate
 over and cleanup registered CAN devices

The networking core takes care and unregisters every network device in
a namespace before calling the can_pernet_exit() hook. This patch
removes the unneeded cleanup.

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/af_can.c | 15 ---------------
 1 file changed, 15 deletions(-)

diff --git a/net/can/af_can.c b/net/can/af_can.c
index e3df12c..d781b93 100644
--- a/net/can/af_can.c
+++ b/net/can/af_can.c
@@ -906,27 +906,12 @@ static int can_pernet_init(struct net *net)
 
 static void can_pernet_exit(struct net *net)
 {
-	struct net_device *dev;
-
 	if (IS_ENABLED(CONFIG_PROC_FS)) {
 		can_remove_proc(net);
 		if (stats_timer)
 			del_timer_sync(&net->can.can_stattimer);
 	}
 
-	/* remove created dev_rcv_lists from still registered CAN devices */
-	rcu_read_lock();
-	for_each_netdev_rcu(net, dev) {
-		if (dev->type == ARPHRD_CAN && dev->ml_priv) {
-			struct can_dev_rcv_lists *dev_rcv_lists = dev->ml_priv;
-
-			BUG_ON(dev_rcv_lists->entries);
-			kfree(dev_rcv_lists);
-			dev->ml_priv = NULL;
-		}
-	}
-	rcu_read_unlock();
-
 	kfree(net->can.can_rx_alldev_list);
 	kfree(net->can.can_stats);
 	kfree(net->can.can_pstats);
-- 
1.9.1


From 59149a9d4fa43af8487df1ce49b291c05b17ded6 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sun, 30 Jul 2017 14:31:31 +0200
Subject: [PATCH 012/113] can: introduce CAN midlayer private and allocate it
 automatically

This patch introduces the CAN midlayer private structure ("struct
can_ml_priv") which should be used to hold protocol specific per device
data structures. For now its only member is "struct can_dev_rcv_lists".

The CAN midlayer private is allocated via alloc_netdev()'s private and
assigned to "struct net_device::ml_priv" during device creation. This is
done transparently for CAN drivers using alloc_candev(). The slcan, vcan
and vxcan drivers which are not using alloc_candev() have been adopted
manually. The memory layout of the netdev_priv allocated via
alloc_candev() will look like this:

  +-------------------------+
  | driver's priv           |
  +-------------------------+
  | struct can_ml_priv      |
  +-------------------------+
  | array of struct sk_buff |
  +-------------------------+

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 drivers/net/can/dev.c      | 22 ++++++++++++++++++----
 drivers/net/can/slcan.c    |  4 +++-
 drivers/net/can/vcan.c     |  6 ++++--
 drivers/net/can/vxcan.c    |  2 +-
 include/linux/can/can-ml.h | 23 +++++++++++++++++++++++
 5 files changed, 49 insertions(+), 8 deletions(-)
 create mode 100644 include/linux/can/can-ml.h

diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c
index 365a8cc..85a6367 100644
--- a/drivers/net/can/dev.c
+++ b/drivers/net/can/dev.c
@@ -23,6 +23,7 @@
 #include <linux/if_arp.h>
 #include <linux/workqueue.h>
 #include <linux/can.h>
+#include <linux/can/can-ml.h>
 #include <linux/can/dev.h>
 #include <linux/can/skb.h>
 #include <linux/can/netlink.h>
@@ -708,11 +709,24 @@ struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max)
 	struct can_priv *priv;
 	int size;
 
+	/* We put the driver's priv, the CAN mid layer priv and the
+	 * echo skb into the netdevice's priv. The memory layout for
+	 * the netdev_priv is like this:
+	 *
+	 * +-------------------------+
+	 * | driver's priv           |
+	 * +-------------------------+
+	 * | struct can_ml_priv      |
+	 * +-------------------------+
+	 * | array of struct sk_buff |
+	 * +-------------------------+
+	 */
+
+	size = ALIGN(sizeof_priv, NETDEV_ALIGN) + sizeof(struct can_ml_priv);
+
 	if (echo_skb_max)
-		size = ALIGN(sizeof_priv, sizeof(struct sk_buff *)) +
+		size = ALIGN(size, sizeof(struct sk_buff *)) +
 			echo_skb_max * sizeof(struct sk_buff *);
-	else
-		size = sizeof_priv;
 
 	dev = alloc_netdev(size, "can%d", NET_NAME_UNKNOWN, can_setup);
 	if (!dev)
@@ -724,7 +738,7 @@ struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max)
 	if (echo_skb_max) {
 		priv->echo_skb_max = echo_skb_max;
 		priv->echo_skb = (void *)priv +
-			ALIGN(sizeof_priv, sizeof(struct sk_buff *));
+			(size - echo_skb_max * sizeof(struct sk_buff *));
 	}
 
 	priv->state = CAN_STATE_STOPPED;
diff --git a/drivers/net/can/slcan.c b/drivers/net/can/slcan.c
index 5d067c1..f1647b4 100644
--- a/drivers/net/can/slcan.c
+++ b/drivers/net/can/slcan.c
@@ -514,6 +514,7 @@ static struct slcan *slc_alloc(dev_t line)
 	char name[IFNAMSIZ];
 	struct net_device *dev = NULL;
 	struct slcan       *sl;
+	int size;
 
 	for (i = 0; i < maxdev; i++) {
 		dev = slcan_devs[i];
@@ -527,7 +528,8 @@ static struct slcan *slc_alloc(dev_t line)
 		return NULL;
 
 	sprintf(name, "slcan%d", i);
-	dev = alloc_netdev(sizeof(*sl), name, NET_NAME_UNKNOWN, slc_setup);
+	size = ALIGN(sizeof(*sl), NETDEV_ALIGN) + sizeof(struct can_ml_priv);
+	dev = alloc_netdev(size, name, NET_NAME_UNKNOWN, slc_setup);
 	if (!dev)
 		return NULL;
 
diff --git a/drivers/net/can/vcan.c b/drivers/net/can/vcan.c
index a8cb332..96e42ea 100644
--- a/drivers/net/can/vcan.c
+++ b/drivers/net/can/vcan.c
@@ -45,6 +45,7 @@
 #include <linux/if_arp.h>
 #include <linux/if_ether.h>
 #include <linux/can.h>
+#include <linux/can/can-ml.h>
 #include <linux/can/dev.h>
 #include <linux/can/skb.h>
 #include <linux/slab.h>
@@ -167,8 +168,9 @@ static void vcan_setup(struct net_device *dev)
 }
 
 static struct rtnl_link_ops vcan_link_ops __read_mostly = {
-	.kind	= DRV_NAME,
-	.setup	= vcan_setup,
+	.kind = DRV_NAME,
+	.priv_size = sizeof(struct can_ml_priv),
+	.setup = vcan_setup,
 };
 
 static __init int vcan_init_module(void)
diff --git a/drivers/net/can/vxcan.c b/drivers/net/can/vxcan.c
index 8404e88..8925d79 100644
--- a/drivers/net/can/vxcan.c
+++ b/drivers/net/can/vxcan.c
@@ -292,7 +292,7 @@ static struct net *vxcan_get_link_net(const struct net_device *dev)
 
 static struct rtnl_link_ops vxcan_link_ops = {
 	.kind		= DRV_NAME,
-	.priv_size	= sizeof(struct vxcan_priv),
+	.priv_size	= ALIGN(sizeof(struct vxcan_priv), NETDEV_ALIGN) + sizeof(struct can_ml_priv);
 	.setup		= vxcan_setup,
 	.newlink	= vxcan_newlink,
 	.dellink	= vxcan_dellink,
diff --git a/include/linux/can/can-ml.h b/include/linux/can/can-ml.h
new file mode 100644
index 0000000..2786b04
--- /dev/null
+++ b/include/linux/can/can-ml.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2017 Pengutronix, Marc Kleine-Budde <kernel@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef CAN_ML_H
+#define CAN_ML_H
+
+#include "../../net/can/af_can.h"
+
+struct can_ml_priv {
+	struct can_dev_rcv_lists dev_rcv_lists;
+};
+
+#endif /* CAN_ML_H */
-- 
1.9.1


From 8d3a485a07c88126c3ebc6d6208efa9cddc3ea8e Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sun, 30 Jul 2017 16:38:07 +0200
Subject: [PATCH 013/113] can: make use of preallocated can_ml_priv for per
 device struct can_dev_rcv_lists

This patch removes the old method of allocating the per device protocol
specific memory via a netdevice_notifier. This had the drawback, that
the allocation can fail, leading to a lot of null pointer checks in the
code. This also makes the live cycle management of this memory quite
complicated.

This patch switches from the allocating the struct can_dev_rcv_lists in
a NETDEV_REGISTER call to using the dev->ml_priv, which is allocated by
the driver since the previous patch.

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 drivers/net/can/dev.c   |  2 ++
 drivers/net/can/slcan.c |  1 +
 drivers/net/can/vcan.c  |  1 +
 drivers/net/can/vxcan.c |  1 +
 net/can/af_can.c        | 45 ++++++++-------------------------------------
 net/can/af_can.h        |  1 -
 6 files changed, 13 insertions(+), 38 deletions(-)

diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c
index 85a6367..89f9a05 100644
--- a/drivers/net/can/dev.c
+++ b/drivers/net/can/dev.c
@@ -735,6 +735,8 @@ struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max)
 	priv = netdev_priv(dev);
 	priv->dev = dev;
 
+	dev->ml_priv = (void *)priv + ALIGN(sizeof_priv, NETDEV_ALIGN);
+
 	if (echo_skb_max) {
 		priv->echo_skb_max = echo_skb_max;
 		priv->echo_skb = (void *)priv +
diff --git a/drivers/net/can/slcan.c b/drivers/net/can/slcan.c
index f1647b4..38e8271 100644
--- a/drivers/net/can/slcan.c
+++ b/drivers/net/can/slcan.c
@@ -535,6 +535,7 @@ static struct slcan *slc_alloc(dev_t line)
 
 	dev->base_addr  = i;
 	sl = netdev_priv(dev);
+	dev->ml_priv = (void *)sl + ALIGN(sizeof(*sl), NETDEV_ALIGN);
 
 	/* Initialize channel control data */
 	sl->magic = SLCAN_MAGIC;
diff --git a/drivers/net/can/vcan.c b/drivers/net/can/vcan.c
index 96e42ea..ff388f0 100644
--- a/drivers/net/can/vcan.c
+++ b/drivers/net/can/vcan.c
@@ -158,6 +158,7 @@ static void vcan_setup(struct net_device *dev)
 	dev->addr_len		= 0;
 	dev->tx_queue_len	= 0;
 	dev->flags		= IFF_NOARP;
+	dev->ml_priv		= netdev_priv(dev);
 
 	/* set flags according to driver capabilities */
 	if (echo)
diff --git a/drivers/net/can/vxcan.c b/drivers/net/can/vxcan.c
index 8925d79..ed92932 100644
--- a/drivers/net/can/vxcan.c
+++ b/drivers/net/can/vxcan.c
@@ -157,6 +157,7 @@ static void vxcan_setup(struct net_device *dev)
 	dev->flags		= (IFF_NOARP|IFF_ECHO);
 	dev->netdev_ops		= &vxcan_netdev_ops;
 	dev->needs_free_netdev	= true;
+	dev->ml_priv		= netdev_priv(dev) + ALIGN(sizeof(struct vxcan_priv), NETDEV_ALIGN);
 }
 
 /* forward declaration for rtnl_create_link() */
diff --git a/net/can/af_can.c b/net/can/af_can.c
index d781b93..c3eac4a 100644
--- a/net/can/af_can.c
+++ b/net/can/af_can.c
@@ -58,6 +58,7 @@
 #include <linux/can.h>
 #include <linux/can/core.h>
 #include <linux/can/skb.h>
+#include <linux/can/can-ml.h>
 #include <linux/ratelimit.h>
 #include <net/net_namespace.h>
 #include <net/sock.h>
@@ -324,10 +325,12 @@ int can_send(struct sk_buff *skb, int loop)
 static struct can_dev_rcv_lists *can_dev_rcv_lists_find(struct net *net,
 							struct net_device *dev)
 {
-	if (!dev)
+	if (dev) {
+		struct can_ml_priv *ml_priv = dev->ml_priv;
+		return &ml_priv->dev_rcv_lists;
+	} else {
 		return net->can.can_rx_alldev_list;
-	else
-		return (struct can_dev_rcv_lists *)dev->ml_priv;
+	}
 }
 
 /**
@@ -589,12 +592,6 @@ void can_rx_unregister(struct net *net, struct net_device *dev, canid_t can_id,
 	if (can_pstats->rcv_entries > 0)
 		can_pstats->rcv_entries--;
 
-	/* remove device structure requested by NETDEV_UNREGISTER */
-	if (dev_rcv_lists->remove_on_zero_entries && !dev_rcv_lists->entries) {
-		kfree(dev_rcv_lists);
-		dev->ml_priv = NULL;
-	}
-
  out:
 	spin_unlock(&net->can.can_rcvlists_lock);
 
@@ -827,7 +824,6 @@ static int can_notifier(struct notifier_block *nb, unsigned long msg,
 			void *ptr)
 {
 	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
-	struct can_dev_rcv_lists *dev_rcv_lists;
 
 	if (dev->type != ARPHRD_CAN)
 		return NOTIFY_DONE;
@@ -835,33 +831,8 @@ static int can_notifier(struct notifier_block *nb, unsigned long msg,
 	switch (msg) {
 
 	case NETDEV_REGISTER:
-
-		/* create new dev_rcv_lists for this device */
-		dev_rcv_lists = kzalloc(sizeof(*dev_rcv_lists), GFP_KERNEL);
-		if (!dev_rcv_lists)
-			return NOTIFY_DONE;
-		BUG_ON(dev->ml_priv);
-		dev->ml_priv = dev_rcv_lists;
-
-		break;
-
-	case NETDEV_UNREGISTER:
-		spin_lock(&dev_net(dev)->can.can_rcvlists_lock);
-
-		dev_rcv_lists = dev->ml_priv;
-		if (dev_rcv_lists) {
-			if (dev_rcv_lists->entries)
-				dev_rcv_lists->remove_on_zero_entries = 1;
-			else {
-				kfree(dev_rcv_lists);
-				dev->ml_priv = NULL;
-			}
-		} else
-			pr_err("can: notifier: receive list not found for dev "
-			       "%s\n", dev->name);
-
-		spin_unlock(&dev_net(dev)->can.can_rcvlists_lock);
-
+		WARN(!dev->ml_priv,
+		     "No CAN mid layer private allocated, please fix your driver and use alloc_candev()!\n");
 		break;
 	}
 
diff --git a/net/can/af_can.h b/net/can/af_can.h
index 4b77c79..dc198a0 100644
--- a/net/can/af_can.h
+++ b/net/can/af_can.h
@@ -71,7 +71,6 @@ struct can_dev_rcv_lists {
 	struct hlist_head rx[RX_MAX];
 	struct hlist_head rx_sff[CAN_SFF_RCV_ARRAY_SZ];
 	struct hlist_head rx_eff[CAN_EFF_RCV_ARRAY_SZ];
-	int remove_on_zero_entries;
 	int entries;
 };
 
-- 
1.9.1


From 4c9c636f9ac938e822797d730d8a758997216302 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sun, 30 Jul 2017 16:31:09 +0200
Subject: [PATCH 014/113] can: af_can: remove NULL-ptr checks from users of
 can_dev_rcv_lists_find()

Since using the "struct can_ml_priv" for the per device "struct
dev_rcv_lists" the call can_dev_rcv_lists_find() cannot fail anymore.
This patch simplifies af_can by removing the NULL pointer checks from
the dev_rcv_lists returned by can_dev_rcv_lists_find().

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/af_can.c | 46 ++++++++++++++++------------------------------
 1 file changed, 16 insertions(+), 30 deletions(-)

diff --git a/net/can/af_can.c b/net/can/af_can.c
index c3eac4a..f940030 100644
--- a/net/can/af_can.c
+++ b/net/can/af_can.c
@@ -486,28 +486,22 @@ int can_rx_register(struct net *net, struct net_device *dev, canid_t can_id,
 	spin_lock(&net->can.can_rcvlists_lock);
 
 	dev_rcv_lists = can_dev_rcv_lists_find(net, dev);
-	if (dev_rcv_lists) {
-		rcv_list = can_rcv_list_find(&can_id, &mask, dev_rcv_lists);
-
-		rcv->can_id = can_id;
-		rcv->mask = mask;
-		rcv->matches = 0;
-		rcv->func = func;
-		rcv->data = data;
-		rcv->ident = ident;
-		rcv->sk = sk;
-
-		hlist_add_head_rcu(&rcv->list, rcv_list);
-		dev_rcv_lists->entries++;
-
-		can_pstats->rcv_entries++;
-		can_pstats->rcv_entries_max = max(can_pstats->rcv_entries_max,
-						  can_pstats->rcv_entries);
-	} else {
-		kmem_cache_free(rcv_cache, rcv);
-		err = -ENODEV;
-	}
+	rcv_list = can_rcv_list_find(&can_id, &mask, dev_rcv_lists);
+
+	rcv->can_id = can_id;
+	rcv->mask = mask;
+	rcv->matches = 0;
+	rcv->func = func;
+	rcv->data = data;
+	rcv->ident = ident;
+	rcv->sk = sk;
 
+	hlist_add_head_rcu(&rcv->list, rcv_list);
+	dev_rcv_lists->entries++;
+
+	can_pstats->rcv_entries++;
+	can_pstats->rcv_entries_max = max(can_pstats->rcv_entries_max,
+					  can_pstats->rcv_entries);
 	spin_unlock(&net->can.can_rcvlists_lock);
 
 	return err;
@@ -556,13 +550,6 @@ void can_rx_unregister(struct net *net, struct net_device *dev, canid_t can_id,
 	spin_lock(&net->can.can_rcvlists_lock);
 
 	dev_rcv_lists = can_dev_rcv_lists_find(net, dev);
-	if (!dev_rcv_lists) {
-		pr_err("BUG: receive list not found for "
-		       "dev %s, id %03X, mask %03X\n",
-		       DNAME(dev), can_id, mask);
-		goto out;
-	}
-
 	rcv_list = can_rcv_list_find(&can_id, &mask, dev_rcv_lists);
 
 	/*
@@ -697,8 +684,7 @@ static void can_receive(struct sk_buff *skb, struct net_device *dev)
 
 	/* find receive list for this device */
 	dev_rcv_lists = can_dev_rcv_lists_find(net, dev);
-	if (dev_rcv_lists)
-		matches += can_rcv_filter(dev_rcv_lists, skb);
+	matches += can_rcv_filter(dev_rcv_lists, skb);
 
 	rcu_read_unlock();
 
-- 
1.9.1


From e5e5832ced057e4d084a4f2357c0e7128505210b Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Wed, 2 Aug 2017 09:30:32 +0200
Subject: [PATCH 015/113] CAN: debug

---
 net/core/rtnetlink.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index a78fd61..3eda9d9 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -2424,6 +2424,8 @@ struct net_device *rtnl_create_link(struct net *net,
 	else if (ops->get_num_rx_queues)
 		num_rx_queues = ops->get_num_rx_queues();
 
+	printk("%s: ifname=%s, priv_size=%zu\n", __func__, ifname, ops->priv_size);
+
 	dev = alloc_netdev_mqs(ops->priv_size, ifname, name_assign_type,
 			       ops->setup, num_tx_queues, num_rx_queues);
 	if (!dev)
-- 
1.9.1


From 165d649af3cf5188dfc45cce5d8489353e7b6ee3 Mon Sep 17 00:00:00 2001
From: Kurt Van Dijck <kurt.van.dijck@eia.be>
Date: Mon, 23 May 2011 10:26:25 +0200
Subject: [PATCH 016/113] can-j1939: Import SAE J1939

Signed-off-by: Kurt Van Dijck <kurt.van.dijck@eia.be>
Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 Documentation/networking/j1939.txt |  576 +++++++++++++++
 MAINTAINERS                        |    8 +
 include/linux/can/core.h           |   10 +
 include/uapi/linux/can.h           |   20 +-
 include/uapi/linux/can/j1939.h     |   99 +++
 net/can/Kconfig                    |    2 +
 net/can/Makefile                   |    2 +
 net/can/af_can.h                   |    3 +
 net/can/bcm.c                      |    4 +-
 net/can/j1939/Kconfig              |   22 +
 net/can/j1939/Makefile             |   12 +
 net/can/j1939/address-claim.c      |  214 ++++++
 net/can/j1939/bus.c                |  242 ++++++
 net/can/j1939/j1939-priv.h         |  306 ++++++++
 net/can/j1939/main.c               |  490 +++++++++++++
 net/can/j1939/socket.c             |  814 ++++++++++++++++++++
 net/can/j1939/transport.c          | 1428 ++++++++++++++++++++++++++++++++++++
 net/can/raw.c                      |    4 +-
 18 files changed, 4251 insertions(+), 5 deletions(-)
 create mode 100644 Documentation/networking/j1939.txt
 create mode 100644 include/uapi/linux/can/j1939.h
 create mode 100644 net/can/j1939/Kconfig
 create mode 100644 net/can/j1939/Makefile
 create mode 100644 net/can/j1939/address-claim.c
 create mode 100644 net/can/j1939/bus.c
 create mode 100644 net/can/j1939/j1939-priv.h
 create mode 100644 net/can/j1939/main.c
 create mode 100644 net/can/j1939/socket.c
 create mode 100644 net/can/j1939/transport.c

diff --git a/Documentation/networking/j1939.txt b/Documentation/networking/j1939.txt
new file mode 100644
index 0000000..a9d47f6
--- /dev/null
+++ b/Documentation/networking/j1939.txt
@@ -0,0 +1,576 @@
+============================================================================
+
+j1939.txt
+
+Readme file for the J1939 Protocol
+
+This file contains
+
+  1 Overview / What is j1939
+    1.1 specifications used
+
+  2 Motivation
+
+  3 J1939 concepts
+    3.1 socket type
+    3.2 addressing
+    3.3 priority
+    3.4 PGN
+    3.5 filtering
+    3.6 destinations with dynamic address
+
+  4 How to use J1939
+    4.1 rtnetlink interface
+    4.2 API calls
+        4.2.1 Message flags during sendmsg
+	4.2.2 SCM_J1939_DEST_ADDR & SCM_J1939_DEST_NAME
+	4.2.3 SCM_J1939_PRIORITY
+    4.3 Dynamic addressing
+    4.4 Send Examples
+        4.4.1 Static address
+	4.4.2 Dynamic address
+	4.4.3 Mixed mode
+
+  5 socket options
+    5.1 SO_J1939_FILTER
+    5.2 SO_J1939_PROMISC
+    5.3 SO_J1939_RECV_OWN
+    5.4 SO_J1939_SEND_PRIO
+
+  6 can-j1939 procfs interface
+    6.1 /proc/net/can-j1939/ecu
+    6.2 /proc/net/can-j1939/filter
+    6.3 /proc/net/can-j1939/sock
+    6.4 /proc/net/can-j1939/transport
+
+  7 can-j1939 SYSCTL
+    7.1 /proc/sys/net/can-j1939/transport_max_payload_in_bytes
+    7.2 /proc/sys/net/can-j1939/transport_cts_nr_of_frames
+    7.3 /proc/sys/net/can-j1939/transport_tx_retry_ms
+
+  8 Credits
+
+============================================================================
+
+1. Introduction
+--------------------------------
+
+  SAE J1939 defines a higher layer protocol on CAN. It implements a more
+  sophisticated addressing scheme and extends the maximum packet size above
+  8 bytes. Several derived specifications exists, which differ from the
+  original j1939 on the application level, like MilCAN, NMEA2000 and
+  especially ISO-11783 (ISOBUS). This last one specifies the so-called ETP
+  (Extended Transport Protocol) which is has been included in this
+  implementation. This inclusion results in a maximum packet size of
+  ((2^24)-1)*7 bytes
+
+
+1.1 specifications used
+
+  SAE J1939-21 : data link layer
+  SAE J1939-81 : network management
+  ISO 11783-6  : Virtual Terminal (Extended Transport Protocol)
+
+
+2. Motivation
+--------------------------------
+
+  Given the fact there's something like SocketCAN with an API similar to BSD
+  sockets, we found some reasons to justify a kernel implementation for the
+  addressing and transport methods used by J1939.
+
+  * addressing:
+    When a process on an ECU communicates via j1939, it should not necessarily
+    know its source address. Although at least 1 process per ECU should know
+    the source address. Other processes should be able to reuse that address.
+    This way, address parameters for different processes cooperating for the
+    same ECU, are not duplicated.
+    This way of working is closely related to the unix concept where programs
+    do just 1 thing, and do it well.
+
+  * dynamic addressing:
+    Address Claiming in J1939 is time critical. Furthermore data transport
+    should be handled properly during the address negotiation. Putting these
+    functionality in the kernel eliminates this functionality as a requirement
+    for _every_ userspace process that communicates via J1939. This results in
+    a consistent J1939 bus with proper addressing.
+
+  * transport:
+    Both TP & ETP reuse some PGN's to relay big packets over them. Different
+    processes may thus use the same TP & ETP PGN's without actually knowing it.
+    The individual TP & ETP sessions _must_ be serialized (synchronised)
+    between different processes. The kernel solves this problem properly, and
+    eliminates the serialisation (synchronisation) as a requirement for
+    _every_ userspace process that communicates via J1939.
+
+  J1939 defines some other features (relaying, gateway, Fast Packet transport,
+  ...). In-kernel code for these would not contribute to protocol stability.
+  Therefore, these parts are left to userspace.
+
+  The j1939 sockets operate on CAN network devices (see SocketCAN). Any j1939
+  userspace library operating on CAN raw sockets will still operate properly.
+  Since such library does not communicate with the in-kernel implementation,
+  care must be taken that these 2 do not interfere. In practice, this means
+  they cannot share ECU addresses. A single ECU (or virtual ECU) address is
+  used by the library exclusively, or by the in-kernel system exclusively.
+
+
+3. J1939 concepts
+--------------------------------
+
+3.1 PGN
+
+  The PGN (Parameter Group Number) is a number to identify a packet. The PGN
+  is composed as follows:
+   1 bit  : Reserved Bit
+   1 bit  : Data Page
+   8 bits : PF (PDU Format)
+   8 bits : PS (PDU Specific)
+
+  In J1939-21, distinction is made between PDU1 Format (where PF < 240) and
+  PDU2 Format (where PF >= 240). Furthermore, when using PDU2 Format, the
+  PS-field contains a so-called Group Extension, which is part of the PGN.
+  When using PDU2 Format, the Group Extension is set in the PS-field.
+
+  On the other hand, when using PDU1 Format, the PS-field contains a so-called
+  Destination Address, which is _not_ part of the PGN. When communicating a
+  PGN from userspace to kernel (or visa versa) and PDU2 Format is used, the
+  PS-field of the PGN shall be set to zero. The Destination Address shall be
+  set elsewhere.
+
+  Regarding PGN mapping to 29-bit CAN identifier, the Destination Address
+  shall be get/set from/to the apropriate bits of the identifier by the kernel.
+
+
+3.2 addressing
+
+  Both static and dynamic addressing methods can be used.
+
+  For static addresses, no extra checks are made by the kernel, and provided
+  addresses are considered right. This responsibility is for the OEM or system
+  integrator.
+
+  For dynamic addressing, so-called Address Claiming, extra support is forseen
+  in the kernel. In J1939 any ECU is known by it's 64-bit NAME. At the moment
+  of succesfull address claim, the kernel keeps track of both NAME and source
+  address being claimed. This serves as a base for filter schemes. By default,
+  packets with a destination that is not locally, will be rejected soon after
+  reception.
+
+  Mixed mode packets (from a static to a dynamic address or vice versa) are
+  allowed. The BSD sockets define seperate API calls for getting/setting the
+  local & remote address and are applicable for J1939 sockets.
+
+
+3.3 Filtering
+
+  Similar to SocketCAN, j1939 defines filters per socket that a user can set
+  in order to receive a subset of the j1939 traffic. Filtering can base on
+  * SA
+  * NAME
+  * PGN
+
+  There is a semantic difference with SocketCAN with regard to filtering.
+  When multiple filters are in place for a single socket, and a packet comes
+  in that matches several of those filters, the packet is only received once
+  for that socket.
+  The rationale behind this difference originates in the filter capabilities.
+  Where SocketCAN filters on only 1 orthogonal (can id), J1939 can filter
+  on 3 orthogonal properties (sa, name, pgn).
+
+  When a filter on the SA is set, j1939 traffic with a matching SA, but with
+  its NAME set (aka having claimed SA successfully) will match, although
+  the filter would not match its NAME.
+
+  Filtering on priority is _not_ supported.
+
+
+4. How to use J1939
+--------------------------------
+
+4.1 rtnetlink interface
+
+  Per default j1939 is not active. Specifying can_ifindex != 0 in bind(2)
+  or connect(2) needs an active j1939 on that interface. You must have done
+  $ ip link set canX j1939 on
+  on that interface.
+
+  $ ip link set canX j1939 off
+  disables j1939 on canX.
+
+  Assigning addresses is done via
+  $ ip addr add dev canX j1939 0xXX
+  statically or
+  $ ip addr add dev canX j1939 name 0xXX
+  dynamically. In the latter case, address claiming must take place
+  before other traffic can leave.
+
+  Removing addresses is done similarly via
+  $ ip addr del dev canX j1939 0xXX
+  $ ip addr del dev canX j1939 name 0xXX
+
+  A static address cannot be assigned together with a 64bit name.
+
+4.2 API calls
+
+  Like TCP/IP and CAN, you first need to open a socket for communicating over a
+  CAN network. To use j1939, include <include/linux/j1939.h>. From there,
+  <include/linux/can.h> will be included too.
+  To open a socket, you would write
+
+    s = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);
+
+  J1939 does use SOCK_DGRAM sockets. In the j1939 specification, connections are
+  mentioned in the context of transport protocol sessions. These still deliver
+  packets to the other end (using several CAN packets).
+  SOCK_STREAM is never appropriate.
+
+  After the successful creation of the socket, you would normally use the
+  bind(2) and/or connect(2) system call to bind the socket to a CAN interface
+  (which is different from TCP/IP due to different addressing) After binding
+  and/or connecting the socket, you can read(2) and write(2) from/to the socket
+  or use send(2), sendto(2), sendmsg(2) and the recv* counterpart operations on
+  the socket as usual. There are also J1939 specific socket options described
+  below.
+
+  In order to send data, a bind(2) must have succeeded. bind(2) assigns a local
+  address to a socket. For this to succeed, you can only choose addresses
+  that have been assigned earlier (see 4.1). When an empty address is assigned
+  (ie. SA=0xff && name=0), a default is taken for the device that is bound to.
+
+  Different from CAN is that the payload data is just the data that get send,
+  without it's header info. The header info is derived from the sockaddr
+  supplied to bind(2), connect(2), sendto(2) and recvfrom(2). A write(2) with
+  size 4 will result in a packet with 4 bytes.
+
+  The sockaddr structure has extensions for use with j1939 as specified below:
+      struct sockaddr_can {
+         sa_family_t can_family;
+         int         can_ifindex;
+         union {
+            struct {
+               __u64 name;
+               __u32 pgn;
+               __u8  addr;
+            } j1939;
+         } can_addr;
+      }
+
+  can_family & can_ifindex serve the same purpose as for other SocketCAN sockets.
+
+  can_addr.j1939.pgn specifies the PGN (max 0x3ffff). Individual bits are
+  specified above.
+
+  can_addr.j1939.name contains the 64-bit J1939 NAME.
+
+  can_addr.j1939.addr contains the source address.
+
+  When sending data, the source address is applied as follows: If
+  can_addr.j1939.name != 0 the NAME is looked up by the kernel and the
+  corresponding Source Address is used. If can_addr.j1939.name == 0,
+  can_addr.j1939.addr is used.
+
+  After a bind(2), the local address is assigned, i.e. the source address.
+  After a connect(2), the remote address is assigned, i.e. the destination
+  address.
+
+  Both write(2) and send(2) will send a packet with local address from bind,
+  remote address from connect(2). When the address was not set, a broadcast is
+  sent. The PGN is used from bind(2) or overruled with sendto(2), which will
+  override the destination address when valid, and the PGN when valid.
+
+  Both read(2) and recv(2) will receive packets matching the sockets filters.
+  recvfrom(2) will receive these packets with originator's address.
+
+  When creating a socket, reasonable defaults have been set. Some options can be
+  modified with setsockopt(2) & getsockopt(2).
+
+4.2.1 Message flags during sendmsg
+
+  send(2), sendto(2) and sendmsg(2) take a 'flags' argument. J1939 interpretes
+  these flags during outgoing traffic:
+
+  * MSG_DONTWAIT determines nonblocking operation. When a packet must wait for
+    any reason, -EAGAIN is returned.
+
+  * MSG_SYN
+    Packets flagged with MSG_SYN will wait for all pending packets on a socket
+    to be sent before trying to send. This means that if a socket just started
+    a Transport Protocol session, a packet with MSG_SYN will wait for that
+    session to complete before proceeding.
+    Traffic without MSG_SYN (on that very same socket) will still continue.
+
+4.2.2 SCM_J1939_DEST_ADDR & SCM_J1939_DEST_NAME
+
+  Different received j1939 packets could have had different destionations:
+  - broadcast packet, i.e. no destination address
+  - destination address that matches the sockets local address
+  - destination address that matches _a_ local address on the system, and the
+    socket had no local address defined.
+  - SO_J1939_PROMISC was set
+
+  The destination address & destination name (if applicable) are attached
+  to the msghdr in the recvmsg(2) call. It can be extracted using cmsg(3) macros,
+  with cmsg_level == SOL_J1939 && cmsg_type == SCM_J1939_DEST_ADDR
+  or SCM_J1939_DEST_NAME. The returned data is a uint8_t/uint64_t.
+
+4.2.3 SCM_J1939_PRIORITY
+
+  Attached to the msghdr is also the packet's priority on the bus. This is a
+  uint8_t, packed as cmsg_type == SCM_J1939_PRIORITY.
+
+4.3 Dynamic Addressing
+
+  Distinction has to be made in and using the claimed address and doing an
+  address claim. To use an already claimed address, one has to fill in the
+  j1939.name member and provide it to bind(2). If the name had claimed an
+  address earlier, all further PGN's being sent will use that address. And the
+  j1939.addr member will be ignored.
+
+  An exception on this is pgn 0x0ee00. This is the "Address Claim/Cannot Claim
+  Address" message and when the kernel will use the j1939.addr member for that
+  pgn if necessary.
+
+  To claim an address, bind(2) with:
+  j1939.pgn  set to 0x0ee00
+  j1939.addr set to the desired Source Address.
+  j1939.name set to the NAME you want the Source Address to claim to.
+
+  Afterwards do a write(2) with data set to the NAME (Little Endian). If the
+  NAME provided, does not match the j1939.name provided to bind(2), EPROTO
+  will be returned. One might use sendto(2) also to send the Addres Claim. In
+  that case, the j1939.addr member must be set to the broadcast address (255)
+  and the j1939.pgn must be set to 0x0ee00. If This combination is not given,
+  EPROTO is returned.
+
+  If no-one else contest the address claim within 250ms after transmission, the
+  kernel marks the NAME-SA assignment as valid. The valid assignment will be
+  kept, among other valid NAME-SA assignments. From that point, any socket
+  bound to the NAME can send packets.
+
+  If another ECU claims the address, the kernel will mark the NAME-SA expired.
+  No socket bound to the NAME can send packets (other than address claims).
+  To claim another address, some socket bound to NAME, must bind(2) again,
+  but with only j1939.addr changed to the new SA, and must then send a
+  valid address claim packet. This restarts the state machine in the kernel
+  (and any other participant on the bus) for this NAME.
+
+
+4.4 Send Examples
+
+4.4.1 Static addressing
+
+  This example will send a pgn (0x12300) from SA 0x20 to DA 0x30.
+
+  Add the address to the system:
+  $ ip addr add j1939 0x20 dev can0
+
+  Bind:
+    struct sockaddr_can addr;
+
+    memset(&addr, 0, sizeof(addr));
+    addr.can_ifindex = ifindex("can0"); // ifindex is a substitute.
+    addr.can_addr.j1939.name = J1939_NO_NAME;
+    addr.can_addr.j1939.addr = 0x20;
+    addr.can_addr.j1939.pgn = J1939_NO_PGN;
+
+    bind(sk, (void *)&addr, sizeof(addr));
+
+  Now, the socket 'sk' is bound to the address 0x20. Since no pgn
+  was specified during bound, a pgn will be necessary during sendto() operations.
+  Alternatively, specifying addr.can_addr.j1939.pgn during bind() allows
+  for using send() & write(), since a default pgn (the pgn specified during bind())
+  can be used then.
+
+  Send:
+    struct sockaddr_can addr;
+
+    memset(&addr, 0, sizeof(addr));
+    addr.can_addr.j1939.name = J1939_NO_NAME;
+    addr.can_addr.j1939.addr = 0x30;
+    addr.can_addr.j1939.pgn = 0x12300;
+    // addr.can_ifindex is not necessary here.
+
+    sendto(sk, data, sizeof(data), 0, (void *)&addr, sizeof(addr));
+
+4.4.2 Dynamic addressing
+
+  This example will send a pgn (0x12300) from 12345678 to 9ABCDEF
+
+  Add the name to the system:
+  $ ip addr add j1939 name 12345678 dev can0
+
+  Start an address claiming daemon (e.g. jacd)
+  $ jacd -r 0x20-0x30 12345678 can0 &
+
+  Bind:
+    struct sockaddr_can addr;
+
+    memset(&addr, 0, sizeof(addr));
+    addr.can_ifindex = ifindex("can0"); // ifindex is a substitute.
+    addr.can_addr.j1939.name = 0x12345678ULL;
+    addr.can_addr.j1939.addr = J1939_NO_ADDR;
+    addr.can_addr.j1939.pgn = J1939_NO_PGN;
+
+    bind(sk, (void *)&addr, sizeof(addr));
+
+  Send:
+    struct sockaddr_can addr;
+
+    memset(&addr, 0, sizeof(addr));
+    addr.can_addr.j1939.name = 0x9ABCDEFULL;
+    addr.can_addr.j1939. = J1939_NO_ADDR;
+    addr.can_addr.j1939.pgn = 0x12300;
+
+    sendto(sk, data, sizeof(data), 0, (void *)&addr, sizeof(addr));
+
+4.4.3 Mixed mode
+
+  A scenario that sends a packet from a static address to a dynamic address
+  or vice versa is called 'mixed mode' here.
+
+  Combining the setup of the static address with a sendto() to a dynamic
+  address from the above examples is legal, and implements such mixed mode
+  addressing. The same applies for the setup of the dynamic address combined
+  with the sendto() towards a dynamic address.
+
+
+5 Socket Options
+--------------------------------
+
+  j1939 sockets have some options that are configurable via setsockopt(2).
+  Each of those options is initialized with a reasonable default.
+
+
+5.1 SO_J1939_FILTER
+
+  As mentioned above, J1939 supports filtering in both NAME, Source Address
+  and PGN. All members must match.
+
+   struct j1939_filter filter = {
+      .name         = ...
+      .name_mask   = ...
+      .addr         = ...
+      .addr_mask   = ...
+      .pgn         = ...
+      .pgn_mask   = ...
+   }
+
+    setsockopt(s, SOL_CAN_J1939, SO_J1939_FILTER, &filter, sizeof(filter));
+
+
+5.2 SO_J1939_PROMISC
+
+  When set, j1939 will receive all packets, not just those with a destination
+  on the local system.
+  default off.
+
+    int promisc = 1; /* 0 = disabled (default), 1 = enabled */
+
+    setsockopt(s, SOL_CAN_J1939, SO_J1939_PROMISC, &promisc, sizeof(promisc));
+
+
+5.3 SO_J1939_RECV_OWN
+
+  All the sent j1939 packets are looped back in the system.
+  The reception of the j1939 packets on the same socket that was
+  sending the j1939 packet is assumed to be unwanted and therefore
+  disabled by default. This default behaviour may be changed on
+  demand:
+
+    int recv_own_msgs = 1; /* 0 = disabled (default), 1 = enabled */
+
+    setsockopt(s, SOL_CAN_J1939, SO_J1939_RECV_OWN,
+               &recv_own_msgs, sizeof(recv_own_msgs));
+
+
+5.4 SO_J1939_SEND_PRIO
+
+  To set the priority field for outgoing packets, the SO_J1939_SEND_PRIO can
+  be changed. This int field specifies the priority that will be used.
+  j1939 defines a priority between 0 and 7 inclusive,
+  with 7 the lowest priority.
+  Per default, the priority is set to 6 (conforming J1939).
+  This priority socket option operates on the same value that is modified
+  with
+
+    setsockopt(s, SOL_SOCKET, SO_PRIORITY, &pri, sizeof(pri))
+
+  socketoption, with a difference that SOL_SOCKET/SO_PRIORITY is defined with
+  0 the lowest priority. SOL_CAN_J1939/SO_J1939_SEND_PRIO inverts this value
+  for you.
+
+
+6. /proc/net/can-j1939 Interface.
+--------------------------------
+
+  Files giving you a view on the in-kernel operation of J1939 are located at:
+  /proc/net/j1939.
+
+6.1 /proc/net/can-j1939/ecu
+
+  This file gives an overview of the known ECU's to the kernel.
+  - iface : network interface they operate on.
+  - SA : current address.
+  - name : 64bit NAME
+  - flags : 'L' = local, 'R' = remote
+
+6.2 /proc/net/can-j1939/filter
+
+6.3 /proc/net/can-j1939/sock
+
+  This file gives a list of all j1939 sockets currently open.
+  - iface : network interface
+  - flags :
+    'b' : bound
+    'c' : connected
+    'P' : PROMISC
+    'o' : RECV_OWN
+    'd' : RECV_DEST
+    'p' : RECV_PRIO
+  - local: [NAME],SA
+  - remote: [NAME]/MASK,DA
+  - pgn : PGN
+  - prio : priority
+  - pending : # packets pending (see MSG_SYN on 4.2.1)
+
+6.4 /proc/net/can-j1939/transport
+
+  This file shows a list of pending transport sessions
+  - iface
+  - src : XX (addr) or XXXXXXXXXXXXXXXX (name)
+  - dst : XX or XXXXXXXXXXXXXXXX or '-' (broadcast)
+  - pgn :
+  - done/total : current # transferred bytes / total
+
+
+7. /proc/sys/net/can-j1939 - SYSCTL
+--------------------------------
+
+  Via these sysctl files, some parameters of the j1939 module can be tuned.
+
+7.1 /proc/sys/net/can-j1939/transport_max_payload_in_bytes [int]
+
+  Is the maximum packet size to accept on both transmit & receive side.
+  Bigger packets will be rejected (local sender), aborted (local receiver)
+  or ignored (broadcasts & remote recievers in PROMISC).
+
+7.2 /proc/sys/net/can-j1939/transport_cts_nr_frames [int]
+
+  Controls the number of packets to allow between consecutive CTS frames
+  (default 255).
+  This number is communicated within the CTS frame from receiver to transmitter.
+  Setting this has effect on received transport sessions only.
+
+7.3 /proc/sys/net/can-j1939/transport_tx_retry_ms [int]
+
+  Controls how many time to wait before retrying to send an individual TP
+  flow or data packet after transmission failure (default 20).
+
+
+8. Credits
+--------------------------------
+
+  Kurt Van Dijck (j1939 core, transport protocol, API)
+  Pieter Beyens (j1939 core, address claiming)
+
diff --git a/MAINTAINERS b/MAINTAINERS
index 9d47ed9..2b0045d 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -3100,6 +3100,14 @@ F:	include/uapi/linux/can/bcm.h
 F:	include/uapi/linux/can/raw.h
 F:	include/uapi/linux/can/gw.h
 
+CAN-J1939 NETWORK LAYER
+M:	Kurt Van Dijck <kurt.van.dijck@eia.be>
+L:	socketcan-core@lists.berlios.de
+L:	netdev@vger.kernel.org
+S:	Maintained
+F:	net/can/j1939/
+F:	include/linux/can/j1939.h
+
 CAPABILITIES
 M:	Serge Hallyn <serge@hallyn.com>
 L:	linux-security-module@vger.kernel.org
diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index c9a17bb..bd5afce 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -16,6 +16,7 @@
 #include <linux/can.h>
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
+#include <net/rtnetlink.h>
 
 #define CAN_VERSION "20170425"
 
@@ -40,6 +41,15 @@ struct can_proto {
 	struct proto *prot;
 };
 
+/*
+ * required_size
+ * macro to find the minimum size of a struct
+ * that includes a requested member
+ */
+#define required_size(member, struct_type) \
+	(offsetof(typeof(struct_type), member) + \
+	 sizeof(((typeof(struct_type) *)(0))->member))
+
 /* function prototypes for the CAN networklayer core (af_can.c) */
 
 extern int  can_proto_register(const struct can_proto *cp);
diff --git a/include/uapi/linux/can.h b/include/uapi/linux/can.h
index c48d93a..2630d81 100644
--- a/include/uapi/linux/can.h
+++ b/include/uapi/linux/can.h
@@ -156,7 +156,8 @@ struct canfd_frame {
 #define CAN_TP20	4 /* VAG Transport Protocol v2.0 */
 #define CAN_MCNET	5 /* Bosch MCNet */
 #define CAN_ISOTP	6 /* ISO 15765-2 Transport Protocol */
-#define CAN_NPROTO	7
+#define CAN_J1939	7 /* SAE J1939 */
+#define CAN_NPROTO	8
 
 #define SOL_CAN_BASE 100
 
@@ -173,6 +174,23 @@ struct sockaddr_can {
 		/* transport protocol class address information (e.g. ISOTP) */
 		struct { canid_t rx_id, tx_id; } tp;
 
+		/* J1939 address information */
+		struct {
+			/* 8 byte name when using dynamic addressing */
+			__u64 name;
+			/*
+			 * pgn:
+			 * 8bit: PS in PDU2 case, else 0
+			 * 8bit: PF
+			 * 1bit: DP
+			 * 1bit: reserved
+			 */
+			__u32 pgn;
+
+			/* 1byte address */
+			__u8 addr;
+		} j1939;
+
 		/* reserved for future CAN protocols address information */
 	} can_addr;
 };
diff --git a/include/uapi/linux/can/j1939.h b/include/uapi/linux/can/j1939.h
new file mode 100644
index 0000000..7ff419e
--- /dev/null
+++ b/include/uapi/linux/can/j1939.h
@@ -0,0 +1,99 @@
+/*
+ * j1939.h
+ *
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _J1939_H_
+#define _J1939_H_
+
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <linux/can.h>
+
+#define J1939_IDLE_ADDR	0xfe
+#define J1939_NO_ADDR	0xff
+#define J1939_NO_NAME	0
+#define J1939_NO_PGN	0x40000
+/*
+ * J1939 Parameter Group Number
+ *
+ * bit 0-7	: PDU Specific (PS)
+ * bit 8-15	: PDU Format (PF)
+ * bit 16	: Data Page (DP)
+ * bit 17	: Reserved (R)
+ * bit 19-31	: set to zero
+ */
+typedef __u32 pgn_t;
+
+/*
+ * J1939 Priority
+ *
+ * bit 0-2	: Priority (P)
+ * bit 3-7	: set to zero
+ */
+typedef __u8 priority_t;
+
+/*
+ * J1939 NAME
+ *
+ * bit 0-20	: Identity Number
+ * bit 21-31	: Manufacturer Code
+ * bit 32-34	: ECU Instance
+ * bit 35-39	: Function Instance
+ * bit 40-47	: Function
+ * bit 48	: Reserved
+ * bit 49-55	: Vehicle System
+ * bit 56-59	: Vehicle System Instance
+ * bit 60-62	: Industry Group
+ * bit 63	: Arbitrary Address Capable
+ */
+typedef __u64 name_t;
+
+/*
+ * J1939 socket options
+ */
+#define SOL_CAN_J1939 (SOL_CAN_BASE + CAN_J1939)
+enum {
+	SO_J1939_FILTER = 1,	/* set filters */
+	SO_J1939_PROMISC = 2,	/* set/clr promiscuous mode */
+	SO_J1939_RECV_OWN = 3,
+	SO_J1939_SEND_PRIO = 4,
+};
+
+enum {
+	SCM_J1939_DEST_ADDR = 1,
+	SCM_J1939_DEST_NAME = 2,
+	SCM_J1939_PRIO = 3,
+};
+
+struct j1939_filter {
+	name_t name;
+	name_t name_mask;
+	__u8 addr;
+	__u8 addr_mask;
+	pgn_t pgn;
+	pgn_t pgn_mask;
+};
+
+/*
+ * RTNETLINK
+ */
+enum {
+	IFLA_J1939_UNSPEC,
+	IFLA_J1939_ENABLE,
+	IFLA_J1939_MAX,
+};
+
+enum {
+	IFA_J1939_UNSPEC,
+	IFA_J1939_ADDR,
+	IFA_J1939_NAME,
+	IFA_J1939_MAX,
+};
+
+#endif /* _J1939_H_ */
diff --git a/net/can/Kconfig b/net/can/Kconfig
index a15c0e0..85df900 100644
--- a/net/can/Kconfig
+++ b/net/can/Kconfig
@@ -51,6 +51,8 @@ config CAN_GW
 	  They can be modified with AND/OR/XOR/SET operations as configured
 	  by the netlink configuration interface known e.g. from iptables.
 
+source "net/can/j1939/Kconfig"
+
 source "drivers/net/can/Kconfig"
 
 endif
diff --git a/net/can/Makefile b/net/can/Makefile
index 1093675..14f0914 100644
--- a/net/can/Makefile
+++ b/net/can/Makefile
@@ -14,3 +14,5 @@ can-bcm-y		:= bcm.o
 
 obj-$(CONFIG_CAN_GW)	+= can-gw.o
 can-gw-y		:= gw.o
+
+obj-$(CONFIG_CAN_J1939)	+= j1939/
diff --git a/net/can/af_can.h b/net/can/af_can.h
index dc198a0..9c15cf9 100644
--- a/net/can/af_can.h
+++ b/net/can/af_can.h
@@ -72,6 +72,9 @@ struct can_dev_rcv_lists {
 	struct hlist_head rx_sff[CAN_SFF_RCV_ARRAY_SZ];
 	struct hlist_head rx_eff[CAN_EFF_RCV_ARRAY_SZ];
 	int entries;
+#ifdef CAN_J1939
+	void *j1939_priv;
+#endif
 };
 
 /* statistic structures */
diff --git a/net/can/bcm.c b/net/can/bcm.c
index 47a8748d..528f321 100644
--- a/net/can/bcm.c
+++ b/net/can/bcm.c
@@ -1328,7 +1328,7 @@ static int bcm_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 		/* no bound device as default => check msg_name */
 		DECLARE_SOCKADDR(struct sockaddr_can *, addr, msg->msg_name);
 
-		if (msg->msg_namelen < sizeof(*addr))
+		if (msg->msg_namelen < required_size(can_ifindex, *addr))
 			return -EINVAL;
 
 		if (addr->can_family != AF_CAN)
@@ -1569,7 +1569,7 @@ static int bcm_connect(struct socket *sock, struct sockaddr *uaddr, int len,
 	struct net *net = sock_net(sk);
 	int ret = 0;
 
-	if (len < sizeof(*addr))
+	if (len < required_size(can_ifindex, *addr))
 		return -EINVAL;
 
 	lock_sock(sk);
diff --git a/net/can/j1939/Kconfig b/net/can/j1939/Kconfig
new file mode 100644
index 0000000..74d2a86
--- /dev/null
+++ b/net/can/j1939/Kconfig
@@ -0,0 +1,22 @@
+#
+# SAE J1939 network layer core configuration
+#
+
+config CAN_J1939
+	tristate "SAE J1939"
+	depends on CAN
+	---help---
+	  SAE J1939
+	  Say Y to have in-kernel support for j1939 socket type. This
+	  allows communication according to SAE j1939.
+	  The relevant parts in kernel are
+	  SAE j1939-21 (datalink & transport protocol)
+	  & SAE j1939-81 (network management).
+
+config CAN_J1939_DEBUG
+	bool "debug SAE J1939"
+	depends on CAN_J1939
+	default n
+	---help---
+	  Say Y to add extra debug code (via printk) in the j1939 stack
+
diff --git a/net/can/j1939/Makefile b/net/can/j1939/Makefile
new file mode 100644
index 0000000..77b6bfa
--- /dev/null
+++ b/net/can/j1939/Makefile
@@ -0,0 +1,12 @@
+
+obj-$(CONFIG_CAN_J1939)	+= can-j1939.o
+
+can-j1939-objs := main.o \
+	bus.o \
+	address-claim.o transport.o \
+	socket.o
+
+ifeq ($(CONFIG_CAN_J1939_DEBUG),y)
+	EXTRA_CFLAGS += -DDEBUG
+endif
+
diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
new file mode 100644
index 0000000..36d995b
--- /dev/null
+++ b/net/can/j1939/address-claim.c
@@ -0,0 +1,214 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Pieter Beyens <pieter.beyens@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+/*
+ * J1939 Address Claiming.
+ * Address Claiming in the kernel
+ * - keeps track of the AC states of ECU's,
+ * - resolves NAME<=>SA taking into account the AC states of ECU's.
+ *
+ * All Address Claim msgs (including host-originated msg) are processed
+ * at the receive path (a sent msg is always received again via CAN echo).
+ * As such, the processing of AC msgs is done in the order on which msgs
+ * are sent on the bus.
+ *
+ * This module doesn't send msgs itself (e.g. replies on Address Claims),
+ * this is the responsibility of a user space application or daemon.
+ */
+
+#include <linux/skbuff.h>
+#include <linux/byteorder/generic.h>
+
+#include "j1939-priv.h"
+
+#define CANDATA2NAME(data) le64_to_cpup((uint64_t *)data)
+
+static inline int ac_msg_is_request_for_ac(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+	int req_pgn;
+
+	if ((skb->len < 3) || (skcb->pgn != PGN_REQUEST))
+		return 0;
+	req_pgn = skb->data[0] | (skb->data[1] << 8) | (skb->data[2] << 16);
+	return req_pgn == PGN_ADDRESS_CLAIMED;
+}
+
+static int j1939_verify_outgoing_address_claim(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+
+	if (skb->len != 8) {
+		j1939_notice("tx address claim with dlc %i\n", skb->len);
+		return -EPROTO;
+	}
+
+	if (skcb->srcname != CANDATA2NAME(skb->data)) {
+		j1939_notice("tx address claim with different name\n");
+		return -EPROTO;
+	}
+
+	if (skcb->srcaddr == J1939_NO_ADDR) {
+		j1939_notice("tx address claim with broadcast sa\n");
+		return -EPROTO;
+	}
+
+	/* ac must always be a broadcast */
+	if (skcb->dstname || (skcb->dstaddr != J1939_NO_ADDR)) {
+		j1939_notice("tx address claim with dest, not broadcast\n");
+		return -EPROTO;
+	}
+	return 0;
+}
+
+int j1939_fixup_address_claim(struct sk_buff *skb)
+{
+	int ret, sa;
+	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+
+	/* network mgmt: address claiming msgs */
+	if (skcb->pgn == PGN_ADDRESS_CLAIMED) {
+		struct j1939_ecu *ecu;
+
+		ret = j1939_verify_outgoing_address_claim(skb);
+		/* return both when failure & when successfull */
+		if (ret < 0)
+			return ret;
+		ecu = j1939_ecu_find_by_name(skcb->srcname,
+				skb->dev->ifindex);
+		if (!ecu)
+			return -ENODEV;
+
+		if (ecu->sa != skcb->srcaddr)
+			/* hold further traffic for ecu, remove from parent */
+			j1939_ecu_remove_sa(ecu);
+		put_j1939_ecu(ecu);
+	} else if (skcb->srcname) {
+		/* assign source address */
+		sa = j1939_name_to_sa(skcb->srcname, skb->dev->ifindex);
+		if (!j1939_address_is_unicast(sa) &&
+				!ac_msg_is_request_for_ac(skb)) {
+			j1939_notice("tx drop: invalid sa for name "
+					"0x%016llx\n", skcb->srcname);
+			return -EADDRNOTAVAIL;
+		}
+		skcb->srcaddr = sa;
+	}
+
+	/* assign destination address */
+	if (skcb->dstname) {
+		sa = j1939_name_to_sa(skcb->dstname, skb->dev->ifindex);
+		if (!j1939_address_is_unicast(sa)) {
+			j1939_notice("tx drop: invalid da for name "
+					"0x%016llx\n", skcb->dstname);
+			return -EADDRNOTAVAIL;
+		}
+		skcb->dstaddr = sa;
+	}
+	return 0;
+}
+
+static void j1939_process_address_claim(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+	struct j1939_ecu *ecu, *prev;
+	struct j1939_priv *priv;
+	name_t name;
+
+	if (skb->len != 8) {
+		j1939_notice("rx address claim with wrong dlc %i\n", skb->len);
+		return;
+	}
+
+	name = CANDATA2NAME(skb->data);
+	skcb->srcname = name;
+	if (!name) {
+		j1939_notice("rx address claim without name\n");
+		return;
+	}
+
+	if (!j1939_address_is_valid(skcb->srcaddr)) {
+		j1939_notice("rx address claim with broadcast sa\n");
+		return;
+	}
+
+	priv = j1939_priv_find(skb->skb_iif);
+	if (!priv)
+		return;
+
+	write_lock_bh(&priv->lock);
+
+	ecu = _j1939_ecu_get_register(priv, name,
+			j1939_address_is_unicast(skcb->srcaddr));
+	if (IS_ERR(ecu))
+		goto done;
+
+	if (skcb->srcaddr >= J1939_IDLE_ADDR) {
+		_j1939_ecu_unregister(ecu);
+		goto done;
+	}
+
+	/* save new SA */
+	if (skcb->srcaddr != ecu->sa)
+		_j1939_ecu_remove_sa(ecu);
+	/* cancel pending (previous) address claim */
+	hrtimer_try_to_cancel(&ecu->ac_timer);
+	ecu->sa = skcb->srcaddr;
+
+	prev = priv->ents[skcb->srcaddr].ecu;
+	if (prev && prev != ecu) {
+		if (ecu->name > prev->name) {
+			_j1939_ecu_unregister(ecu);
+			goto done;
+		} else {
+			/* kick prev */
+			_j1939_ecu_unregister(prev);
+		}
+	}
+
+	/* schedule timer in 250 msec to commit address change */
+	hrtimer_start(&ecu->ac_timer, ktime_set(0, 250000000),
+			HRTIMER_MODE_REL);
+	/* rxtime administration */
+	ecu->rxtime = ktime_get();
+done:
+	write_unlock_bh(&priv->lock);
+	put_j1939_priv(priv);
+}
+
+void j1939_recv_address_claim(struct sk_buff *skb, struct j1939_priv *priv)
+{
+	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+	struct j1939_ecu *ecu;
+
+	/*
+	 * network mgmt
+	 */
+	if (skcb->pgn == PGN_ADDRESS_CLAIMED)
+		j1939_process_address_claim(skb);
+	else if (j1939_address_is_unicast(skcb->srcaddr)) {
+		ecu = j1939_ecu_find_by_addr(skcb->srcaddr, skb->skb_iif);
+		if (ecu) {
+			/* source administration */
+			ecu->rxtime = ktime_get();
+			skcb->srcname = ecu->name;
+			put_j1939_ecu(ecu);
+		}
+	}
+
+	/* assign destination stuff */
+	ecu = j1939_ecu_find_by_addr(skcb->dstaddr, skb->skb_iif);
+	if (ecu) {
+		skcb->dstname = ecu->name;
+		put_j1939_ecu(ecu);
+	}
+}
+
diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
new file mode 100644
index 0000000..e7b91c5
--- /dev/null
+++ b/net/can/j1939/bus.c
@@ -0,0 +1,242 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+/*
+ * j1939-bus.c - bus for j1939 remote devices
+ * Since rtnetlink, no real bus is used.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/workqueue.h>
+
+#include "j1939-priv.h"
+
+#define ecu_dbg(ecu, fmt, ...) \
+	pr_debug("j1939-%i,%016llx,%02x: " fmt, (ecu)->priv->ifindex, \
+		(ecu)->name, (ecu)->sa, ##__VA_ARGS__)
+#define ecu_alert(ecu, fmt, ...) \
+	pr_alert("j1939-%i,%016llx,%02x: " fmt, (ecu)->priv->ifindex, \
+		(ecu)->name, (ecu)->sa, ##__VA_ARGS__)
+
+/*
+ * ECU device interface
+ */
+static enum hrtimer_restart j1939_ecu_timer_handler(struct hrtimer *hrtimer)
+{
+	struct j1939_ecu *ecu =
+		container_of(hrtimer, struct j1939_ecu, ac_timer);
+
+	atomic_set(&ecu->ac_delay_expired, 1);
+	tasklet_schedule(&ecu->priv->ac_task);
+	return HRTIMER_NORESTART;
+}
+
+static void cb_put_j1939_ecu(struct kref *kref)
+{
+	struct j1939_ecu *ecu =container_of(kref, struct j1939_ecu, kref);
+
+	kfree(ecu);
+}
+void put_j1939_ecu(struct j1939_ecu *ecu)
+{
+	kref_put(&ecu->kref, cb_put_j1939_ecu);
+}
+
+struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv, name_t name,
+		int create_if_necessary)
+{
+	struct j1939_ecu *ecu, *dut;
+
+	/* find existing */
+	/* test for existing name */
+	list_for_each_entry(dut, &priv->ecus, list) {
+		if (dut->name == name)
+			return dut;
+	}
+	/* alloc */
+	ecu = kzalloc(sizeof(*ecu), gfp_any());
+	if (!ecu)
+		/* should we look for an existing ecu */
+		return ERR_PTR(-ENOMEM);
+	kref_init(&ecu->kref);
+	ecu->sa = J1939_IDLE_ADDR;
+	ecu->name = name;
+
+	hrtimer_init(&ecu->ac_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	ecu->ac_timer.function = j1939_ecu_timer_handler;
+	INIT_LIST_HEAD(&ecu->list);
+
+	/* first add to internal list */
+	/* a ref to priv is held */
+	ecu->priv = priv;
+	list_add_tail(&ecu->list, &priv->ecus);
+
+	ecu_dbg(ecu, "register\n");
+	/* do not put_j1939_priv, a new ECU keeps a refcnt open */
+	return ecu;
+}
+
+void _j1939_ecu_unregister(struct j1939_ecu *ecu)
+{
+	BUG_ON(!ecu);
+	ecu_dbg(ecu, "unregister\n");
+	hrtimer_try_to_cancel(&ecu->ac_timer);
+
+	_j1939_ecu_remove_sa(ecu);
+	list_del_init(&ecu->list);
+	put_j1939_ecu(ecu);
+}
+
+struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex)
+{
+	struct j1939_ecu *ecu;
+	struct j1939_priv *priv;
+
+	if (!j1939_address_is_unicast(sa))
+		return NULL;
+	priv = j1939_priv_find(ifindex);
+	if (!priv)
+		return NULL;
+	read_lock_bh(&priv->lock);
+	ecu = priv->ents[sa].ecu;
+	if (ecu)
+		get_j1939_ecu(ecu);
+	read_unlock_bh(&priv->lock);
+	put_j1939_priv(priv);
+	return ecu;
+}
+
+int j1939_name_to_sa(uint64_t name, int ifindex)
+{
+	struct j1939_ecu *ecu;
+	struct j1939_priv *priv;
+	int sa;
+
+	if (!name)
+		return J1939_NO_ADDR;
+	priv = j1939_priv_find(ifindex);
+	if (!priv)
+		return J1939_NO_ADDR;
+
+	sa = J1939_IDLE_ADDR;
+	read_lock_bh(&priv->lock);
+	list_for_each_entry(ecu, &priv->ecus, list) {
+		if (ecu->name == name) {
+			if (priv->ents[ecu->sa].ecu == ecu)
+				/* ecu's SA is registered */
+				sa = ecu->sa;
+			break;
+		}
+	}
+	read_unlock_bh(&priv->lock);
+	put_j1939_priv(priv);
+	return sa;
+}
+
+/* ecu lookup helper */
+static struct j1939_ecu *_j1939_ecu_find_by_name(name_t name,
+		struct j1939_priv *priv)
+{
+	struct j1939_ecu *ecu;
+
+	read_lock_bh(&priv->lock);
+	list_for_each_entry(ecu, &priv->ecus, list) {
+		if (ecu->name == name) {
+			get_j1939_ecu(ecu);
+			goto found_on_intf;
+		}
+	}
+	ecu = NULL;
+found_on_intf:
+	read_unlock_bh(&priv->lock);
+	return ecu;
+}
+
+/* ecu lookup by name */
+struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex)
+{
+	struct j1939_ecu *ecu;
+	struct j1939_priv *priv;
+
+	if (!name)
+		return NULL;
+	if (!ifindex)
+		return NULL;
+	priv = j1939_priv_find(ifindex);
+	if (!priv)
+		return NULL;
+	ecu = _j1939_ecu_find_by_name(name, priv);
+	put_j1939_priv(priv);
+	return ecu;
+}
+
+/* TX addr/name accounting
+ * Transport protocol needs to know if a SA is local or not
+ * These functions originate from userspace manipulating sockets,
+ * so locking is straigforward
+ */
+void j1939_addr_local_get(struct j1939_priv *priv, int sa)
+{
+	if (!j1939_address_is_unicast(sa))
+		return;
+	write_lock_bh(&priv->lock);
+	++priv->ents[sa].nusers;
+	write_unlock_bh(&priv->lock);
+}
+
+void j1939_addr_local_put(struct j1939_priv *priv, int sa)
+{
+	if (!j1939_address_is_unicast(sa))
+		return;
+	write_lock_bh(&priv->lock);
+	--priv->ents[sa].nusers;
+	write_unlock_bh(&priv->lock);
+}
+
+void j1939_name_local_get(struct j1939_priv *priv, uint64_t name)
+{
+	struct j1939_ecu *ecu;
+
+	if (!name)
+		return;
+	write_lock_bh(&priv->lock);
+	ecu = _j1939_ecu_get_register(priv, name, 1);
+	if (!IS_ERR(ecu)) {
+		get_j1939_ecu(ecu);
+		++ecu->nusers;
+		if (priv->ents[ecu->sa].ecu == ecu)
+			/* ecu's sa is active already */
+			++priv->ents[ecu->sa].nusers;
+	}
+	write_unlock_bh(&priv->lock);
+}
+
+void j1939_name_local_put(struct j1939_priv *priv, uint64_t name)
+{
+	struct j1939_ecu *ecu;
+
+	if (!name)
+		return;
+	write_lock_bh(&priv->lock);
+	ecu = _j1939_ecu_get_register(priv, name, 0);
+	if (!IS_ERR(ecu)) {
+		--ecu->nusers;
+		if (priv->ents[ecu->sa].ecu == ecu)
+			/* ecu's sa is active already */
+			--priv->ents[ecu->sa].nusers;
+		put_j1939_ecu(ecu);
+	}
+	write_unlock_bh(&priv->lock);
+}
+
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
new file mode 100644
index 0000000..4b684a8
--- /dev/null
+++ b/net/can/j1939/j1939-priv.h
@@ -0,0 +1,306 @@
+/*
+ * j1939-priv.h
+ *
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _J1939_PRIV_H_
+#define _J1939_PRIV_H_
+
+#include <linux/kref.h>
+#include <linux/list.h>
+#include <net/sock.h>
+
+#include <linux/proc_fs.h>
+#include <linux/module.h>
+#include <linux/can/j1939.h>
+#include <linux/atomic.h>
+#include <linux/interrupt.h>
+#include <linux/if_arp.h>
+
+#include "../af_can.h"
+
+/* TODO: return ENETRESET on busoff. */
+
+#define PGN_REQUEST		0x0ea00
+#define PGN_ADDRESS_CLAIMED	0x0ee00
+#define PGN_MAX			0x3ffff
+
+#define SA_MAX_UNICAST	0xfd
+/*
+ * j1939 devices
+ */
+struct j1939_ecu {
+	struct list_head list;
+	ktime_t rxtime;
+	name_t name;
+	uint8_t sa;
+	/*
+	 * atomic flag, set by ac_timer
+	 * cleared/processed by segment's tasklet
+	 * indicates that this ecu successfully claimed @sa as its address
+	 * By communicating this from the ac_timer event to segments tasklet,
+	 * a context locking problem is solved. All other 'ecu readers'
+	 * must only lock with _bh, not with _irq.
+	 */
+	atomic_t ac_delay_expired;
+	struct hrtimer ac_timer;
+	struct kref kref;
+	struct j1939_priv *priv;
+	/* count users, to help transport protocol decide for interaction */
+	int nusers;
+};
+#define to_j1939_ecu(x) container_of((x), struct j1939_ecu, dev)
+
+struct j1939_priv {
+	struct list_head ecus; /*
+	 * local list entry in priv
+	 * These allow irq (& softirq) context lookups on j1939 devices
+	 * This approach (seperate lists) is done as the other 2 alternatives
+	 * are not easier or even wrong
+	 * 1) using the pure kobject methods involves mutexes, which are not
+	 *    allowed in irq context.
+	 * 2) duplicating data structures would require a lot of synchronization
+	 *    code
+	 * usage:
+	 */
+	rwlock_t lock; /*
+	 * segments need a lock to protect the above list
+	 */
+	int ifindex;
+	struct net_device *netdev;
+	struct addr_ent {
+		ktime_t rxtime;
+		struct j1939_ecu *ecu;
+		/* count users, to help transport protocol */
+		int nusers;
+	} ents[256];
+
+	/*
+	 * tasklet to process ecu address claimed events.
+	 * These events raise in hardirq context. Signalling the event
+	 * and scheduling this tasklet successfully moves the
+	 * event to softirq context
+	 */
+	struct tasklet_struct ac_task;
+	/*
+	 * list of 256 ecu ptrs, that cache the claimed addresses.
+	 * also protected by the above lock
+	 * don't use directly, use j1939_ecu_set_address() instead
+	 */
+	struct kref kref;
+	/*
+	 * ref counter that hold the number of active listeners.
+	 * This number itself is protected with a mutex
+	 */
+	int nusers;
+};
+#define to_j1939_priv(x) container_of((x), struct j1939_priv, dev)
+
+extern void put_j1939_ecu(struct j1939_ecu *ecu);
+extern void put_j1939_priv(struct j1939_priv *segment);
+static inline void get_j1939_ecu(struct j1939_ecu *dut)
+{
+	kref_get(&dut->kref);
+}
+static inline void get_j1939_priv(struct j1939_priv *dut)
+{
+	kref_get(&dut->kref);
+}
+
+/* keep the cache of what is local */
+extern void j1939_addr_local_get(struct j1939_priv *priv, int sa);
+extern void j1939_addr_local_put(struct j1939_priv *priv, int sa);
+extern void j1939_name_local_get(struct j1939_priv *priv, uint64_t name);
+extern void j1939_name_local_put(struct j1939_priv *priv, uint64_t name);
+
+/*
+ * conversion function between (struct sock | struct sk_buff)->sk_priority
+ * from linux and j1939 priority field
+ */
+static inline int j1939_prio(int sk_priority)
+{
+	if (sk_priority < 0)
+		return 6; /* default */
+	else if (sk_priority > 7)
+		return 0;
+	else
+		return 7 - sk_priority;
+}
+static inline int j1939_to_sk_priority(int j1939_prio)
+{
+	return 7 - j1939_prio;
+}
+
+static inline int j1939_address_is_valid(uint8_t sa)
+{
+	return sa != J1939_NO_ADDR;
+}
+
+static inline int j1939_address_is_unicast(uint8_t sa)
+{
+	return sa <= SA_MAX_UNICAST;
+}
+
+static inline int pgn_is_pdu1(pgn_t pgn)
+{
+	/* ignore dp & res bits for this */
+	return (pgn & 0xff00) < 0xf000;
+}
+
+static inline int pgn_is_valid(pgn_t pgn)
+{
+	return pgn <= PGN_MAX;
+}
+
+/* utility to correctly unregister a SA */
+static inline void _j1939_ecu_remove_sa(struct j1939_ecu *ecu)
+{
+	if (!j1939_address_is_unicast(ecu->sa))
+		return;
+	if (ecu->priv && ecu->priv->ents[ecu->sa].ecu == ecu) {
+		ecu->priv->ents[ecu->sa].ecu = NULL;
+		ecu->priv->ents[ecu->sa].nusers -= ecu->nusers;
+	}
+}
+
+static inline void j1939_ecu_remove_sa(struct j1939_ecu *ecu)
+{
+	if (!j1939_address_is_unicast(ecu->sa))
+		return;
+	write_lock_bh(&ecu->priv->lock);
+	_j1939_ecu_remove_sa(ecu);
+	write_unlock_bh(&ecu->priv->lock);
+}
+
+extern int j1939_name_to_sa(uint64_t name, int ifindex);
+extern struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex);
+extern struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex);
+/* find_by_name, with kref & read_lock taken */
+extern struct j1939_ecu *j1939_ecu_find_priv_default_tx(
+		int ifindex, name_t *pname, uint8_t *paddr);
+
+extern struct proc_dir_entry *j1939_procdir;
+extern const char j1939_procname[];
+
+/* j1939 printk */
+#define j1939_printk(level, ...) printk(level "J1939 " __VA_ARGS__)
+
+#define j1939_err(...)		j1939_printk(KERN_ERR , __VA_ARGS__)
+#define j1939_warning(...)	j1939_printk(KERN_WARNING , __VA_ARGS__)
+#define j1939_notice(...)	j1939_printk(KERN_NOTICE , __VA_ARGS__)
+#define j1939_info(...)		j1939_printk(KERN_INFO , __VA_ARGS__)
+#ifdef DEBUG
+#define j1939_debug(...)	j1939_printk(KERN_DEBUG , __VA_ARGS__)
+#else
+#define j1939_debug(...)
+#endif
+
+struct sk_buff;
+
+/* control buffer of the sk_buff */
+struct j1939_sk_buff_cb {
+	pgn_t pgn;
+	priority_t priority;
+	uint8_t srcaddr;
+	uint8_t dstaddr;
+	name_t srcname;
+	name_t dstname;
+
+	/*
+	 * Flags for quick lookups during skb processing
+	 * These are set in the receive path only
+	 */
+	int srcflags, dstflags;
+	#define ECU_LOCAL	1
+	/* for tx, MSG_SYN will be used to sync on sockets */
+	int msg_flags;
+	/* j1939 clones incoming skb's.
+	 * insock saves the incoming skb->sk
+	 * to determine local generated packets
+	 */
+	struct sock *insock;
+};
+
+#define J1939_MSG_RESERVED	MSG_SYN
+#define J1939_MSG_SYNC		MSG_SYN
+
+static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
+{
+	return (!skcb->dstname && (skcb->dstaddr >= 0xff));
+}
+
+extern int j1939_send(struct sk_buff *);
+extern void j1939_recv(struct sk_buff *);
+
+/* stack entries */
+extern int j1939_send_transport(struct sk_buff *);
+extern int j1939_recv_transport(struct sk_buff *);
+extern int j1939_fixup_address_claim(struct sk_buff *);
+extern void j1939_recv_address_claim(struct sk_buff *, struct j1939_priv *priv);
+
+/* network management */
+/*
+ * j1939_ecu_get_register
+ * 'create' & 'register' & 'get' new ecu
+ * when a matching ecu already exists, then that is returned
+ */
+extern struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv,
+		name_t name, int create_if_necessary);
+/* unregister must be called with lock held */
+extern void _j1939_ecu_unregister(struct j1939_ecu *);
+
+extern int j1939_netdev_start(struct net_device *);
+extern void j1939_netdev_stop(struct net_device *);
+
+static inline struct j1939_priv *dev_j1939_priv(struct net_device *dev)
+{
+	struct dev_rcv_lists *can_ml_priv;
+	struct j1939_priv *priv;
+
+	BUG_ON(!dev);
+
+	if (dev->type != ARPHRD_CAN)
+		return NULL;
+
+	can_ml_priv = dev->ml_priv;
+	priv = can_ml_priv ? can_ml_priv->j1939_priv : NULL;
+	if (priv)
+		get_j1939_priv(priv);
+	return priv;
+}
+
+static inline struct j1939_priv *j1939_priv_find(int ifindex)
+{
+	struct j1939_priv *priv;
+	struct net_device *netdev;
+
+	netdev = dev_get_by_index(&init_net, ifindex);
+	priv = dev_j1939_priv(netdev);
+	if (netdev)
+		dev_put(netdev);
+	return priv;
+}
+
+/* notify/alert all j1939 sockets bound to ifindex */
+extern void j1939sk_netdev_event(int ifindex, int error_code);
+extern int j1939tp_rmdev_notifier(struct net_device *netdev);
+
+/*
+ * decrement pending skb for a j1939 socket
+ */
+extern void j1939_sock_pending_del(struct sock *sk);
+
+/* seperate module-init/modules-exit's */
+extern __init int j1939tp_module_init(void);
+
+extern void j1939tp_module_exit(void);
+
+/* CAN protocol */
+extern const struct can_proto j1939_can_proto;
+
+#endif /* _J1939_PRIV_H_ */
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
new file mode 100644
index 0000000..ee24d48
--- /dev/null
+++ b/net/can/j1939/main.c
@@ -0,0 +1,490 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ * Pieter Beyens <pieter.beyens@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+/*
+ * Core of can-j1939 that links j1939 to CAN.
+ */
+
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/socket.h>
+#include <linux/list.h>
+#include <linux/if_arp.h>
+#include <net/tcp_states.h>
+
+#include <linux/can.h>
+#include <linux/can/core.h>
+#include "j1939-priv.h"
+
+MODULE_DESCRIPTION("PF_CAN SAE J1939");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("EIA Electronics (Kurt Van Dijck & Pieter Beyens)");
+MODULE_ALIAS("can-proto-" __stringify(CAN_J1939));
+
+const char j1939_procname[] = "can-j1939";
+struct proc_dir_entry *j1939_procdir;
+
+/* LOWLEVEL CAN interface */
+
+/* CAN_HDR: #bytes before can_frame data part */
+#define CAN_HDR	(offsetof(struct can_frame, data))
+/* CAN_FTR: #bytes beyond data part */
+#define CAN_FTR	(sizeof(struct can_frame)-CAN_HDR-\
+		sizeof(((struct can_frame *)0)->data))
+
+static unsigned int padding = 0;
+
+module_param_named(padding, padding, uint, 0644);
+
+MODULE_PARM_DESC(padding, "Pad all packets to 8 bytes, and stuff with 0xff");
+
+/* lowest layer */
+static void j1939_can_recv(struct sk_buff *iskb, void *data)
+{
+	struct j1939_priv *priv = data;
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skcb;
+	struct can_frame *cf;
+	struct addr_ent *paddr;
+
+	BUILD_BUG_ON(sizeof(*skcb) > sizeof(skb->cb));
+
+	if (!priv)
+		return;
+
+	/* create a copy of the skb
+	 * j1939 only delivers the real data bytes,
+	 * the header goes into sockaddr.
+	 * j1939 may not touch the incoming skb in such way
+	 */
+	skb = skb_clone(iskb, GFP_ATOMIC);
+	/*
+	 * get a pointer to the header of the skb
+	 * the skb payload (pointer) is moved, so that the next skb_data
+	 * returns the actual payload
+	 */
+	cf = (void *)skb->data;
+	skb_pull(skb, CAN_HDR);
+	/* fix length, set to dlc, with 8 maximum */
+	skb_trim(skb, min_t(uint8_t, cf->can_dlc, 8));
+
+	/* set addr */
+	skcb = (struct j1939_sk_buff_cb *)skb->cb;
+	memset(skcb, 0, sizeof(*skcb));
+	/* save incoming socket, without assigning the skb to it */
+	skcb->insock = iskb->sk;
+	skcb->priority = (cf->can_id & 0x1c000000) >> 26;
+	skcb->srcaddr = cf->can_id & 0xff;
+	skcb->pgn = (cf->can_id & 0x3ffff00) >> 8;
+	if (pgn_is_pdu1(skcb->pgn)) {
+		/* Type 1: with destination address */
+		skcb->dstaddr = skcb->pgn & 0xff;
+		/* normalize pgn: strip dst address */
+		skcb->pgn &= 0x3ff00;
+	} else {
+		/* set broadcast address */
+		skcb->dstaddr = J1939_NO_ADDR;
+	}
+
+	/* update local rxtime cache */
+	write_lock_bh(&priv->lock);
+	if (j1939_address_is_unicast(skcb->srcaddr)) {
+		paddr = &priv->ents[skcb->srcaddr];
+		paddr->rxtime = ktime_get();
+		if (paddr->ecu && skcb->pgn != 0x0ee00)
+			paddr->ecu->rxtime = paddr->rxtime;
+	}
+	write_unlock_bh(&priv->lock);
+
+	/* update localflags */
+	read_lock_bh(&priv->lock);
+	if (j1939_address_is_unicast(skcb->srcaddr) &&
+			priv->ents[skcb->srcaddr].nusers)
+		skcb->srcflags |= ECU_LOCAL;
+	if (j1939_address_is_valid(skcb->dstaddr) ||
+			(j1939_address_is_unicast(skcb->dstaddr) &&
+				priv->ents[skcb->dstaddr].nusers))
+		skcb->dstflags |= ECU_LOCAL;
+	read_unlock_bh(&priv->lock);
+
+	/* deliver into the j1939 stack ... */
+	j1939_recv_address_claim(skb, priv);
+
+	if (j1939_recv_transport(skb))
+		/* this means the transport layer processed the message */
+		goto done;
+	j1939_recv(skb);
+done:
+	kfree_skb(skb);
+}
+
+int j1939_send(struct sk_buff *skb)
+{
+	int ret, dlc;
+	canid_t canid;
+	struct j1939_sk_buff_cb *skcb = (struct j1939_sk_buff_cb *)skb->cb;
+	struct can_frame *cf;
+
+	if (skb->len > 8)
+		/* re-route via transport protocol */
+		return j1939_send_transport(skb);
+
+	/* apply sanity checks */
+	skcb->pgn &= (pgn_is_pdu1(skcb->pgn)) ? 0x3ff00 : 0x3ffff;
+	if (skcb->priority > 7)
+		skcb->priority = 6;
+
+	ret = j1939_fixup_address_claim(skb);
+	if (unlikely(ret))
+		goto failed;
+	dlc = skb->len;
+	if (dlc > 8) {
+		ret = -EMSGSIZE;
+		goto failed;
+	}
+
+	/* re-claim the CAN_HDR from the SKB */
+	cf = (void *)skb_push(skb, CAN_HDR);
+	BUG_ON(!cf);
+	/* make it a full can frame again */
+	skb_put(skb, CAN_FTR + (8 - dlc));
+
+	canid = CAN_EFF_FLAG |
+		(skcb->srcaddr & 0xff) |
+		((skcb->priority & 0x7) << 26);
+	if (pgn_is_pdu1(skcb->pgn))
+		canid |= ((skcb->pgn & 0x3ff00) << 8) |
+			((skcb->dstaddr & 0xff) << 8);
+	else
+		canid |= ((skcb->pgn & 0x3ffff) << 8);
+
+	cf->can_id = canid;
+	if (padding) {
+		memset(cf->data + dlc, 0xff, 8 - dlc);
+		cf->can_dlc = 8;
+	} else
+		cf->can_dlc = dlc;
+
+	return can_send(skb, 1);
+failed:
+	consume_skb(skb);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(j1939_send);
+
+/*
+ * iterate over ECU's,
+ * and register flagged ecu's on their claimed SA
+ */
+static void j1939_priv_ac_task(unsigned long val)
+{
+	struct j1939_priv *priv = (void *)val;
+	struct j1939_ecu *ecu;
+
+	write_lock_bh(&priv->lock);
+	list_for_each_entry(ecu, &priv->ecus, list) {
+		/* next 2 (read & set) could be merged into xxx? */
+		if (!atomic_read(&ecu->ac_delay_expired))
+			continue;
+		atomic_set(&ecu->ac_delay_expired, 0);
+		if (j1939_address_is_unicast(ecu->sa)) {
+			ecu->priv->ents[ecu->sa].ecu = ecu;
+			ecu->priv->ents[ecu->sa].nusers += ecu->nusers;
+		}
+	}
+	write_unlock_bh(&priv->lock);
+}
+
+/* NETDEV MANAGEMENT */
+
+/* values for can_rx_(un)register */
+#define J1939_CAN_ID	CAN_EFF_FLAG
+#define J1939_CAN_MASK	(CAN_EFF_FLAG | CAN_RTR_FLAG)
+
+static DEFINE_MUTEX(j1939_netdev_lock);
+
+int j1939_netdev_start(struct net_device *netdev)
+{
+	int ret;
+	struct j1939_priv *priv;
+	struct dev_rcv_lists *can_ml_priv;
+
+	BUG_ON(!netdev);
+	if (netdev->type != ARPHRD_CAN)
+		return -EAFNOSUPPORT;
+
+	mutex_lock(&j1939_netdev_lock);
+	can_ml_priv = netdev->ml_priv;
+	priv = can_ml_priv->j1939_priv;
+	if (priv) {
+		++priv->nusers;
+		goto done;
+	}
+
+	/* create/stuff j1939_priv */
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		ret = -ENOMEM;
+		goto fail_mem;
+	}
+	tasklet_init(&priv->ac_task, j1939_priv_ac_task, (unsigned long)priv);
+	rwlock_init(&priv->lock);
+	INIT_LIST_HEAD(&priv->ecus);
+	priv->netdev = netdev;
+	priv->ifindex = netdev->ifindex;
+	kref_init(&priv->kref);
+	priv->nusers = 1;
+
+	/* add CAN handler */
+	ret = can_rx_register(netdev, J1939_CAN_ID, J1939_CAN_MASK,
+			      j1939_can_recv, priv, "j1939", NULL);
+	if (ret < 0)
+		goto fail_can;
+
+	can_ml_priv->j1939_priv = priv;
+	dev_hold(netdev);
+done:
+	mutex_unlock(&j1939_netdev_lock);
+	return 0;
+
+fail_can:
+	kfree(priv);
+fail_mem:
+	mutex_unlock(&j1939_netdev_lock);
+	return ret;
+}
+
+void j1939_netdev_stop(struct net_device *netdev)
+{
+	struct dev_rcv_lists *can_ml_priv;
+	struct j1939_priv *priv;
+
+	BUG_ON(!netdev);
+	if (netdev->type != ARPHRD_CAN)
+		return;
+	can_ml_priv = netdev->ml_priv;
+
+	mutex_lock(&j1939_netdev_lock);
+	priv = can_ml_priv->j1939_priv;
+	--priv->nusers;
+	if (priv->nusers) {
+		mutex_unlock(&j1939_netdev_lock);
+		return;
+	}
+	/* no users left, start breakdown */
+
+	/* unlink from netdev */
+	can_ml_priv->j1939_priv = NULL;
+	mutex_unlock(&j1939_netdev_lock);
+
+	can_rx_unregister(netdev, J1939_CAN_ID, J1939_CAN_MASK,
+			j1939_can_recv, priv);
+
+	/* remove pending transport protocol sessions */
+	j1939tp_rmdev_notifier(netdev);
+
+	/* final put */
+	put_j1939_priv(priv);
+	dev_put(netdev);
+}
+
+/*
+ * device interface
+ */
+static void on_put_j1939_priv(struct kref *kref)
+{
+	struct j1939_priv *priv = container_of(kref, struct j1939_priv, kref);
+	struct j1939_ecu *ecu;
+
+	tasklet_disable_nosync(&priv->ac_task);
+
+	/* cleanup priv */
+	write_lock_bh(&priv->lock);
+	while (!list_empty(&priv->ecus)) {
+		ecu = list_first_entry(&priv->ecus, struct j1939_ecu, list);
+		_j1939_ecu_unregister(ecu);
+	}
+	write_unlock_bh(&priv->lock);
+	kfree(priv);
+}
+
+void put_j1939_priv(struct j1939_priv *segment)
+{
+	kref_put(&segment->kref, on_put_j1939_priv);
+}
+
+static int j1939_netdev_notify(struct notifier_block *nb,
+			unsigned long msg, void *data)
+{
+	struct net_device *netdev = (struct net_device *)data;
+
+	if (!net_eq(dev_net(netdev), &init_net))
+		return NOTIFY_DONE;
+
+	if (netdev->type != ARPHRD_CAN)
+		return NOTIFY_DONE;
+
+	switch (msg) {
+	case NETDEV_UNREGISTER:
+		j1939tp_rmdev_notifier(netdev);
+		j1939sk_netdev_event(netdev->ifindex, ENODEV);
+		break;
+
+	case NETDEV_DOWN:
+		j1939sk_netdev_event(netdev->ifindex, ENETDOWN);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block j1939_netdev_notifier = {
+	.notifier_call = j1939_netdev_notify,
+};
+
+/* proc access to the addr+name database */
+static int j1939_proc_show_addr(struct seq_file *sqf, void *v)
+{
+	struct net_device *netdev;
+	struct j1939_priv *priv;
+	int j;
+
+	seq_printf(sqf, "iface\tsa\t#users\n");
+	rcu_read_lock();
+	for_each_netdev_rcu(&init_net, netdev) {
+		priv = dev_j1939_priv(netdev);
+		if (!priv)
+			continue;
+		read_lock_bh(&priv->lock);
+		for (j = 0; j < 0xfe; ++j) {
+			if (!priv->ents[j].nusers)
+				continue;
+			seq_printf(sqf, "%s\t%02x\t%i\n",
+					netdev->name, j, priv->ents[j].nusers);
+		}
+		read_unlock_bh(&priv->lock);
+	}
+	rcu_read_unlock();
+	return 0;
+}
+
+static int j1939_proc_show_name(struct seq_file *sqf, void *v)
+{
+	struct net_device *netdev;
+	struct j1939_priv *priv;
+	struct j1939_ecu *ecu;
+
+	seq_printf(sqf, "iface\tname\tsa\t#users\n");
+	rcu_read_lock();
+	for_each_netdev_rcu(&init_net, netdev) {
+		priv = dev_j1939_priv(netdev);
+		if (!priv)
+			continue;
+		read_lock_bh(&priv->lock);
+		list_for_each_entry(ecu, &priv->ecus, list)
+			seq_printf(sqf, "%s\t%016llx\t%02x%s\t%i\n",
+					netdev->name, ecu->name, ecu->sa,
+				(priv->ents[ecu->sa].ecu == ecu) ? "" : "?",
+					ecu->nusers);
+		read_unlock_bh(&priv->lock);
+	}
+	rcu_read_unlock();
+	return 0;
+}
+
+static int j1939_proc_open_addr(struct inode *inode, struct file *file)
+{
+	return single_open(file, j1939_proc_show_addr, NULL);
+}
+
+static int j1939_proc_open_name(struct inode *inode, struct file *file)
+{
+	return single_open(file, j1939_proc_show_name, NULL);
+}
+
+static const struct file_operations j1939_proc_ops_addr = {
+	.owner		= THIS_MODULE,
+	.open		= j1939_proc_open_addr,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static const struct file_operations j1939_proc_ops_name = {
+	.owner		= THIS_MODULE,
+	.open		= j1939_proc_open_name,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/* MODULE interface */
+static __init int j1939_module_init(void)
+{
+	int ret;
+
+	pr_info("can: SAE J1939\n");
+
+	/* create /proc/net/can directory */
+	j1939_procdir = proc_mkdir(j1939_procname, init_net.proc_net);
+	if (!j1939_procdir)
+		return -EINVAL;
+
+	register_netdevice_notifier(&j1939_netdev_notifier);
+
+	ret = can_proto_register(&j1939_can_proto);
+	if (ret < 0) {
+		pr_err("can: registration of j1939 protocol failed\n");
+		goto fail_sk;
+	}
+	ret = j1939tp_module_init();
+	if (ret < 0)
+		goto fail_tp;
+
+	if (!proc_create("addr", 0444, j1939_procdir, &j1939_proc_ops_addr))
+		goto fail_addr;
+	if (!proc_create("name", 0444, j1939_procdir, &j1939_proc_ops_name))
+		goto fail_name;
+	return 0;
+
+	remove_proc_entry("name", j1939_procdir);
+fail_name:
+	remove_proc_entry("addr", j1939_procdir);
+fail_addr:
+	j1939tp_module_exit();
+fail_tp:
+	can_proto_unregister(&j1939_can_proto);
+fail_sk:
+	unregister_netdevice_notifier(&j1939_netdev_notifier);
+	proc_remove(j1939_procdir);
+	j1939_procdir = NULL;
+	return ret;
+}
+
+static __exit void j1939_module_exit(void)
+{
+	remove_proc_entry("name", j1939_procdir);
+	remove_proc_entry("addr", j1939_procdir);
+	j1939tp_module_exit();
+
+	can_proto_unregister(&j1939_can_proto);
+
+	unregister_netdevice_notifier(&j1939_netdev_notifier);
+
+	proc_remove(j1939_procdir);
+	j1939_procdir = NULL;
+}
+
+module_init(j1939_module_init);
+module_exit(j1939_module_exit);
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
new file mode 100644
index 0000000..a3a2898
--- /dev/null
+++ b/net/can/j1939/socket.c
@@ -0,0 +1,814 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ * Pieter Beyens <pieter.beyens@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/socket.h>
+#include <linux/list.h>
+#include <linux/if_arp.h>
+#include <net/tcp_states.h>
+
+#include <linux/can/core.h>
+#include <linux/can/skb.h>
+#include <linux/can/j1939.h>
+#include "j1939-priv.h"
+
+#define J1939_MIN_NAMELEN required_size(can_addr.j1939, struct sockaddr_can)
+
+/*
+ * list of sockets
+ */
+static struct list_head j1939_socks = LIST_HEAD_INIT(j1939_socks);
+static DEFINE_SPINLOCK(j1939_socks_lock);
+
+struct j1939_sock {
+	struct sock sk; /* must be first to skip with memset */
+	struct list_head list;
+
+	int state;
+	#define JSK_BOUND	BIT(0)
+	#define JSK_CONNECTED	BIT(1)
+	#define PROMISC		BIT(2)
+	#define RECV_OWN	BIT(3)
+
+	int ifindex_started; /* ifindex of netdev */
+
+	struct {
+		name_t src, dst;
+		pgn_t pgn;
+
+		uint8_t sa, da;
+	} addr;
+
+	struct j1939_filter *filters;
+	int nfilters;
+
+	/*
+	 * j1939 may emit equal PGN (!= equal CAN-id's) out of order
+	 * when transport protocol comes in.
+	 * To allow emitting in order, keep a 'pending' nr. of packets
+	 */
+	int skb_pending;
+	spinlock_t lock;
+	wait_queue_head_t waitq;
+};
+
+static inline struct j1939_sock *j1939_sk(const struct sock *sk)
+{
+	return container_of(sk, struct j1939_sock, sk);
+}
+
+/* skb_pending issues */
+static inline int j1939_sock_pending_add_first(struct sock *sk)
+{
+	int saved;
+	struct j1939_sock *jsk = j1939_sk(sk);
+
+	spin_lock_bh(&jsk->lock);
+	if (!jsk->skb_pending) {
+		++jsk->skb_pending;
+		saved = 1;
+	} else
+		saved = 0;
+	spin_unlock_bh(&jsk->lock);
+	return saved;
+}
+
+static inline void j1939_sock_pending_add(struct sock *sk)
+{
+	struct j1939_sock *jsk = j1939_sk(sk);
+
+	spin_lock_bh(&jsk->lock);
+	++jsk->skb_pending;
+	spin_unlock_bh(&jsk->lock);
+}
+
+void j1939_sock_pending_del(struct sock *sk)
+{
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int saved;
+
+	spin_lock_bh(&jsk->lock);
+	--jsk->skb_pending;
+	saved = jsk->skb_pending;
+	spin_unlock_bh(&jsk->lock);
+	if (!saved)
+		wake_up(&jsk->waitq);
+}
+
+static inline int j1939_no_address(const struct sock *sk)
+{
+	const struct j1939_sock *jsk = j1939_sk(sk);
+	return (jsk->addr.sa == J1939_NO_ADDR) && !jsk->addr.src;
+}
+
+/* matches skb control buffer (addr) with a j1939 filter */
+static inline int packet_match(const struct j1939_sk_buff_cb *skcb,
+		const struct j1939_filter *f, int nfilter)
+{
+	if (!nfilter)
+		/* receive all when no filters are assigned */
+		return 1;
+	/*
+	 * Filters relying on the addr for static addressing _should_ get
+	 * packets from dynamic addressed ECU's too if they match their SA.
+	 * Sockets using dynamic addressing in their filters should not set it.
+	 */
+	for (; nfilter; ++f, --nfilter) {
+		if ((skcb->pgn & f->pgn_mask) != (f->pgn & f->pgn_mask))
+			continue;
+		if ((skcb->srcaddr & f->addr_mask) != (f->addr & f->addr_mask))
+			continue;
+		if ((skcb->srcname & f->name_mask) != (f->name & f->name_mask))
+			continue;
+		return 1;
+	}
+	return 0;
+}
+
+/* callback per socket, called from j1939_recv */
+static void j1939sk_recv_skb(struct sk_buff *oskb, struct j1939_sock *jsk)
+{
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skcb = (void *)oskb->cb;
+
+	if (!(jsk->state & (JSK_BOUND | JSK_CONNECTED)))
+		return;
+	if (jsk->sk.sk_bound_dev_if &&
+			(jsk->sk.sk_bound_dev_if != oskb->skb_iif))
+		/* this socket does not take packets from this iface */
+		return;
+	if (!(jsk->state & PROMISC)) {
+		if (jsk->addr.src) {
+			/* reject message for other destinations */
+			if (skcb->dstname &&
+				(skcb->dstname != jsk->addr.src))
+				/*
+				 * the msg is not destined for the name
+				 * that the socket is bound to
+				 */
+				return;
+		} else {
+			/* reject messages for other destination addresses */
+			if (j1939_address_is_unicast(skcb->dstaddr) &&
+				(skcb->dstaddr != jsk->addr.sa))
+				/*
+				 * the msg is not destined for the name
+				 * that the socket is bound to
+				 */
+				return;
+		}
+	}
+
+	if ((skcb->insock == &jsk->sk) && !(jsk->state & RECV_OWN))
+		/* own message */
+		return;
+
+	if (!packet_match(skcb, jsk->filters, jsk->nfilters))
+		return;
+
+	skb = skb_clone(oskb, GFP_ATOMIC);
+	if (!skb) {
+		j1939_warning("skb clone failed\n");
+		return;
+	}
+	skcb = (void *)skb->cb;
+	skcb->msg_flags &= ~(MSG_DONTROUTE | MSG_CONFIRM);
+	if (skcb->insock)
+		skcb->msg_flags |= MSG_DONTROUTE;
+	if (skcb->insock == &jsk->sk)
+		skcb->msg_flags |= MSG_CONFIRM;
+
+	if (sock_queue_rcv_skb(&jsk->sk, skb) < 0)
+		kfree_skb(skb);
+}
+
+void j1939_recv(struct sk_buff *skb)
+{
+	struct j1939_sock *jsk;
+
+	spin_lock_bh(&j1939_socks_lock);
+	list_for_each_entry(jsk, &j1939_socks, list) {
+		j1939sk_recv_skb(skb, jsk);
+	}
+	spin_unlock_bh(&j1939_socks_lock);
+}
+EXPORT_SYMBOL_GPL(j1939_recv);
+
+static int j1939sk_init(struct sock *sk)
+{
+	struct j1939_sock *jsk = j1939_sk(sk);
+
+	INIT_LIST_HEAD(&jsk->list);
+	spin_lock_init(&jsk->lock);
+	init_waitqueue_head(&jsk->waitq);
+	jsk->sk.sk_priority = j1939_to_sk_priority(6);
+	jsk->sk.sk_reuse = 1; /* per default */
+	jsk->addr.sa = J1939_NO_ADDR;
+	jsk->addr.da = J1939_NO_ADDR;
+	jsk->addr.pgn = J1939_NO_PGN;
+	return 0;
+}
+
+/*
+ * helper: return <0 for error, >0 for error to notify
+ */
+static int j1939_ifindex_start(int ifindex)
+{
+	int ret;
+	struct net_device *netdev;
+
+	netdev = dev_get_by_index(&init_net, ifindex);
+	if (!netdev)
+		return -ENODEV;
+
+	/* no need to test for CAN device,
+	 * done by j1939_netdev_start
+	 */
+	ret = j1939_netdev_start(netdev);
+
+	dev_put(netdev);
+	return ret;
+}
+
+static void j1939_ifindex_stop(int ifindex)
+{
+	struct net_device *netdev;
+
+	netdev = dev_get_by_index(&init_net, ifindex);
+	if (netdev) {
+		j1939_netdev_stop(netdev);
+		dev_put(netdev);
+	}
+}
+
+static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct j1939_sock *jsk = j1939_sk(sock->sk);
+	int ret, bound_dev_if;
+	struct j1939_priv *priv;
+
+	if (len < J1939_MIN_NAMELEN)
+		return -EINVAL;
+	if (addr->can_family != AF_CAN)
+		return -EINVAL;
+
+	lock_sock(sock->sk);
+
+	/* bind to device ... */
+	bound_dev_if = jsk->sk.sk_bound_dev_if;
+	/* copy netdev info */
+	if (!bound_dev_if && addr->can_ifindex)
+		bound_dev_if = addr->can_ifindex;
+	else if (bound_dev_if && addr->can_ifindex) {
+		/* do netdev */
+		if (bound_dev_if != addr->can_ifindex) {
+			ret = -EBUSY;
+			goto fail_locked;
+		}
+	}
+	/* start j1939 */
+	if (bound_dev_if && bound_dev_if != jsk->ifindex_started) {
+		if (jsk->ifindex_started) {
+			ret = -EBUSY;
+			goto fail_locked;
+		}
+		ret = j1939_ifindex_start(bound_dev_if);
+		if (ret < 0)
+			goto fail_locked;
+		jsk->ifindex_started = bound_dev_if;
+		priv = j1939_priv_find(jsk->ifindex_started);
+		j1939_name_local_get(priv, jsk->addr.src);
+		j1939_addr_local_get(priv, jsk->addr.sa);
+		put_j1939_priv(priv);
+	}
+
+	jsk->sk.sk_bound_dev_if = bound_dev_if;
+
+	/* set addr + name */
+	if (jsk->ifindex_started) {
+		priv = j1939_priv_find(jsk->ifindex_started);
+		/* priv should be set when ifindex_started is nonzero */
+		j1939_name_local_put(priv, jsk->addr.src);
+		j1939_name_local_get(priv, addr->can_addr.j1939.name);
+		j1939_addr_local_put(priv, jsk->addr.sa);
+		j1939_addr_local_get(priv, addr->can_addr.j1939.addr);
+		put_j1939_priv(priv);
+	}
+	jsk->addr.src = addr->can_addr.j1939.name;
+	jsk->addr.sa = addr->can_addr.j1939.addr;
+
+
+	/* set default transmit pgn */
+	if (pgn_is_valid(addr->can_addr.j1939.pgn))
+		jsk->addr.pgn = addr->can_addr.j1939.pgn;
+
+	if (!(jsk->state & (JSK_BOUND | JSK_CONNECTED))) {
+		spin_lock_bh(&j1939_socks_lock);
+		list_add_tail(&jsk->list, &j1939_socks);
+		spin_unlock_bh(&j1939_socks_lock);
+	}
+	jsk->state |= JSK_BOUND;
+
+	ret = 0;
+
+fail_locked:
+	if (!jsk->sk.sk_bound_dev_if && jsk->ifindex_started) {
+		/* started j1939 on this netdev during this call,
+		 * so we revert that */
+		j1939_ifindex_stop(jsk->ifindex_started);
+		jsk->ifindex_started = 0;
+	}
+	release_sock(sock->sk);
+	return ret;
+}
+
+static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
+		int len, int flags)
+{
+	int ret;
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct j1939_sock *jsk = j1939_sk(sock->sk);
+	struct j1939_priv *priv;
+	int bound_dev_if;
+
+	if (!uaddr)
+		return -EDESTADDRREQ;
+
+	if (len < J1939_MIN_NAMELEN)
+		return -EINVAL;
+	if (addr->can_family != AF_CAN)
+		return -EINVAL;
+
+	lock_sock(sock->sk);
+
+	/* bind to device ... */
+	bound_dev_if = jsk->sk.sk_bound_dev_if;
+	/* copy netdev info */
+	if (!bound_dev_if && addr->can_ifindex)
+		bound_dev_if = addr->can_ifindex;
+	else if (bound_dev_if && addr->can_ifindex) {
+		/* do netdev */
+		if (bound_dev_if != addr->can_ifindex) {
+			ret = -EBUSY;
+			goto fail_locked;
+		}
+	}
+	/* start j1939 */
+	if (bound_dev_if && bound_dev_if != jsk->ifindex_started) {
+		if (jsk->ifindex_started) {
+			ret = -EBUSY;
+			goto fail_locked;
+		}
+		ret = j1939_ifindex_start(bound_dev_if);
+		if (ret < 0)
+			goto fail_locked;
+		jsk->ifindex_started = bound_dev_if;
+		/* make sure that this is in sync */
+		priv = j1939_priv_find(jsk->ifindex_started);
+		j1939_name_local_get(priv, jsk->addr.src);
+		j1939_addr_local_get(priv, jsk->addr.sa);
+		put_j1939_priv(priv);
+	}
+
+	/* lookup destination */
+	jsk->addr.dst = addr->can_addr.j1939.name;
+	jsk->addr.da = addr->can_addr.j1939.addr;
+
+	/* start assigning, no problem can occur at this point anymore */
+	jsk->sk.sk_bound_dev_if = bound_dev_if;
+
+	if (pgn_is_valid(addr->can_addr.j1939.pgn))
+		jsk->addr.pgn = addr->can_addr.j1939.pgn;
+
+	if (!(jsk->state & (JSK_BOUND | JSK_CONNECTED))) {
+		spin_lock_bh(&j1939_socks_lock);
+		list_add_tail(&jsk->list, &j1939_socks);
+		spin_unlock_bh(&j1939_socks_lock);
+	}
+	jsk->state |= JSK_CONNECTED;
+	ret = 0;
+
+fail_locked:
+	release_sock(sock->sk);
+	return ret;
+}
+
+static void j1939sk_sock2sockaddr_can(struct sockaddr_can *addr,
+		const struct j1939_sock *jsk, int peer)
+{
+	addr->can_family = AF_CAN;
+	addr->can_ifindex = jsk->sk.sk_bound_dev_if;
+	addr->can_addr.j1939.name = peer ? jsk->addr.dst : jsk->addr.src;
+	addr->can_addr.j1939.pgn = jsk->addr.pgn;
+	addr->can_addr.j1939.addr = peer ? jsk->addr.da : jsk->addr.sa;
+}
+
+static int j1939sk_getname(struct socket *sock, struct sockaddr *uaddr,
+		int *len, int peer)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int ret = 0;
+
+	lock_sock(sk);
+
+	if (peer && !(jsk->state & JSK_CONNECTED)) {
+		ret = -EADDRNOTAVAIL;
+		goto failure;
+	}
+
+	j1939sk_sock2sockaddr_can(addr, jsk, peer);
+	*len = J1939_MIN_NAMELEN;
+
+failure:
+	release_sock(sk);
+
+	return ret;
+}
+
+static int j1939sk_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk;
+	struct j1939_priv *priv;
+
+	if (!sk)
+		return 0;
+	lock_sock(sk);
+	jsk = j1939_sk(sk);
+	spin_lock_bh(&j1939_socks_lock);
+	list_del_init(&jsk->list);
+	spin_unlock_bh(&j1939_socks_lock);
+
+	if (jsk->ifindex_started) {
+		priv = j1939_priv_find(jsk->ifindex_started);
+		j1939_addr_local_put(priv, jsk->addr.sa);
+		j1939_name_local_put(priv, jsk->addr.src);
+		put_j1939_priv(priv);
+
+		j1939_ifindex_stop(jsk->ifindex_started);
+	}
+	jsk->ifindex_started = 0;
+
+	sock_orphan(sk);
+	sock->sk = NULL;
+
+	release_sock(sk);
+	sock_put(sk);
+
+	return 0;
+}
+
+static int j1939sk_setsockopt_flag(struct j1939_sock *jsk,
+		char __user *optval, unsigned int optlen, int flag)
+{
+	int tmp;
+
+	if (optlen != sizeof(tmp))
+		return -EINVAL;
+	if (copy_from_user(&tmp, optval, optlen))
+		return -EFAULT;
+	lock_sock(&jsk->sk);
+	if (tmp)
+		jsk->state |= flag;
+	else
+		jsk->state &= ~flag;
+	release_sock(&jsk->sk);
+	return tmp;
+}
+
+static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
+		char __user *optval, unsigned int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int tmp, count;
+	struct j1939_filter *filters, *ofilters;
+
+	if (level != SOL_CAN_J1939)
+		return -EINVAL;
+
+	switch (optname) {
+	case SO_J1939_FILTER:
+		if (optval) {
+			if (optlen % sizeof(*filters) != 0)
+				return -EINVAL;
+			count = optlen / sizeof(*filters);
+			filters = kmalloc(optlen, GFP_KERNEL);
+			if (!filters)
+				return -ENOMEM;
+			if (copy_from_user(filters, optval, optlen)) {
+				kfree(filters);
+				return -EFAULT;
+			}
+		} else {
+			filters = NULL;
+			count = 0;
+		}
+
+		spin_lock_bh(&j1939_socks_lock);
+		ofilters = jsk->filters;
+		jsk->filters = filters;
+		jsk->nfilters = count;
+		spin_unlock_bh(&j1939_socks_lock);
+		if (ofilters)
+			kfree(ofilters);
+		return 0;
+	case SO_J1939_PROMISC:
+		return j1939sk_setsockopt_flag(jsk, optval, optlen, PROMISC);
+	case SO_J1939_RECV_OWN:
+		return j1939sk_setsockopt_flag(jsk, optval, optlen, RECV_OWN);
+	case SO_J1939_SEND_PRIO:
+		if (optlen != sizeof(tmp))
+			return -EINVAL;
+		if (copy_from_user(&tmp, optval, optlen))
+			return -EFAULT;
+		if ((tmp < 0) || (tmp > 7))
+			return -EDOM;
+		if ((tmp < 2) && !capable(CAP_NET_ADMIN))
+			return -EPERM;
+		lock_sock(&jsk->sk);
+		jsk->sk.sk_priority = j1939_to_sk_priority(tmp);
+		release_sock(&jsk->sk);
+		return 0;
+	default:
+		return -ENOPROTOOPT;
+	}
+}
+
+static int j1939sk_getsockopt(struct socket *sock, int level, int optname,
+		char __user *optval, int __user *optlen)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int ret, ulen;
+	/* set defaults for using 'int' properties */
+	int tmp = 0;
+	int len = sizeof(tmp);
+	void *val = &tmp;
+
+	if (level != SOL_CAN_J1939)
+		return -EINVAL;
+	if (get_user(ulen, optlen))
+		return -EFAULT;
+	if (ulen < 0)
+		return -EINVAL;
+
+	lock_sock(&jsk->sk);
+	switch (optname) {
+	case SO_J1939_PROMISC:
+		tmp = (jsk->state & PROMISC) ? 1 : 0;
+		break;
+	case SO_J1939_RECV_OWN:
+		tmp = (jsk->state & RECV_OWN) ? 1 : 0;
+		break;
+	case SO_J1939_SEND_PRIO:
+		tmp = j1939_prio(jsk->sk.sk_priority);
+		break;
+	default:
+		ret = -ENOPROTOOPT;
+		goto no_copy;
+	}
+
+	/*
+	 * copy to user, based on 'len' & 'val'
+	 * but most sockopt's are 'int' properties, and have 'len' & 'val'
+	 * left unchanged, but instead modified 'tmp'
+	 */
+	if (len > ulen)
+		ret = -EFAULT;
+	else if (put_user(len, optlen))
+		ret = -EFAULT;
+	else if (copy_to_user(optval, val, len))
+		ret = -EFAULT;
+	else
+		ret = 0;
+no_copy:
+	release_sock(&jsk->sk);
+	return ret;
+}
+
+static int j1939sk_recvmsg(struct socket *sock, struct msghdr *msg,
+		size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skcb;
+	int ret = 0;
+
+	skb = skb_recv_datagram(sk, flags, 0, &ret);
+	if (!skb)
+		return ret;
+
+	if (size < skb->len)
+		msg->msg_flags |= MSG_TRUNC;
+	else
+		size = skb->len;
+
+	ret = memcpy_to_msg(msg, skb->data, size);
+	if (ret < 0) {
+		skb_free_datagram(sk, skb);
+		return ret;
+	}
+
+	skcb = (void *)skb->cb;
+	if (j1939_address_is_valid(skcb->dstaddr))
+		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_ADDR,
+				sizeof(skcb->dstaddr), &skcb->dstaddr);
+
+	if (skcb->dstname)
+		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_NAME,
+				sizeof(skcb->dstname), &skcb->dstname);
+
+	put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_PRIO,
+			sizeof(skcb->priority), &skcb->priority);
+
+	if (msg->msg_name) {
+		struct sockaddr_can *paddr = msg->msg_name;
+
+		msg->msg_namelen = J1939_MIN_NAMELEN;
+		memset(msg->msg_name, 0, msg->msg_namelen);
+		paddr->can_family = AF_CAN;
+		paddr->can_ifindex = skb->skb_iif;
+		paddr->can_addr.j1939.name = skcb->srcname;
+		paddr->can_addr.j1939.addr = skcb->srcaddr;
+		paddr->can_addr.j1939.pgn = skcb->pgn;
+	}
+
+	sock_recv_ts_and_drops(msg, sk, skb);
+	msg->msg_flags |= skcb->msg_flags;
+	skb_free_datagram(sk, skb);
+
+	return size;
+}
+
+static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	struct sockaddr_can *addr = msg->msg_name;
+	struct j1939_sk_buff_cb *skcb;
+	struct sk_buff *skb;
+	struct net_device *dev;
+	int ifindex;
+	int ret;
+
+	/* various socket state tests */
+	if (!(jsk->state & JSK_BOUND))
+		return -EBADFD;
+
+	ifindex = jsk->ifindex_started;
+	if (!ifindex)
+		return -EBADFD;
+
+	if (jsk->addr.sa == J1939_NO_ADDR && !jsk->addr.src)
+		/* no address assigned yet */
+		return -EBADFD;
+
+	/* deal with provided address info */
+	if (msg->msg_name) {
+		if (msg->msg_namelen < J1939_MIN_NAMELEN)
+			return -EINVAL;
+		if (addr->can_family != AF_CAN)
+			return -EINVAL;
+		if (addr->can_ifindex && (ifindex != addr->can_ifindex))
+			return -EBADFD;
+	}
+
+	dev = dev_get_by_index(&init_net, ifindex);
+	if (!dev)
+		return -ENXIO;
+
+	skb = sock_alloc_send_skb(sk, size + sizeof(struct can_frame) - sizeof(((struct can_frame*)NULL)->data) + sizeof(struct can_skb_priv),
+			msg->msg_flags & MSG_DONTWAIT, &ret);
+	if (!skb)
+		goto put_dev;
+
+	can_skb_reserve(skb);
+	can_skb_prv(skb)->ifindex = dev->ifindex;
+	skb_reserve(skb, offsetof(struct can_frame, data));
+
+	ret = memcpy_from_msg(skb_put(skb, size), msg, size);
+	if (ret < 0)
+		goto free_skb;
+	sock_tx_timestamp(sk, &skb_shinfo(skb)->tx_flags);
+
+	skb->dev = dev;
+
+	skcb = (void *)skb->cb;
+	memset(skcb, 0, sizeof(*skcb));
+	skcb->msg_flags = msg->msg_flags;
+	skcb->srcname = jsk->addr.src;
+	skcb->dstname = jsk->addr.dst;
+	skcb->pgn = jsk->addr.pgn;
+	skcb->priority = j1939_prio(jsk->sk.sk_priority);
+	skcb->srcaddr = jsk->addr.sa;
+	skcb->dstaddr = jsk->addr.da;
+
+	if (msg->msg_name) {
+		struct sockaddr_can *addr = msg->msg_name;
+
+		if (addr->can_addr.j1939.name ||
+				(addr->can_addr.j1939.addr != J1939_NO_ADDR)) {
+			skcb->dstname = addr->can_addr.j1939.name;
+			skcb->dstaddr = addr->can_addr.j1939.addr;
+		}
+		if (pgn_is_valid(addr->can_addr.j1939.pgn))
+			skcb->pgn = addr->can_addr.j1939.pgn;
+	}
+	if (!pgn_is_valid(skcb->pgn)) {
+		ret = -EINVAL;
+		goto free_skb;
+	}
+
+	if (skcb->msg_flags & J1939_MSG_SYNC) {
+		if (skcb->msg_flags & MSG_DONTWAIT) {
+			ret = j1939_sock_pending_add_first(&jsk->sk);
+			if (ret > 0)
+				ret = -EAGAIN;
+		} else {
+			ret = wait_event_interruptible(jsk->waitq,
+					j1939_sock_pending_add_first(&jsk->sk));
+		}
+		if (ret < 0)
+			goto free_skb;
+	} else {
+		j1939_sock_pending_add(&jsk->sk);
+	}
+
+	ret = j1939_send(skb);
+	if (ret < 0)
+		j1939_sock_pending_del(&jsk->sk);
+
+	dev_put(dev);
+	return (ret < 0) ? ret : size;
+
+free_skb:
+	kfree_skb(skb);
+put_dev:
+	dev_put(dev);
+	return ret;
+}
+
+void j1939sk_netdev_event(int ifindex, int error_code)
+{
+	struct j1939_sock *jsk;
+
+	spin_lock_bh(&j1939_socks_lock);
+	list_for_each_entry(jsk, &j1939_socks, list) {
+		if (jsk->sk.sk_bound_dev_if != ifindex)
+			continue;
+		jsk->sk.sk_err = error_code;
+		if (!sock_flag(&jsk->sk, SOCK_DEAD))
+			jsk->sk.sk_error_report(&jsk->sk);
+		/* do not remove filters here */
+	}
+	spin_unlock_bh(&j1939_socks_lock);
+}
+
+static const struct proto_ops j1939_ops = {
+	.family = PF_CAN,
+	.release = j1939sk_release,
+	.bind = j1939sk_bind,
+	.connect = j1939sk_connect,
+	.socketpair = sock_no_socketpair,
+	.accept = sock_no_accept,
+	.getname = j1939sk_getname,
+	.poll = datagram_poll,
+	.ioctl = can_ioctl,
+	.listen = sock_no_listen,
+	.shutdown = sock_no_shutdown,
+	.setsockopt = j1939sk_setsockopt,
+	.getsockopt = j1939sk_getsockopt,
+	.sendmsg = j1939sk_sendmsg,
+	.recvmsg = j1939sk_recvmsg,
+	.mmap = sock_no_mmap,
+	.sendpage = sock_no_sendpage,
+};
+
+static struct proto j1939_proto __read_mostly = {
+	.name = "CAN_J1939",
+	.owner = THIS_MODULE,
+	.obj_size = sizeof(struct j1939_sock),
+	.init = j1939sk_init,
+};
+
+const struct can_proto j1939_can_proto = {
+	.type = SOCK_DGRAM,
+	.protocol = CAN_J1939,
+	.ops = &j1939_ops,
+	.prot = &j1939_proto,
+};
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
new file mode 100644
index 0000000..688e965
--- /dev/null
+++ b/net/can/j1939/transport.c
@@ -0,0 +1,1428 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <linux/skbuff.h>
+#include <linux/hrtimer.h>
+#include <linux/version.h>
+#include <linux/if_arp.h>
+#include <linux/wait.h>
+#include <linux/seq_file.h>
+#include <linux/can/skb.h>
+#include "j1939-priv.h"
+
+#define REGULAR		0
+#define EXTENDED	1
+
+#define etp_pgn_ctl	0xc800
+#define etp_pgn_dat	0xc700
+#define tp_pgn_ctl	0xec00
+#define tp_pgn_dat	0xeb00
+
+#define  tp_cmd_bam	0x20
+#define  tp_cmd_rts	0x10
+#define  tp_cmd_cts	0x11
+#define  tp_cmd_eof	0x13
+#define  tp_cmd_abort	0xff
+
+#define etp_cmd_rts	0x14
+#define etp_cmd_cts	0x15
+#define etp_cmd_dpo	0x16
+#define etp_cmd_eof	0x17
+#define etp_cmd_abort	0xff
+
+#define ABORT_BUSY	1
+#define ABORT_RESOURCE	2
+#define ABORT_TIMEOUT	3
+#define ABORT_GENERIC	4
+#define ABORT_FAULT	5
+
+#define MAX_TP_PACKET_SIZE	(7*255)
+#define MAX_ETP_PACKET_SIZE	(7*0xffffff)
+
+static unsigned int block = 255;
+static unsigned int max_packet_size = 1024*100;
+static unsigned int retry_ms = 20;
+static unsigned int packet_delay = 0;
+
+module_param_named(transport_burst_count, block, uint, 0644);
+module_param_named(transport_max_size, max_packet_size, uint, 0644);
+module_param_named(transport_retry_time, retry_ms, uint, 0644);
+module_param_named(transport_packet_delay, packet_delay, uint, 0644);
+
+MODULE_PARM_DESC(transport_burst_count, "Number of packets to send in burst between flow control (1..255, default 255)");
+MODULE_PARM_DESC(transport_max_size, "Maximum packet size (default 100k)");
+MODULE_PARM_DESC(transport_retry_time, "Packet retransmission timeout in msecs, used in case of buffer full. (default 20)");
+MODULE_PARM_DESC(transport_packet_delay, "Delay between packets to avoid buffer overruns (default 0)");
+
+struct session {
+	struct list_head list;
+	atomic_t refs;
+	spinlock_t lock;
+
+	struct j1939_sk_buff_cb *cb; /*
+	 * ifindex, src, dst, pgn define the session block
+	 * the are _never_ modified after insertion in the list
+	 * this decreases locking problems a _lot_
+	 */
+	struct sk_buff *skb;
+	int skb_iif;
+
+	/*
+	 * all tx related stuff (last_txcmd, pkt.tx)
+	 * is protected (modified only) with the txtask tasklet
+	 * 'total' & 'block' are never changed,
+	 * last_cmd, last & block are protected by ->lock
+	 * this means that the tx may run after cts is received that should
+	 * have stopped tx, but this time discrepancy is never avoided anyhow
+	 */
+	uint8_t last_cmd, last_txcmd;
+	uint8_t transmission;
+	uint8_t extd;
+	struct {
+		/*
+		 * these do not require 16 bit, they should fit in uint8_t
+		 * but putting in int makes it easier to deal with
+		 */
+		unsigned int total, done, last, tx;
+		unsigned int block; /* for TP */
+		unsigned int dpo; /* for ETP */
+	} pkt;
+	struct hrtimer txtimer, rxtimer;
+	/* tasklets for execution of tx/rx timer hander in softirq */
+	struct tasklet_struct txtask, rxtask;
+};
+
+/* forward declarations */
+static struct session *j1939session_new(struct sk_buff *skb);
+static struct session *j1939session_fresh_new(int size,
+		struct sk_buff *rel_skb, pgn_t pgn);
+static void j1939tp_del_work(struct work_struct *work);
+
+/* local variables */
+static DEFINE_SPINLOCK(tp_lock);
+static struct list_head tp_sessionq = LIST_HEAD_INIT(tp_sessionq);
+static struct list_head tp_extsessionq = LIST_HEAD_INIT(tp_extsessionq);
+static DEFINE_SPINLOCK(tp_dellock);
+static struct list_head tp_delsessionq = LIST_HEAD_INIT(tp_delsessionq);
+static DECLARE_WORK(tp_delwork, j1939tp_del_work);
+static DECLARE_WAIT_QUEUE_HEAD(tp_wait);
+
+/* helpers */
+static inline void fix_cb(struct j1939_sk_buff_cb *cb)
+{
+	cb->msg_flags &= ~J1939_MSG_RESERVED;
+}
+
+static inline struct list_head *sessionq(int extd)
+{
+	return extd ? &tp_extsessionq : &tp_sessionq;
+}
+
+static inline void j1939session_destroy(struct session *session)
+{
+	if (session->skb)
+		kfree_skb(session->skb);
+	hrtimer_cancel(&session->rxtimer);
+	hrtimer_cancel(&session->txtimer);
+	tasklet_disable(&session->rxtask);
+	tasklet_disable(&session->txtask);
+	kfree(session);
+}
+
+/* clean up work queue */
+static void j1939tp_del_work(struct work_struct *work)
+{
+	struct session *session;
+	int cnt = 0;
+
+	do {
+		session = NULL;
+		spin_lock_bh(&tp_dellock);
+		if (list_empty(&tp_delsessionq)) {
+			spin_unlock_bh(&tp_dellock);
+			break;
+		}
+		session = list_first_entry(&tp_delsessionq,
+				struct session, list);
+		list_del_init(&session->list);
+		spin_unlock_bh(&tp_dellock);
+		j1939session_destroy(session);
+		++cnt;
+	} while (1);
+}
+/* reference counter */
+static inline void get_session(struct session *session)
+{
+	atomic_inc(&session->refs);
+}
+
+static void put_session(struct session *session)
+{
+	BUG_ON(!session);
+	if (atomic_add_return(-1, &session->refs) >= 0)
+		/* not the last one */
+		return;
+	/* it should have been removed from any list long time ago */
+	BUG_ON(!list_empty(&session->list));
+
+	hrtimer_try_to_cancel(&session->rxtimer);
+	hrtimer_try_to_cancel(&session->txtimer);
+	tasklet_disable_nosync(&session->rxtask);
+	tasklet_disable_nosync(&session->txtask);
+
+	if (in_interrupt()) {
+		spin_lock_bh(&tp_dellock);
+		list_add_tail(&session->list, &tp_delsessionq);
+		spin_unlock_bh(&tp_dellock);
+		schedule_work(&tp_delwork);
+	} else {
+		/* destroy session right here */
+		j1939session_destroy(session);
+	}
+}
+
+/* transport status locking */
+static inline void session_lock(struct session *session)
+{
+	get_session(session); /* safety measure */
+	spin_lock_bh(&session->lock);
+}
+
+static inline void session_unlock(struct session *session)
+{
+	spin_unlock_bh(&session->lock);
+	put_session(session);
+}
+
+static inline void sessionlist_lock(void)
+{
+	spin_lock_bh(&tp_lock);
+}
+
+static inline void sessionlist_unlock(void)
+{
+	spin_unlock_bh(&tp_lock);
+}
+
+/*
+ * see if we are receiver
+ * returns 0 for broadcasts, although we will receive them
+ */
+static inline int j1939tp_im_receiver(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	return cb->dstflags & ECU_LOCAL;
+}
+
+/* see if we are sender */
+static inline int j1939tp_im_transmitter(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	return cb->srcflags & ECU_LOCAL;
+}
+
+/* see if we are involved as either receiver or transmitter */
+static int j1939tp_im_involved(struct sk_buff *skb, int swap)
+{
+	return swap ? j1939tp_im_receiver(skb) : j1939tp_im_transmitter(skb);
+}
+
+static int j1939tp_im_involved_anydir(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	return (cb->srcflags | cb->dstflags) & ECU_LOCAL;
+}
+
+/* extract pgn from flow-ctl message */
+static inline pgn_t j1939xtp_ctl_to_pgn(const uint8_t *dat)
+{
+	pgn_t pgn;
+
+	pgn = (dat[7] << 16) | (dat[6] << 8) | (dat[5] << 0);
+	if (pgn_is_pdu1(pgn))
+		pgn &= 0xffff00;
+	return pgn;
+}
+
+static inline unsigned int j1939tp_ctl_to_size(const uint8_t *dat)
+{
+	return (dat[2] << 8) + (dat[1] << 0);
+}
+static inline unsigned int j1939etp_ctl_to_packet(const uint8_t *dat)
+{
+	return (dat[4] << 16) | (dat[3] << 8) | (dat[2] << 0);
+}
+static inline unsigned int j1939etp_ctl_to_size(const uint8_t *dat)
+{
+	return (dat[4] << 24) | (dat[3] << 16) |
+		(dat[2] << 8) | (dat[1] << 0);
+}
+
+/*
+ * find existing session:
+ * reverse: swap cb's src & dst
+ * there is no problem with matching broadcasts, since
+ * broadcasts (no dst, no da) would never call this
+ * with reverse==1
+ */
+static int j1939tp_match(struct session *session, struct sk_buff *skb,
+		int reverse)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	if (session->skb_iif != skb->skb_iif)
+		return 0;
+	if (!reverse) {
+		if (session->cb->srcname) {
+			if (session->cb->srcname != cb->srcname)
+				return 0;
+		} else if (session->cb->srcaddr != cb->srcaddr)
+			return 0;
+		if (session->cb->dstname) {
+			if (session->cb->dstname != cb->dstname)
+				return 0;
+		} else if (session->cb->dstaddr != cb->dstaddr)
+			return 0;
+	} else {
+		if (session->cb->srcname) {
+			if (session->cb->srcname != cb->dstname)
+				return 0;
+		} else if (session->cb->srcaddr != cb->dstaddr)
+			return 0;
+		if (session->cb->dstname) {
+			if (session->cb->dstname != cb->srcname)
+				return 0;
+		} else if (session->cb->dstaddr != cb->srcaddr)
+			return 0;
+	}
+	return 1;
+}
+
+static struct session *_j1939tp_find(struct list_head *root,
+		struct sk_buff *skb, int reverse)
+{
+	struct session *session;
+
+	list_for_each_entry(session, root, list) {
+		get_session(session);
+		if (j1939tp_match(session, skb, reverse))
+			return session;
+		put_session(session);
+	}
+	return NULL;
+}
+
+static struct session *j1939tp_find(struct list_head *root,
+		struct sk_buff *skb, int reverse)
+{
+	struct session *session;
+	sessionlist_lock();
+	session = _j1939tp_find(root, skb, reverse);
+	sessionlist_unlock();
+	return session;
+}
+
+static void j1939_skbcb_swap(struct j1939_sk_buff_cb *cb)
+{
+	name_t name;
+	uint8_t addr;
+	int flags;
+
+	name = cb->dstname;
+	cb->dstname = cb->srcname;
+	cb->srcname = name;
+
+	addr = cb->dstaddr;
+	cb->dstaddr = cb->srcaddr;
+	cb->srcaddr = addr;
+
+	flags = cb->dstflags;
+	cb->dstflags = cb->srcflags;
+	cb->srcflags = flags;
+}
+/* TP transmit packet functions */
+static int j1939tp_tx_dat(struct sk_buff *related, int extd,
+		const uint8_t *dat, int len)
+{
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skb_cb;
+	uint8_t *skdat;
+
+	skb = alloc_skb(sizeof(struct can_frame) + sizeof(struct can_skb_priv),
+			GFP_ATOMIC);
+	if (unlikely(!skb)) {
+		pr_alert("%s: out of memory?\n", __func__);
+		return -ENOMEM;
+	}
+	can_skb_reserve(skb);
+	can_skb_prv(skb)->ifindex = can_skb_prv(related)->ifindex;
+	/* reserve CAN header */
+	skb_reserve(skb, offsetof(struct can_frame, data));
+
+	skb->dev = related->dev;
+	skb->protocol = related->protocol;
+	skb->pkt_type = related->pkt_type;
+	skb->ip_summed = related->ip_summed;
+
+	memcpy(skb->cb, related->cb, sizeof(skb->cb));
+	skb_cb = (void *)skb->cb;
+	fix_cb(skb_cb);
+	/* fix pgn */
+	skb_cb->pgn = extd ? etp_pgn_dat : tp_pgn_dat;
+
+	skdat = skb_put(skb, len);
+	memcpy(skdat, dat, len);
+	return j1939_send(skb);
+}
+
+static int j1939xtp_do_tx_ctl(struct sk_buff *related, int extd,
+		int swap_src_dst, pgn_t pgn, const uint8_t dat[5])
+{
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skb_cb;
+	uint8_t *skdat;
+
+	if (!j1939tp_im_involved(related, swap_src_dst))
+		return 0;
+
+	skb = alloc_skb(sizeof(struct can_frame) + sizeof(struct can_skb_priv),
+			GFP_ATOMIC);
+	if (unlikely(!skb)) {
+		pr_alert("%s: out of memory?\n", __func__);
+		return -ENOMEM;
+	}
+	skb->dev = related->dev;
+	can_skb_reserve(skb);
+	can_skb_prv(skb)->ifindex = can_skb_prv(related)->ifindex;
+	/* reserve CAN header */
+	skb_reserve(skb, offsetof(struct can_frame, data));
+	skb->protocol = related->protocol;
+	skb->pkt_type = related->pkt_type;
+	skb->ip_summed = related->ip_summed;
+
+	memcpy(skb->cb, related->cb, sizeof(skb->cb));
+	skb_cb = (void *)skb->cb;
+	fix_cb(skb_cb);
+	if (swap_src_dst)
+		j1939_skbcb_swap(skb_cb);
+	skb_cb->pgn = extd ? etp_pgn_ctl : tp_pgn_ctl;
+
+	skdat = skb_put(skb, 8);
+	memcpy(skdat, dat, 5);
+	skdat[7] = (pgn >> 16) & 0xff;
+	skdat[6] = (pgn >>  8) & 0xff;
+	skdat[5] = (pgn >>  0) & 0xff;
+
+	return j1939_send(skb);
+}
+
+static inline int j1939tp_tx_ctl(struct session *session,
+		int swap_src_dst, const uint8_t dat[8])
+{
+	return j1939xtp_do_tx_ctl(session->skb, session->extd, swap_src_dst,
+			session->cb->pgn, dat);
+}
+
+static int j1939xtp_tx_abort(struct sk_buff *related, int extd,
+		int swap_src_dst, int err, pgn_t pgn)
+{
+	uint8_t dat[5];
+
+	if (!j1939tp_im_involved(related, swap_src_dst))
+		return 0;
+
+	memset(dat, 0xff, sizeof(dat));
+	dat[0] = tp_cmd_abort;
+	if (!extd)
+		dat[1] = err ?: ABORT_GENERIC;
+	return j1939xtp_do_tx_ctl(related, extd, swap_src_dst, pgn, dat);
+}
+
+/* timer & scheduler functions */
+static inline void j1939session_schedule_txnow(struct session *session)
+{
+	tasklet_schedule(&session->txtask);
+}
+static enum hrtimer_restart j1939tp_txtimer(struct hrtimer *hrtimer)
+{
+	struct session *session =
+		container_of(hrtimer, struct session, txtimer);
+	j1939session_schedule_txnow(session);
+	return HRTIMER_NORESTART;
+}
+static inline void j1939tp_schedule_txtimer(struct session *session, int msec)
+{
+	hrtimer_start(&session->txtimer,
+			ktime_set(msec / 1000, (msec % 1000)*1000000UL),
+			HRTIMER_MODE_REL);
+}
+static inline void j1939tp_set_rxtimeout(struct session *session, int msec)
+{
+	hrtimer_start(&session->rxtimer,
+			ktime_set(msec / 1000, (msec % 1000)*1000000UL),
+			HRTIMER_MODE_REL);
+}
+
+/*
+ * session completion functions
+ */
+/*
+ * j1939session_drop
+ * removes a session from open session list
+ */
+static inline void j1939session_drop(struct session *session)
+{
+	sessionlist_lock();
+	list_del_init(&session->list);
+	sessionlist_unlock();
+
+	if (session->transmission) {
+		if (session->skb && session->skb->sk)
+			j1939_sock_pending_del(session->skb->sk);
+		wake_up_all(&tp_wait);
+	}
+	put_session(session);
+}
+
+static inline void j1939session_completed(struct session *session)
+{
+	/* distribute among j1939 receivers */
+	j1939_recv(session->skb);
+	j1939session_drop(session);
+}
+
+static void j1939session_cancel(struct session *session, int err)
+{
+	if ((err >= 0) && j1939tp_im_involved_anydir(session->skb)) {
+		if (!j1939cb_is_broadcast(session->cb)) {
+			/* do not send aborts on incoming broadcasts */
+			j1939xtp_tx_abort(session->skb, session->extd,
+				!(session->cb->srcflags & ECU_LOCAL),
+				err, session->cb->pgn);
+		}
+	}
+	j1939session_drop(session);
+}
+
+static enum hrtimer_restart j1939tp_rxtimer(struct hrtimer *hrtimer)
+{
+	struct session *session =
+		container_of(hrtimer, struct session, rxtimer);
+	tasklet_schedule(&session->rxtask);
+	return HRTIMER_NORESTART;
+}
+
+static void j1939tp_rxtask(unsigned long val)
+{
+	struct session *session = (void *)val;
+
+	get_session(session);
+	pr_alert("%s: timeout on %i\n", __func__, session->skb_iif);
+	j1939session_cancel(session, ABORT_TIMEOUT);
+	put_session(session);
+}
+
+/*
+ * receive packet functions
+ */
+static void _j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
+{
+	struct session *session;
+	pgn_t pgn;
+
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), skb, 0);
+	if (session /*&& (session->cb->pgn == pgn)*/) {
+		/* do not allow TP control messages on 2 pgn's */
+		j1939session_cancel(session, ABORT_FAULT);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	j1939xtp_tx_abort(skb, extd, 0, ABORT_FAULT, pgn);
+	if (!session)
+		return;
+	put_session(session); /* ~j1939tp_find */
+}
+
+/* abort packets may come in 2 directions */
+static void j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	pr_info("%s, pgn %05x\n", __func__, j1939xtp_ctl_to_pgn(skb->data));
+	_j1939xtp_rx_bad_message(skb, extd);
+	j1939_skbcb_swap(cb);
+	_j1939xtp_rx_bad_message(skb, extd);
+	/* restore skb */
+	j1939_skbcb_swap(cb);
+	return;
+}
+
+static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd)
+{
+	struct session *session;
+	pgn_t pgn;
+
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), skb, 0);
+	if (!session)
+		return;
+	if (session->transmission && !session->last_txcmd) {
+		/*
+		 * empty block:
+		 * do not drop session when a transmit session did not
+		 * start yet
+		 */
+	} else if (session->cb->pgn == pgn)
+		j1939session_drop(session);
+	/* another PGN had a bad message */
+	/*
+	 * TODO: maybe cancel current connection
+	 * as another pgn was communicated
+	 */
+	put_session(session); /* ~j1939tp_find */
+}
+/* abort packets may come in 2 directions */
+static inline void j1939xtp_rx_abort(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	pr_info("%s %i, %05x\n", __func__, skb->skb_iif,
+			j1939xtp_ctl_to_pgn(skb->data));
+	_j1939xtp_rx_abort(skb, extd);
+	j1939_skbcb_swap(cb);
+	_j1939xtp_rx_abort(skb, extd);
+	/* restore skb */
+	j1939_skbcb_swap(cb);
+	return;
+}
+
+static void j1939xtp_rx_eof(struct sk_buff *skb, int extd)
+{
+	struct session *session;
+	pgn_t pgn;
+
+	/* end of tx cycle */
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), skb, 1);
+	if (!session)
+		/*
+		 * strange, we had EOF on closed connection
+		 * do nothing, as EOF closes the connection anyway
+		 */
+		return;
+
+	if (session->cb->pgn != pgn) {
+		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
+		j1939session_cancel(session, ABORT_BUSY);
+	} else {
+		/* transmitted without problems */
+		j1939session_completed(session);
+	}
+	put_session(session); /* ~j1939tp_find */
+}
+
+static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
+{
+	struct session *session;
+	pgn_t pgn;
+	unsigned int pkt;
+	const uint8_t *dat;
+
+	dat = skb->data;
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), skb, 1);
+	if (!session) {
+		/* 'CTS shall be ignored' */
+		return;
+	}
+	if (session->cb->pgn != pgn) {
+		/* what to do? */
+		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
+		j1939session_cancel(session, ABORT_BUSY);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	session_lock(session);
+	pkt = extd ? j1939etp_ctl_to_packet(dat) : dat[2];
+	if (!dat[0])
+		hrtimer_cancel(&session->txtimer);
+	else if (!pkt)
+		goto bad_fmt;
+	else if (dat[1] > session->pkt.block /* 0xff for etp */)
+		goto bad_fmt;
+	else {
+		/* set packet counters only when not CTS(0) */
+		session->pkt.done = pkt - 1;
+		session->pkt.last = session->pkt.done + dat[1];
+		if (session->pkt.last > session->pkt.total)
+			/* safety measure */
+			session->pkt.last = session->pkt.total;
+		/* TODO: do not set tx here, do it in txtask */
+		session->pkt.tx = session->pkt.done;
+	}
+	session->last_cmd = dat[0];
+	session_unlock(session);
+	if (dat[1]) {
+		j1939tp_set_rxtimeout(session, 1250);
+		if (j1939tp_im_transmitter(session->skb))
+			j1939session_schedule_txnow(session);
+	} else {
+		/* CTS(0) */
+		j1939tp_set_rxtimeout(session, 550);
+	}
+	put_session(session); /* ~j1939tp_find */
+	return;
+bad_fmt:
+	session_unlock(session);
+	j1939session_cancel(session, ABORT_FAULT);
+	put_session(session); /* ~j1939tp_find */
+}
+
+static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	int len;
+	const uint8_t *dat;
+	pgn_t pgn;
+
+	dat = skb->data;
+	pgn = j1939xtp_ctl_to_pgn(dat);
+
+	if ((tp_cmd_rts == dat[0]) && j1939cb_is_broadcast(cb)) {
+		pr_alert("%s: rts without destination (%i %02x)\n", __func__,
+			skb->skb_iif, cb->srcaddr);
+		return;
+	}
+	/*
+	 * TODO: abort RTS when a similar
+	 * TP is pending in the other direction
+	 */
+	session = j1939tp_find(sessionq(extd), skb, 0);
+	if (session && !j1939tp_im_transmitter(skb)) {
+		/* RTS on pending connection */
+		j1939session_cancel(session, ABORT_BUSY);
+		if ((pgn != session->cb->pgn) && (tp_cmd_bam != dat[0]))
+			j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	} else if (!session && j1939tp_im_transmitter(skb)) {
+		pr_alert("%s: I should tx (%i %02x %02x)\n", __func__,
+			skb->skb_iif, cb->srcaddr, cb->dstaddr);
+		return;
+	}
+	if (session && (0 != session->last_cmd)) {
+		/* we received a second rts on the same connection */
+		pr_alert("%s: connection exists (%i %02x %02x)\n", __func__,
+				skb->skb_iif, cb->srcaddr, cb->dstaddr);
+		j1939session_cancel(session, ABORT_BUSY);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	if (session) {
+		/*
+		 * make sure 'sa' & 'da' are correct !
+		 * They may be 'not filled in yet' for sending
+		 * skb's, since they did not pass the Address Claim ever.
+		 */
+		session->cb->srcaddr = cb->srcaddr;
+		session->cb->dstaddr = cb->dstaddr;
+	} else {
+		int abort = 0;
+		if (extd) {
+			len = j1939etp_ctl_to_size(dat);
+			if (len > MAX_ETP_PACKET_SIZE)
+				abort = ABORT_FAULT;
+			else if (max_packet_size && (len > max_packet_size))
+				abort = ABORT_RESOURCE;
+			else if (len <= MAX_TP_PACKET_SIZE)
+				abort = ABORT_FAULT;
+		} else {
+			len = j1939tp_ctl_to_size(dat);
+			if (len > MAX_TP_PACKET_SIZE)
+				abort = ABORT_FAULT;
+			else if (max_packet_size && (len > max_packet_size))
+				abort = ABORT_RESOURCE;
+		}
+		if (abort) {
+			j1939xtp_tx_abort(skb, extd, 1, abort, pgn);
+			return;
+		}
+		session = j1939session_fresh_new(len, skb, pgn);
+		if (!session) {
+			j1939xtp_tx_abort(skb, extd, 1, ABORT_RESOURCE, pgn);
+			return;
+		}
+		session->extd = extd;
+		/* initialize the control buffer: plain copy */
+		session->pkt.total = (len+6)/7;
+		session->pkt.block = 0xff;
+		if (!extd) {
+			if (dat[3] != session->pkt.total)
+				pr_alert("%s: strange total,"
+						" %u != %u\n", __func__,
+						session->pkt.total, dat[3]);
+			session->pkt.total = dat[3];
+			session->pkt.block = dat[4];
+		}
+		session->pkt.done = session->pkt.tx = 0;
+		get_session(session); /* equivalent to j1939tp_find() */
+		sessionlist_lock();
+		list_add_tail(&session->list, sessionq(extd));
+		sessionlist_unlock();
+	}
+	session->last_cmd = dat[0];
+
+	j1939tp_set_rxtimeout(session, 1250);
+
+	if (j1939tp_im_receiver(session->skb)) {
+		if (extd || (tp_cmd_bam != dat[0]))
+			j1939session_schedule_txnow(session);
+	}
+	/*
+	 * as soon as it's inserted, things can go fast
+	 * protect against a long delay
+	 * between spin_unlock & next statement
+	 * so, only release here, at the end
+	 */
+	put_session(session); /* ~j1939tp_find */
+	return;
+}
+
+static void j1939xtp_rx_dpo(struct sk_buff *skb, int extd)
+{
+	struct session *session;
+	pgn_t pgn;
+	const uint8_t *dat = skb->data;
+
+	pgn = j1939xtp_ctl_to_pgn(dat);
+	session = j1939tp_find(sessionq(extd), skb, 0);
+	if (!session) {
+		pr_info("%s: %s\n", __func__, "no connection found");
+		return;
+	}
+
+	if (session->cb->pgn != pgn) {
+		pr_info("%s: different pgn\n", __func__);
+		j1939xtp_tx_abort(skb, 1, 1, ABORT_BUSY, pgn);
+		j1939session_cancel(session, ABORT_BUSY);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	/* transmitted without problems */
+	session->pkt.dpo = j1939etp_ctl_to_packet(skb->data);
+	session->last_cmd = dat[0];
+	j1939tp_set_rxtimeout(session, 750);
+	put_session(session); /* ~j1939tp_find */
+}
+
+static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
+{
+	struct session *session;
+	const uint8_t *dat;
+	uint8_t *tpdat;
+	int offset;
+	int nbytes;
+	int final;
+	int do_cts_eof;
+	int packet;
+
+	session = j1939tp_find(sessionq(extd), skb, 0);
+	if (!session) {
+		pr_info("%s:%s\n", __func__, "no connection found");
+		return;
+	}
+	dat = skb->data;
+	if (skb->len <= 1)
+		/* makes no sense */
+		goto strange_packet_unlocked;
+
+	session_lock(session);
+
+	switch (session->last_cmd) {
+	case 0xff:
+		break;
+	case etp_cmd_dpo:
+		if (extd)
+			break;
+	case tp_cmd_bam:
+	case tp_cmd_cts:
+		if (!extd)
+			break;
+	default:
+		pr_info("%s: last %02x\n", __func__,
+				session->last_cmd);
+		goto strange_packet;
+	}
+
+	packet = (dat[0]-1+session->pkt.dpo);
+	offset = packet * 7;
+	if ((packet > session->pkt.total) ||
+			(session->pkt.done+1) > session->pkt.total) {
+		pr_info("%s: should have been completed\n", __func__);
+		goto strange_packet;
+	}
+	nbytes = session->skb->len - offset;
+	if (nbytes > 7)
+		nbytes = 7;
+	if ((nbytes <= 0) || ((nbytes + 1) > skb->len)) {
+		pr_info("%s: nbytes %i, len %i\n", __func__, nbytes,
+				skb->len);
+		goto strange_packet;
+	}
+	tpdat = session->skb->data;
+	memcpy(&tpdat[offset], &dat[1], nbytes);
+	if (packet == session->pkt.done)
+		++session->pkt.done;
+
+	if (!extd && j1939cb_is_broadcast(session->cb)) {
+		final = session->pkt.done >= session->pkt.total;
+		do_cts_eof = 0;
+	} else {
+		final = 0; /* never final, an EOF must follow */
+		do_cts_eof = (session->pkt.done >= session->pkt.last);
+	}
+	session_unlock(session);
+	if (final) {
+		j1939session_completed(session);
+	} else if (do_cts_eof) {
+		j1939tp_set_rxtimeout(session, 1250);
+		if (j1939tp_im_receiver(session->skb))
+			j1939session_schedule_txnow(session);
+	} else {
+		j1939tp_set_rxtimeout(session, 250);
+	}
+	session->last_cmd = 0xff;
+	put_session(session); /* ~j1939tp_find */
+	return;
+
+strange_packet:
+	/* unlock session (spinlock) before trying to send */
+	session_unlock(session);
+strange_packet_unlocked:
+	j1939session_cancel(session, ABORT_FAULT);
+	put_session(session); /* ~j1939tp_find */
+}
+
+/*
+ * transmit function
+ */
+static int j1939tp_txnext(struct session *session)
+{
+	uint8_t dat[8];
+	const uint8_t *tpdat;
+	int ret, offset, pkt_done, pkt_end;
+	unsigned int pkt, len, pdelay;
+
+	memset(dat, 0xff, sizeof(dat));
+	get_session(session); /* do not loose it */
+
+	switch (session->last_cmd) {
+	case 0:
+		if (!j1939tp_im_transmitter(session->skb))
+			break;
+		dat[1] = (session->skb->len >> 0) & 0xff;
+		dat[2] = (session->skb->len >> 8) & 0xff;
+		dat[3] = session->pkt.total;
+		if (session->extd) {
+			dat[0] = etp_cmd_rts;
+			dat[1] = (session->skb->len >>  0) & 0xff;
+			dat[2] = (session->skb->len >>  8) & 0xff;
+			dat[3] = (session->skb->len >> 16) & 0xff;
+			dat[4] = (session->skb->len >> 24) & 0xff;
+		} else if (j1939cb_is_broadcast(session->cb)) {
+			dat[0] = tp_cmd_bam;
+			/* fake cts for broadcast */
+			session->pkt.tx = 0;
+		} else {
+			dat[0] = tp_cmd_rts;
+			dat[4] = dat[3];
+		}
+		if (dat[0] == session->last_txcmd)
+			/* done already */
+			break;
+		ret = j1939tp_tx_ctl(session, 0, dat);
+		if (ret < 0)
+			goto failed;
+		session->last_txcmd = dat[0];
+		/* must lock? */
+		if (tp_cmd_bam == dat[0])
+			j1939tp_schedule_txtimer(session, 50);
+		j1939tp_set_rxtimeout(session, 1250);
+		break;
+	case tp_cmd_rts:
+	case etp_cmd_rts:
+		if (!j1939tp_im_receiver(session->skb))
+			break;
+tx_cts:
+		ret = 0;
+		len = session->pkt.total - session->pkt.done;
+		len = min(max(len, session->pkt.block), block ?: 255);
+
+		if (session->extd) {
+			pkt = session->pkt.done+1;
+			dat[0] = etp_cmd_cts;
+			dat[1] = len;
+			dat[2] = (pkt >>  0) & 0xff;
+			dat[3] = (pkt >>  8) & 0xff;
+			dat[4] = (pkt >> 16) & 0xff;
+		} else {
+			dat[0] = tp_cmd_cts;
+			dat[1] = len;
+			dat[2] = session->pkt.done+1;
+		}
+		if (dat[0] == session->last_txcmd)
+			/* done already */
+			break;
+		ret = j1939tp_tx_ctl(session, 1, dat);
+		if (ret < 0)
+			goto failed;
+		if (len)
+			/* only mark cts done when len is set */
+			session->last_txcmd = dat[0];
+		j1939tp_set_rxtimeout(session, 1250);
+		break;
+	case etp_cmd_cts:
+		if (j1939tp_im_transmitter(session->skb) && session->extd &&
+		    (etp_cmd_dpo != session->last_txcmd)) {
+			/* do dpo */
+			dat[0] = etp_cmd_dpo;
+			session->pkt.dpo = session->pkt.done;
+			pkt = session->pkt.dpo;
+			dat[1] = session->pkt.last - session->pkt.done;
+			dat[2] = (pkt >>  0) & 0xff;
+			dat[3] = (pkt >>  8) & 0xff;
+			dat[4] = (pkt >> 16) & 0xff;
+			ret = j1939tp_tx_ctl(session, 0, dat);
+			if (ret < 0)
+				goto failed;
+			session->last_txcmd = dat[0];
+			j1939tp_set_rxtimeout(session, 1250);
+			session->pkt.tx = session->pkt.done;
+		}
+	case tp_cmd_cts:
+	case 0xff: /* did some data */
+	case etp_cmd_dpo:
+		if ((session->extd || !j1939cb_is_broadcast(session->cb)) &&
+		     j1939tp_im_receiver(session->skb)) {
+			if (session->pkt.done >= session->pkt.total) {
+				if (session->extd) {
+					dat[0] = etp_cmd_eof;
+					dat[1] = session->skb->len >> 0;
+					dat[2] = session->skb->len >> 8;
+					dat[3] = session->skb->len >> 16;
+					dat[4] = session->skb->len >> 24;
+				} else {
+					dat[0] = tp_cmd_eof;
+					dat[1] = session->skb->len;
+					dat[2] = session->skb->len >> 8;
+					dat[3] = session->pkt.total;
+				}
+				if (dat[0] == session->last_txcmd)
+					/* done already */
+					break;
+				ret = j1939tp_tx_ctl(session, 1, dat);
+				if (ret < 0)
+					goto failed;
+				session->last_txcmd = dat[0];
+				j1939tp_set_rxtimeout(session, 1250);
+				/* wait for the EOF packet to come in */
+				break;
+			} else if (session->pkt.done >= session->pkt.last) {
+				session->last_txcmd = 0;
+				goto tx_cts;
+			}
+		}
+	case tp_cmd_bam:
+		if (!j1939tp_im_transmitter(session->skb))
+			break;
+		tpdat = session->skb->data;
+		ret = 0;
+		pkt_done = 0;
+		pkt_end = (!session->extd && j1939cb_is_broadcast(session->cb))
+			? session->pkt.total : session->pkt.last;
+
+		while (session->pkt.tx < pkt_end) {
+			dat[0] = session->pkt.tx - session->pkt.dpo+1;
+			offset = session->pkt.tx * 7;
+			len = session->skb->len - offset;
+			if (len > 7)
+				len = 7;
+			memcpy(&dat[1], &tpdat[offset], len);
+			ret = j1939tp_tx_dat(session->skb, session->extd,
+					dat, len+1);
+			if (ret < 0)
+				break;
+			session->last_txcmd = 0xff;
+			++pkt_done;
+			++session->pkt.tx;
+			pdelay = j1939cb_is_broadcast(session->cb) ?  50 :
+				packet_delay;
+			if ((session->pkt.tx < session->pkt.total) && pdelay) {
+				j1939tp_schedule_txtimer(session, pdelay);
+				break;
+			}
+		}
+		if (pkt_done)
+			j1939tp_set_rxtimeout(session, 250);
+		if (ret)
+			goto failed;
+		break;
+	}
+	put_session(session);
+	return 0;
+failed:
+	put_session(session);
+	return ret;
+}
+
+static void j1939tp_txtask(unsigned long val)
+{
+	struct session *session = (void *)val;
+	int ret;
+
+	get_session(session);
+	ret = j1939tp_txnext(session);
+	if (ret < 0)
+		j1939tp_schedule_txtimer(session, retry_ms ?: 20);
+	put_session(session);
+}
+
+static inline int j1939tp_tx_initial(struct session *session)
+{
+	int ret;
+
+	get_session(session);
+	ret = j1939tp_txnext(session);
+	/* set nonblocking for further packets */
+	session->cb->msg_flags |= MSG_DONTWAIT;
+	put_session(session);
+	return ret;
+}
+
+/* this call is to be used as probe within wait_event_xxx() */
+static int j1939session_insert(struct session *session)
+{
+	struct session *pending;
+
+	sessionlist_lock();
+	pending = _j1939tp_find(sessionq(session->extd), session->skb, 0);
+	if (pending)
+		/* revert the effect of find() */
+		put_session(pending);
+	else
+		list_add_tail(&session->list, sessionq(session->extd));
+	sessionlist_unlock();
+	return pending ? 0 : 1;
+}
+/*
+ * j1939 main intf
+ */
+int j1939_send_transport(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	int ret;
+	struct j1939_priv *priv;
+
+	if ((tp_pgn_dat == cb->pgn) || (tp_pgn_ctl == cb->pgn) ||
+	    (etp_pgn_dat == cb->pgn) || (etp_pgn_ctl == cb->pgn))
+		/* avoid conflict */
+		return -EDOM;
+	else if ((skb->len > MAX_ETP_PACKET_SIZE) ||
+			(max_packet_size && (skb->len > max_packet_size)))
+		return -EMSGSIZE;
+
+	if (skb->len > MAX_TP_PACKET_SIZE) {
+		if (j1939cb_is_broadcast(cb))
+			return -EDESTADDRREQ;
+	}
+
+	/* fill in addresses from names */
+	ret = j1939_fixup_address_claim(skb);
+	if (unlikely(ret))
+		return ret;
+
+	/* fix dstflags, it may be used there soon */
+	priv = j1939_priv_find(can_skb_prv(skb)->ifindex);
+	if (!priv)
+		return -EINVAL;
+	if (!j1939_address_is_valid(cb->dstaddr) ||
+			(j1939_address_is_unicast(cb->dstaddr) &&
+				priv->ents[cb->dstaddr].nusers))
+		cb->dstflags |= ECU_LOCAL;
+	put_j1939_priv(priv);
+	/* src is always local, I'm sending ... */
+	cb->srcflags |= ECU_LOCAL;
+
+	/* prepare new session */
+	session = j1939session_new(skb);
+	if (!session)
+		return -ENOMEM;
+
+	session->skb_iif = can_skb_prv(skb)->ifindex;
+	session->extd = (skb->len > MAX_TP_PACKET_SIZE) ? EXTENDED : REGULAR;
+	session->transmission = 1;
+	session->pkt.total = (skb->len + 6)/7;
+	session->pkt.block = session->extd ? 255 :
+		min(block ?: 255, session->pkt.total);
+	if (j1939cb_is_broadcast(session->cb))
+		/* set the end-packet for broadcast */
+		session->pkt.last = session->pkt.total;
+
+	/* insert into queue, but avoid collision with pending session */
+	if (session->cb->msg_flags & MSG_DONTWAIT)
+		ret = j1939session_insert(session) ? 0 : -EAGAIN;
+	else
+		ret = wait_event_interruptible(tp_wait,
+				j1939session_insert(session));
+	if (ret < 0)
+		goto failed;
+
+	ret = j1939tp_tx_initial(session);
+	if (!ret)
+		/* transmission started */
+		return ret;
+	sessionlist_lock();
+	list_del_init(&session->list);
+	sessionlist_unlock();
+failed:
+	/*
+	 * hide the skb from j1939session_drop, as it would
+	 * kfree_skb, but our caller will kfree_skb(skb) too.
+	 */
+	session->skb = NULL;
+	j1939session_drop(session);
+	return ret;
+}
+
+int j1939_recv_transport(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	const uint8_t *dat;
+
+	switch (cb->pgn) {
+	case etp_pgn_dat:
+		j1939xtp_rx_dat(skb, EXTENDED);
+		break;
+	case etp_pgn_ctl:
+		if (skb->len < 8) {
+			j1939xtp_rx_bad_message(skb, EXTENDED);
+			break;
+		}
+		dat = skb->data;
+		switch (*dat) {
+		case etp_cmd_rts:
+			j1939xtp_rx_rts(skb, EXTENDED);
+			break;
+		case etp_cmd_cts:
+			j1939xtp_rx_cts(skb, EXTENDED);
+			break;
+		case etp_cmd_dpo:
+			j1939xtp_rx_dpo(skb, EXTENDED);
+			break;
+		case etp_cmd_eof:
+			j1939xtp_rx_eof(skb, EXTENDED);
+			break;
+		case etp_cmd_abort:
+			j1939xtp_rx_abort(skb, EXTENDED);
+			break;
+		default:
+			j1939xtp_rx_bad_message(skb, EXTENDED);
+			break;
+		}
+		break;
+	case tp_pgn_dat:
+		j1939xtp_rx_dat(skb, REGULAR);
+		break;
+	case tp_pgn_ctl:
+		if (skb->len < 8) {
+			j1939xtp_rx_bad_message(skb, REGULAR);
+			break;
+		}
+		dat = skb->data;
+		switch (*dat) {
+		case tp_cmd_bam:
+		case tp_cmd_rts:
+			j1939xtp_rx_rts(skb, REGULAR);
+			break;
+		case tp_cmd_cts:
+			j1939xtp_rx_cts(skb, REGULAR);
+			break;
+		case tp_cmd_eof:
+			j1939xtp_rx_eof(skb, REGULAR);
+			break;
+		case tp_cmd_abort:
+			j1939xtp_rx_abort(skb, REGULAR);
+			break;
+		default:
+			j1939xtp_rx_bad_message(skb, REGULAR);
+			break;
+		}
+		break;
+	default:
+		return 0; /* no problem */
+	}
+	return 1; /* "I processed the message" */
+}
+
+static struct session *j1939session_fresh_new(int size,
+		struct sk_buff *rel_skb, pgn_t pgn)
+{
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *cb;
+	struct session *session;
+
+	/* this SKB is allocated without headroom for CAN skb's.
+	 * This may not pose a problem, this SKB will never
+	 * enter generic CAN functions
+	 */
+	skb = alloc_skb(size, GFP_ATOMIC);
+	if (!skb)
+		return NULL;
+
+	cb = (void *)skb->cb;
+	memcpy(cb, rel_skb->cb, sizeof(*cb));
+	fix_cb(cb);
+	cb->pgn = pgn;
+
+	session = j1939session_new(skb);
+	if (!session) {
+		kfree(skb);
+		return NULL;
+	}
+	session->skb_iif = rel_skb->skb_iif;
+	skb->dev = rel_skb->dev;
+	/* alloc data area */
+	skb_put(skb, size);
+	return session;
+}
+static struct session *j1939session_new(struct sk_buff *skb)
+{
+	struct session *session;
+
+	session = kzalloc(sizeof(*session), gfp_any());
+	if (!session)
+		return NULL;
+	INIT_LIST_HEAD(&session->list);
+	spin_lock_init(&session->lock);
+	session->skb = skb;
+
+	session->cb = (void *)session->skb->cb;
+	hrtimer_init(&session->txtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	session->txtimer.function = j1939tp_txtimer;
+	hrtimer_init(&session->rxtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	session->rxtimer.function = j1939tp_rxtimer;
+	tasklet_init(&session->txtask, j1939tp_txtask, (unsigned long)session);
+	tasklet_init(&session->rxtask, j1939tp_rxtask, (unsigned long)session);
+	return session;
+}
+
+int j1939tp_rmdev_notifier(struct net_device *netdev)
+{
+	struct session *session, *saved;
+
+	sessionlist_lock();
+	list_for_each_entry_safe(session, saved, &tp_sessionq, list) {
+		if (session->skb_iif != netdev->ifindex)
+			continue;
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	list_for_each_entry_safe(session, saved, &tp_extsessionq, list) {
+		if (session->skb_iif != netdev->ifindex)
+			continue;
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	sessionlist_unlock();
+	return NOTIFY_DONE;
+}
+
+/* PROC */
+static int j1939tp_proc_show_session(struct seq_file *sqf,
+		struct session *session)
+{
+	seq_printf(sqf, "%i", session->skb_iif);
+	if (session->cb->srcname)
+		seq_printf(sqf, "\t%016llx", session->cb->srcname);
+	else
+		seq_printf(sqf, "\t%02x", session->cb->srcaddr);
+	if (session->cb->dstname)
+		seq_printf(sqf, "\t%016llx", session->cb->dstname);
+	else if (j1939_address_is_unicast(session->cb->dstaddr))
+		seq_printf(sqf, "\t%02x", session->cb->dstaddr);
+	else
+		seq_printf(sqf, "\t-");
+	seq_printf(sqf, "\t%05x\t%u/%u\n", session->cb->pgn,
+			session->pkt.done*7, session->skb->len);
+	return 0;
+}
+
+static int j1939tp_proc_show(struct seq_file *sqf, void *v)
+{
+	struct session *session;
+
+	seq_printf(sqf, "iface\tsrc\tdst\tpgn\tdone/total\n");
+	sessionlist_lock();
+	list_for_each_entry(session, &tp_sessionq, list)
+		j1939tp_proc_show_session(sqf, session);
+	list_for_each_entry(session, &tp_extsessionq, list)
+		j1939tp_proc_show_session(sqf, session);
+	sessionlist_unlock();
+	return 0;
+}
+
+static int j1939tp_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, j1939tp_proc_show, NULL);
+}
+
+static const struct file_operations j1939tp_proc_ops = {
+	.owner		= THIS_MODULE,
+	.open		= j1939tp_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/* module init */
+int __init j1939tp_module_init(void)
+{
+	if (!proc_create("transport", 0444, j1939_procdir, &j1939tp_proc_ops))
+		return -ENOMEM;
+	return 0;
+}
+
+void j1939tp_module_exit(void)
+{
+	struct session *session, *saved;
+
+	wake_up_all(&tp_wait);
+
+	remove_proc_entry("transport", j1939_procdir);
+	sessionlist_lock();
+	list_for_each_entry_safe(session, saved, &tp_extsessionq, list) {
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	list_for_each_entry_safe(session, saved, &tp_sessionq, list) {
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	sessionlist_unlock();
+	flush_scheduled_work();
+}
+
diff --git a/net/can/raw.c b/net/can/raw.c
index 014874b..23fd13b 100644
--- a/net/can/raw.c
+++ b/net/can/raw.c
@@ -397,7 +397,7 @@ static int raw_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 	int err = 0;
 	int notify_enetdown = 0;
 
-	if (len < sizeof(*addr))
+	if (len < required_size(can_ifindex, *addr))
 		return -EINVAL;
 	if (addr->can_family != AF_CAN)
 		return -EINVAL;
@@ -734,7 +734,7 @@ static int raw_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	if (msg->msg_name) {
 		DECLARE_SOCKADDR(struct sockaddr_can *, addr, msg->msg_name);
 
-		if (msg->msg_namelen < sizeof(*addr))
+		if (msg->msg_namelen < required_size(can_ifindex, *addr))
 			return -EINVAL;
 
 		if (addr->can_family != AF_CAN)
-- 
1.9.1


From 0ca89519a552b1baa16469a5e9a152936646fc56 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 18:09:24 +0200
Subject: [PATCH 017/113] j1939: convert sock_tx_timestamp() to v4.7

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index a3a2898..574c07e 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -704,7 +704,7 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	ret = memcpy_from_msg(skb_put(skb, size), msg, size);
 	if (ret < 0)
 		goto free_skb;
-	sock_tx_timestamp(sk, &skb_shinfo(skb)->tx_flags);
+	sock_tx_timestamp(sk, skb->sk->sk_tsflags, &skb_shinfo(skb)->tx_flags);
 
 	skb->dev = dev;
 
-- 
1.9.1


From 1f96ecc77b927dd2d7be8962e6e71de8b83cc5e3 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Fri, 2 Jun 2017 09:02:32 +0200
Subject: [PATCH 018/113] j1939: port to v4.12

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/main.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index ee24d48..981d5a5 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -247,7 +247,7 @@ int j1939_netdev_start(struct net_device *netdev)
 	priv->nusers = 1;
 
 	/* add CAN handler */
-	ret = can_rx_register(netdev, J1939_CAN_ID, J1939_CAN_MASK,
+	ret = can_rx_register(&init_net, netdev, J1939_CAN_ID, J1939_CAN_MASK,
 			      j1939_can_recv, priv, "j1939", NULL);
 	if (ret < 0)
 		goto fail_can;
@@ -288,8 +288,8 @@ void j1939_netdev_stop(struct net_device *netdev)
 	can_ml_priv->j1939_priv = NULL;
 	mutex_unlock(&j1939_netdev_lock);
 
-	can_rx_unregister(netdev, J1939_CAN_ID, J1939_CAN_MASK,
-			j1939_can_recv, priv);
+	can_rx_unregister(&init_net, netdev, J1939_CAN_ID, J1939_CAN_MASK,
+			  j1939_can_recv, priv);
 
 	/* remove pending transport protocol sessions */
 	j1939tp_rmdev_notifier(netdev);
-- 
1.9.1


From c48b1622a9d229990670fb9b2ad638524fe05aaf Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sat, 3 Jun 2017 20:12:57 +0200
Subject: [PATCH 019/113] j1939: adopt renaming of "struct dev_rcv_lists" to
 "struct can_dev_rcv_lists"

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 2 +-
 net/can/j1939/main.c       | 4 ++--
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 4b684a8..f08e1bc 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -259,7 +259,7 @@ extern struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv,
 
 static inline struct j1939_priv *dev_j1939_priv(struct net_device *dev)
 {
-	struct dev_rcv_lists *can_ml_priv;
+	struct can_dev_rcv_lists *can_ml_priv;
 	struct j1939_priv *priv;
 
 	BUG_ON(!dev);
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 981d5a5..bf6adec 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -218,7 +218,7 @@ int j1939_netdev_start(struct net_device *netdev)
 {
 	int ret;
 	struct j1939_priv *priv;
-	struct dev_rcv_lists *can_ml_priv;
+	struct can_dev_rcv_lists *can_ml_priv;
 
 	BUG_ON(!netdev);
 	if (netdev->type != ARPHRD_CAN)
@@ -267,7 +267,7 @@ int j1939_netdev_start(struct net_device *netdev)
 
 void j1939_netdev_stop(struct net_device *netdev)
 {
-	struct dev_rcv_lists *can_ml_priv;
+	struct can_dev_rcv_lists *can_ml_priv;
 	struct j1939_priv *priv;
 
 	BUG_ON(!netdev);
-- 
1.9.1


From bc193adca73411014be488c8407b6f3cdd2d0cb4 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 6 Sep 2016 13:02:35 +0200
Subject: [PATCH 020/113] j1939: MAINTAINERS: update files

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 MAINTAINERS | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/MAINTAINERS b/MAINTAINERS
index 2b0045d..2872b2f 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -3101,12 +3101,12 @@ F:	include/uapi/linux/can/raw.h
 F:	include/uapi/linux/can/gw.h
 
 CAN-J1939 NETWORK LAYER
-M:	Kurt Van Dijck <kurt.van.dijck@eia.be>
-L:	socketcan-core@lists.berlios.de
-L:	netdev@vger.kernel.org
+M:	Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
+L:	linux-can@vger.kernel.org
 S:	Maintained
+F:	Documentation/networking/j1939.txt
 F:	net/can/j1939/
-F:	include/linux/can/j1939.h
+F:	include/uapi/linux/can/j1939.h
 
 CAPABILITIES
 M:	Serge Hallyn <serge@hallyn.com>
-- 
1.9.1


From 83f3005559a2004af426af8e9d075651e6b23197 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 6 Sep 2016 13:02:22 +0200
Subject: [PATCH 021/113] j1939: fix typos

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 Documentation/networking/j1939.txt | 6 +++---
 net/can/j1939/address-claim.c      | 2 +-
 net/can/j1939/j1939-priv.h         | 2 +-
 3 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/Documentation/networking/j1939.txt b/Documentation/networking/j1939.txt
index a9d47f6..fbf0d8a 100644
--- a/Documentation/networking/j1939.txt
+++ b/Documentation/networking/j1939.txt
@@ -139,7 +139,7 @@ This file contains
   set elsewhere.
 
   Regarding PGN mapping to 29-bit CAN identifier, the Destination Address
-  shall be get/set from/to the apropriate bits of the identifier by the kernel.
+  shall be get/set from/to the appropriate bits of the identifier by the kernel.
 
 
 3.2 addressing
@@ -158,7 +158,7 @@ This file contains
   reception.
 
   Mixed mode packets (from a static to a dynamic address or vice versa) are
-  allowed. The BSD sockets define seperate API calls for getting/setting the
+  allowed. The BSD sockets define separate API calls for getting/setting the
   local & remote address and are applicable for J1939 sockets.
 
 
@@ -338,7 +338,7 @@ This file contains
 
   Afterwards do a write(2) with data set to the NAME (Little Endian). If the
   NAME provided, does not match the j1939.name provided to bind(2), EPROTO
-  will be returned. One might use sendto(2) also to send the Addres Claim. In
+  will be returned. One might use sendto(2) also to send the Address Claim. In
   that case, the j1939.addr member must be set to the broadcast address (255)
   and the j1939.pgn must be set to 0x0ee00. If This combination is not given,
   EPROTO is returned.
diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
index 36d995b..58223d5 100644
--- a/net/can/j1939/address-claim.c
+++ b/net/can/j1939/address-claim.c
@@ -79,7 +79,7 @@ int j1939_fixup_address_claim(struct sk_buff *skb)
 		struct j1939_ecu *ecu;
 
 		ret = j1939_verify_outgoing_address_claim(skb);
-		/* return both when failure & when successfull */
+		/* return both when failure & when successful */
 		if (ret < 0)
 			return ret;
 		ecu = j1939_ecu_find_by_name(skcb->srcname,
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index f08e1bc..1180871 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -60,7 +60,7 @@ struct j1939_priv {
 	struct list_head ecus; /*
 	 * local list entry in priv
 	 * These allow irq (& softirq) context lookups on j1939 devices
-	 * This approach (seperate lists) is done as the other 2 alternatives
+	 * This approach (separate lists) is done as the other 2 alternatives
 	 * are not easier or even wrong
 	 * 1) using the pure kobject methods involves mutexes, which are not
 	 *    allowed in irq context.
-- 
1.9.1


From 491779342544adf9175c2c29d6ac742eb37284ce Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 17:25:10 +0200
Subject: [PATCH 022/113] j1939: adjust guard macros in userspace headers

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 include/uapi/linux/can/j1939.h | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/include/uapi/linux/can/j1939.h b/include/uapi/linux/can/j1939.h
index 7ff419e..c2363a1 100644
--- a/include/uapi/linux/can/j1939.h
+++ b/include/uapi/linux/can/j1939.h
@@ -8,8 +8,8 @@
  * published by the Free Software Foundation.
  */
 
-#ifndef _J1939_H_
-#define _J1939_H_
+#ifndef _UAPI_CAN_J1939_H_
+#define _UAPI_CAN_J1939_H_
 
 #include <linux/types.h>
 #include <linux/socket.h>
@@ -96,4 +96,4 @@ enum {
 	IFA_J1939_MAX,
 };
 
-#endif /* _J1939_H_ */
+#endif /* !_UAPI_CAN_J1939_H_ */
-- 
1.9.1


From eea4b197837fed95156c5232bca3e81de55a98aa Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 17:35:16 +0200
Subject: [PATCH 023/113] j1939: only declare one member per line in struct

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 3 ++-
 net/can/j1939/socket.c     | 3 ++-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 1180871..ecea708 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -215,7 +215,8 @@ struct j1939_sk_buff_cb {
 	 * Flags for quick lookups during skb processing
 	 * These are set in the receive path only
 	 */
-	int srcflags, dstflags;
+	int srcflags;
+	int dstflags;
 	#define ECU_LOCAL	1
 	/* for tx, MSG_SYN will be used to sync on sockets */
 	int msg_flags;
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 574c07e..a5a92ba 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -44,7 +44,8 @@ struct j1939_sock {
 	int ifindex_started; /* ifindex of netdev */
 
 	struct {
-		name_t src, dst;
+		name_t src;
+		name_t dst;
 		pgn_t pgn;
 
 		uint8_t sa, da;
-- 
1.9.1


From 45d06380773cd989febd239c49a840ab7d89ae89 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 6 Sep 2016 13:08:26 +0200
Subject: [PATCH 024/113] j1939: convert comments to netdev style

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 include/uapi/linux/can.h       |  3 +-
 include/uapi/linux/can/j1939.h | 18 ++++--------
 net/can/j1939/address-claim.c  |  7 ++---
 net/can/j1939/bus.c            |  7 ++---
 net/can/j1939/j1939-priv.h     | 45 +++++++++++++----------------
 net/can/j1939/main.c           | 17 ++++-------
 net/can/j1939/socket.c         | 27 +++++++-----------
 net/can/j1939/transport.c      | 64 ++++++++++++++++--------------------------
 8 files changed, 71 insertions(+), 117 deletions(-)

diff --git a/include/uapi/linux/can.h b/include/uapi/linux/can.h
index 2630d81..8d1298a 100644
--- a/include/uapi/linux/can.h
+++ b/include/uapi/linux/can.h
@@ -178,8 +178,7 @@ struct sockaddr_can {
 		struct {
 			/* 8 byte name when using dynamic addressing */
 			__u64 name;
-			/*
-			 * pgn:
+			/* pgn:
 			 * 8bit: PS in PDU2 case, else 0
 			 * 8bit: PF
 			 * 1bit: DP
diff --git a/include/uapi/linux/can/j1939.h b/include/uapi/linux/can/j1939.h
index c2363a1..9ca1737 100644
--- a/include/uapi/linux/can/j1939.h
+++ b/include/uapi/linux/can/j1939.h
@@ -19,8 +19,8 @@
 #define J1939_NO_ADDR	0xff
 #define J1939_NO_NAME	0
 #define J1939_NO_PGN	0x40000
-/*
- * J1939 Parameter Group Number
+
+/* J1939 Parameter Group Number
  *
  * bit 0-7	: PDU Specific (PS)
  * bit 8-15	: PDU Format (PF)
@@ -30,16 +30,14 @@
  */
 typedef __u32 pgn_t;
 
-/*
- * J1939 Priority
+/* J1939 Priority
  *
  * bit 0-2	: Priority (P)
  * bit 3-7	: set to zero
  */
 typedef __u8 priority_t;
 
-/*
- * J1939 NAME
+/* J1939 NAME
  *
  * bit 0-20	: Identity Number
  * bit 21-31	: Manufacturer Code
@@ -54,9 +52,7 @@
  */
 typedef __u64 name_t;
 
-/*
- * J1939 socket options
- */
+/* J1939 socket options */
 #define SOL_CAN_J1939 (SOL_CAN_BASE + CAN_J1939)
 enum {
 	SO_J1939_FILTER = 1,	/* set filters */
@@ -80,9 +76,7 @@ struct j1939_filter {
 	pgn_t pgn_mask;
 };
 
-/*
- * RTNETLINK
- */
+/* RTNETLINK */
 enum {
 	IFLA_J1939_UNSPEC,
 	IFLA_J1939_ENABLE,
diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
index 58223d5..07f0f0a 100644
--- a/net/can/j1939/address-claim.c
+++ b/net/can/j1939/address-claim.c
@@ -9,8 +9,7 @@
  * as published by the Free Software Foundation
  */
 
-/*
- * J1939 Address Claiming.
+/* J1939 Address Claiming.
  * Address Claiming in the kernel
  * - keeps track of the AC states of ECU's,
  * - resolves NAME<=>SA taking into account the AC states of ECU's.
@@ -189,9 +188,7 @@ void j1939_recv_address_claim(struct sk_buff *skb, struct j1939_priv *priv)
 	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
 	struct j1939_ecu *ecu;
 
-	/*
-	 * network mgmt
-	 */
+	/* network mgmt */
 	if (skcb->pgn == PGN_ADDRESS_CLAIMED)
 		j1939_process_address_claim(skb);
 	else if (j1939_address_is_unicast(skcb->srcaddr)) {
diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index e7b91c5..0f45547 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -9,8 +9,7 @@
  * as published by the Free Software Foundation
  */
 
-/*
- * j1939-bus.c - bus for j1939 remote devices
+/* bus for j1939 remote devices
  * Since rtnetlink, no real bus is used.
  */
 
@@ -29,9 +28,7 @@
 	pr_alert("j1939-%i,%016llx,%02x: " fmt, (ecu)->priv->ifindex, \
 		(ecu)->name, (ecu)->sa, ##__VA_ARGS__)
 
-/*
- * ECU device interface
- */
+/* ECU device interface */
 static enum hrtimer_restart j1939_ecu_timer_handler(struct hrtimer *hrtimer)
 {
 	struct j1939_ecu *ecu =
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index ecea708..6860c7d 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -31,16 +31,15 @@
 #define PGN_MAX			0x3ffff
 
 #define SA_MAX_UNICAST	0xfd
-/*
- * j1939 devices
- */
+
+/* j1939 devices */
 struct j1939_ecu {
 	struct list_head list;
 	ktime_t rxtime;
 	name_t name;
 	uint8_t sa;
-	/*
-	 * atomic flag, set by ac_timer
+
+	/* atomic flag, set by ac_timer
 	 * cleared/processed by segment's tasklet
 	 * indicates that this ecu successfully claimed @sa as its address
 	 * By communicating this from the ac_timer event to segments tasklet,
@@ -57,8 +56,8 @@ struct j1939_ecu {
 #define to_j1939_ecu(x) container_of((x), struct j1939_ecu, dev)
 
 struct j1939_priv {
-	struct list_head ecus; /*
-	 * local list entry in priv
+	struct list_head ecus;
+	/* local list entry in priv
 	 * These allow irq (& softirq) context lookups on j1939 devices
 	 * This approach (separate lists) is done as the other 2 alternatives
 	 * are not easier or even wrong
@@ -68,9 +67,10 @@ struct j1939_priv {
 	 *    code
 	 * usage:
 	 */
-	rwlock_t lock; /*
-	 * segments need a lock to protect the above list
-	 */
+
+	/* segments need a lock to protect the above list */
+	rwlock_t lock;
+
 	int ifindex;
 	struct net_device *netdev;
 	struct addr_ent {
@@ -80,21 +80,20 @@ struct j1939_priv {
 		int nusers;
 	} ents[256];
 
-	/*
-	 * tasklet to process ecu address claimed events.
+	/* tasklet to process ecu address claimed events.
 	 * These events raise in hardirq context. Signalling the event
 	 * and scheduling this tasklet successfully moves the
 	 * event to softirq context
 	 */
 	struct tasklet_struct ac_task;
-	/*
-	 * list of 256 ecu ptrs, that cache the claimed addresses.
+
+	/* list of 256 ecu ptrs, that cache the claimed addresses.
 	 * also protected by the above lock
 	 * don't use directly, use j1939_ecu_set_address() instead
 	 */
 	struct kref kref;
-	/*
-	 * ref counter that hold the number of active listeners.
+
+	/* ref counter that hold the number of active listeners.
 	 * This number itself is protected with a mutex
 	 */
 	int nusers;
@@ -118,8 +117,7 @@ static inline void get_j1939_priv(struct j1939_priv *dut)
 extern void j1939_name_local_get(struct j1939_priv *priv, uint64_t name);
 extern void j1939_name_local_put(struct j1939_priv *priv, uint64_t name);
 
-/*
- * conversion function between (struct sock | struct sk_buff)->sk_priority
+/* conversion function between (struct sock | struct sk_buff)->sk_priority
  * from linux and j1939 priority field
  */
 static inline int j1939_prio(int sk_priority)
@@ -211,8 +209,7 @@ struct j1939_sk_buff_cb {
 	name_t srcname;
 	name_t dstname;
 
-	/*
-	 * Flags for quick lookups during skb processing
+	/* Flags for quick lookups during skb processing
 	 * These are set in the receive path only
 	 */
 	int srcflags;
@@ -245,8 +242,8 @@ static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
 extern void j1939_recv_address_claim(struct sk_buff *, struct j1939_priv *priv);
 
 /* network management */
-/*
- * j1939_ecu_get_register
+
+/* j1939_ecu_get_register
  * 'create' & 'register' & 'get' new ecu
  * when a matching ecu already exists, then that is returned
  */
@@ -291,9 +288,7 @@ static inline struct j1939_priv *j1939_priv_find(int ifindex)
 extern void j1939sk_netdev_event(int ifindex, int error_code);
 extern int j1939tp_rmdev_notifier(struct net_device *netdev);
 
-/*
- * decrement pending skb for a j1939 socket
- */
+/* decrement pending skb for a j1939 socket */
 extern void j1939_sock_pending_del(struct sock *sk);
 
 /* seperate module-init/modules-exit's */
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index bf6adec..f0c10c3 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -10,9 +10,7 @@
  * as published by the Free Software Foundation
  */
 
-/*
- * Core of can-j1939 that links j1939 to CAN.
- */
+/* Core of can-j1939 that links j1939 to CAN. */
 
 #include <linux/version.h>
 #include <linux/mutex.h>
@@ -69,8 +67,8 @@ static void j1939_can_recv(struct sk_buff *iskb, void *data)
 	 * j1939 may not touch the incoming skb in such way
 	 */
 	skb = skb_clone(iskb, GFP_ATOMIC);
-	/*
-	 * get a pointer to the header of the skb
+
+	/* get a pointer to the header of the skb
 	 * the skb payload (pointer) is moved, so that the next skb_data
 	 * returns the actual payload
 	 */
@@ -183,9 +181,8 @@ int j1939_send(struct sk_buff *skb)
 }
 EXPORT_SYMBOL_GPL(j1939_send);
 
-/*
- * iterate over ECU's,
- * and register flagged ecu's on their claimed SA
+/* iterate over ECUs,
+ * and register flagged ECUs on their claimed SA
  */
 static void j1939_priv_ac_task(unsigned long val)
 {
@@ -299,9 +296,7 @@ void j1939_netdev_stop(struct net_device *netdev)
 	dev_put(netdev);
 }
 
-/*
- * device interface
- */
+/* device interface */
 static void on_put_j1939_priv(struct kref *kref)
 {
 	struct j1939_priv *priv = container_of(kref, struct j1939_priv, kref);
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index a5a92ba..1aefd0d 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -25,9 +25,7 @@
 
 #define J1939_MIN_NAMELEN required_size(can_addr.j1939, struct sockaddr_can)
 
-/*
- * list of sockets
- */
+/* list of sockets */
 static struct list_head j1939_socks = LIST_HEAD_INIT(j1939_socks);
 static DEFINE_SPINLOCK(j1939_socks_lock);
 
@@ -54,8 +52,7 @@ struct j1939_sock {
 	struct j1939_filter *filters;
 	int nfilters;
 
-	/*
-	 * j1939 may emit equal PGN (!= equal CAN-id's) out of order
+	/* j1939 may emit equal PGN (!= equal CAN-id's) out of order
 	 * when transport protocol comes in.
 	 * To allow emitting in order, keep a 'pending' nr. of packets
 	 */
@@ -120,8 +117,8 @@ static inline int packet_match(const struct j1939_sk_buff_cb *skcb,
 	if (!nfilter)
 		/* receive all when no filters are assigned */
 		return 1;
-	/*
-	 * Filters relying on the addr for static addressing _should_ get
+
+	/* Filters relying on the addr for static addressing _should_ get
 	 * packets from dynamic addressed ECU's too if they match their SA.
 	 * Sockets using dynamic addressing in their filters should not set it.
 	 */
@@ -154,8 +151,7 @@ static void j1939sk_recv_skb(struct sk_buff *oskb, struct j1939_sock *jsk)
 			/* reject message for other destinations */
 			if (skcb->dstname &&
 				(skcb->dstname != jsk->addr.src))
-				/*
-				 * the msg is not destined for the name
+				/* the msg is not destined for the name
 				 * that the socket is bound to
 				 */
 				return;
@@ -163,8 +159,7 @@ static void j1939sk_recv_skb(struct sk_buff *oskb, struct j1939_sock *jsk)
 			/* reject messages for other destination addresses */
 			if (j1939_address_is_unicast(skcb->dstaddr) &&
 				(skcb->dstaddr != jsk->addr.sa))
-				/*
-				 * the msg is not destined for the name
+				/* the msg is not destined for the name
 				 * that the socket is bound to
 				 */
 				return;
@@ -221,9 +216,7 @@ static int j1939sk_init(struct sock *sk)
 	return 0;
 }
 
-/*
- * helper: return <0 for error, >0 for error to notify
- */
+/* helper: return <0 for error, >0 for error to notify */
 static int j1939_ifindex_start(int ifindex)
 {
 	int ret;
@@ -327,7 +320,8 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 fail_locked:
 	if (!jsk->sk.sk_bound_dev_if && jsk->ifindex_started) {
 		/* started j1939 on this netdev during this call,
-		 * so we revert that */
+		 * so we revert that
+		 */
 		j1939_ifindex_stop(jsk->ifindex_started);
 		jsk->ifindex_started = 0;
 	}
@@ -584,8 +578,7 @@ static int j1939sk_getsockopt(struct socket *sock, int level, int optname,
 		goto no_copy;
 	}
 
-	/*
-	 * copy to user, based on 'len' & 'val'
+	/* copy to user, based on 'len' & 'val'
 	 * but most sockopt's are 'int' properties, and have 'len' & 'val'
 	 * left unchanged, but instead modified 'tmp'
 	 */
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 688e965..05ae976 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -67,16 +67,15 @@ struct session {
 	atomic_t refs;
 	spinlock_t lock;
 
-	struct j1939_sk_buff_cb *cb; /*
-	 * ifindex, src, dst, pgn define the session block
+	/* ifindex, src, dst, pgn define the session block
 	 * the are _never_ modified after insertion in the list
 	 * this decreases locking problems a _lot_
 	 */
+	struct j1939_sk_buff_cb *cb;
 	struct sk_buff *skb;
 	int skb_iif;
 
-	/*
-	 * all tx related stuff (last_txcmd, pkt.tx)
+	/* all tx related stuff (last_txcmd, pkt.tx)
 	 * is protected (modified only) with the txtask tasklet
 	 * 'total' & 'block' are never changed,
 	 * last_cmd, last & block are protected by ->lock
@@ -87,8 +86,7 @@ struct session {
 	uint8_t transmission;
 	uint8_t extd;
 	struct {
-		/*
-		 * these do not require 16 bit, they should fit in uint8_t
+		/* these do not require 16 bit, they should fit in u8
 		 * but putting in int makes it easier to deal with
 		 */
 		unsigned int total, done, last, tx;
@@ -96,7 +94,8 @@ struct session {
 		unsigned int dpo; /* for ETP */
 	} pkt;
 	struct hrtimer txtimer, rxtimer;
-	/* tasklets for execution of tx/rx timer hander in softirq */
+
+	/* tasklets for execution of tx/rx timer handler in softirq */
 	struct tasklet_struct txtask, rxtask;
 };
 
@@ -212,8 +211,7 @@ static inline void sessionlist_unlock(void)
 	spin_unlock_bh(&tp_lock);
 }
 
-/*
- * see if we are receiver
+/* see if we are receiver
  * returns 0 for broadcasts, although we will receive them
  */
 static inline int j1939tp_im_receiver(struct sk_buff *skb)
@@ -269,8 +267,7 @@ static inline unsigned int j1939etp_ctl_to_size(const uint8_t *dat)
 		(dat[2] << 8) | (dat[1] << 0);
 }
 
-/*
- * find existing session:
+/* find existing session:
  * reverse: swap cb's src & dst
  * there is no problem with matching broadcasts, since
  * broadcasts (no dst, no da) would never call this
@@ -474,11 +471,9 @@ static inline void j1939tp_set_rxtimeout(struct session *session, int msec)
 			HRTIMER_MODE_REL);
 }
 
-/*
- * session completion functions
- */
-/*
- * j1939session_drop
+/* session completion functions */
+
+/* j1939session_drop
  * removes a session from open session list
  */
 static inline void j1939session_drop(struct session *session)
@@ -533,9 +528,7 @@ static void j1939tp_rxtask(unsigned long val)
 	put_session(session);
 }
 
-/*
- * receive packet functions
- */
+/* receive packet functions */
 static void _j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
 {
 	struct session *session;
@@ -579,16 +572,13 @@ static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd)
 	if (!session)
 		return;
 	if (session->transmission && !session->last_txcmd) {
-		/*
-		 * empty block:
+		/* empty block:
 		 * do not drop session when a transmit session did not
 		 * start yet
 		 */
 	} else if (session->cb->pgn == pgn)
 		j1939session_drop(session);
-	/* another PGN had a bad message */
-	/*
-	 * TODO: maybe cancel current connection
+	/* TODO: maybe cancel current connection
 	 * as another pgn was communicated
 	 */
 	put_session(session); /* ~j1939tp_find */
@@ -617,8 +607,7 @@ static void j1939xtp_rx_eof(struct sk_buff *skb, int extd)
 	pgn = j1939xtp_ctl_to_pgn(skb->data);
 	session = j1939tp_find(sessionq(extd), skb, 1);
 	if (!session)
-		/*
-		 * strange, we had EOF on closed connection
+		/* strange, we had EOF on closed connection
 		 * do nothing, as EOF closes the connection anyway
 		 */
 		return;
@@ -706,8 +695,8 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 			skb->skb_iif, cb->srcaddr);
 		return;
 	}
-	/*
-	 * TODO: abort RTS when a similar
+
+	/* TODO: abort RTS when a similar
 	 * TP is pending in the other direction
 	 */
 	session = j1939tp_find(sessionq(extd), skb, 0);
@@ -732,8 +721,7 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 		return;
 	}
 	if (session) {
-		/*
-		 * make sure 'sa' & 'da' are correct !
+		/* make sure 'sa' & 'da' are correct !
 		 * They may be 'not filled in yet' for sending
 		 * skb's, since they did not pass the Address Claim ever.
 		 */
@@ -791,8 +779,8 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 		if (extd || (tp_cmd_bam != dat[0]))
 			j1939session_schedule_txnow(session);
 	}
-	/*
-	 * as soon as it's inserted, things can go fast
+
+	/* as soon as it's inserted, things can go fast
 	 * protect against a long delay
 	 * between spin_unlock & next statement
 	 * so, only release here, at the end
@@ -916,9 +904,7 @@ static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
 	put_session(session); /* ~j1939tp_find */
 }
 
-/*
- * transmit function
- */
+/* transmit function */
 static int j1939tp_txnext(struct session *session)
 {
 	uint8_t dat[8];
@@ -1127,9 +1113,8 @@ static int j1939session_insert(struct session *session)
 	sessionlist_unlock();
 	return pending ? 0 : 1;
 }
-/*
- * j1939 main intf
- */
+
+/* j1939 main intf */
 int j1939_send_transport(struct sk_buff *skb)
 {
 	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
@@ -1199,8 +1184,7 @@ int j1939_send_transport(struct sk_buff *skb)
 	list_del_init(&session->list);
 	sessionlist_unlock();
 failed:
-	/*
-	 * hide the skb from j1939session_drop, as it would
+	/* hide the skb from j1939session_drop, as it would
 	 * kfree_skb, but our caller will kfree_skb(skb) too.
 	 */
 	session->skb = NULL;
-- 
1.9.1


From a46111023795e3a88f94d339e9ec03191d880da0 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 09:55:30 +0200
Subject: [PATCH 025/113] j1939: convert from uintX_t to uX

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/bus.c        |  6 +++---
 net/can/j1939/j1939-priv.h | 28 ++++++++++++++--------------
 net/can/j1939/socket.c     |  2 +-
 net/can/j1939/transport.c  | 46 ++++++++++++++++++++++++----------------------
 4 files changed, 42 insertions(+), 40 deletions(-)

diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index 0f45547..27a55a4 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -114,7 +114,7 @@ struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex)
 	return ecu;
 }
 
-int j1939_name_to_sa(uint64_t name, int ifindex)
+int j1939_name_to_sa(u64 name, int ifindex)
 {
 	struct j1939_ecu *ecu;
 	struct j1939_priv *priv;
@@ -201,7 +201,7 @@ void j1939_addr_local_put(struct j1939_priv *priv, int sa)
 	write_unlock_bh(&priv->lock);
 }
 
-void j1939_name_local_get(struct j1939_priv *priv, uint64_t name)
+void j1939_name_local_get(struct j1939_priv *priv, u64 name)
 {
 	struct j1939_ecu *ecu;
 
@@ -219,7 +219,7 @@ void j1939_name_local_get(struct j1939_priv *priv, uint64_t name)
 	write_unlock_bh(&priv->lock);
 }
 
-void j1939_name_local_put(struct j1939_priv *priv, uint64_t name)
+void j1939_name_local_put(struct j1939_priv *priv, u64 name)
 {
 	struct j1939_ecu *ecu;
 
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 6860c7d..19f832a 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -37,7 +37,7 @@ struct j1939_ecu {
 	struct list_head list;
 	ktime_t rxtime;
 	name_t name;
-	uint8_t sa;
+	u8 sa;
 
 	/* atomic flag, set by ac_timer
 	 * cleared/processed by segment's tasklet
@@ -112,10 +112,10 @@ static inline void get_j1939_priv(struct j1939_priv *dut)
 }
 
 /* keep the cache of what is local */
-extern void j1939_addr_local_get(struct j1939_priv *priv, int sa);
-extern void j1939_addr_local_put(struct j1939_priv *priv, int sa);
-extern void j1939_name_local_get(struct j1939_priv *priv, uint64_t name);
-extern void j1939_name_local_put(struct j1939_priv *priv, uint64_t name);
+void j1939_addr_local_get(struct j1939_priv *priv, int sa);
+void j1939_addr_local_put(struct j1939_priv *priv, int sa);
+void j1939_name_local_get(struct j1939_priv *priv, u64 name);
+void j1939_name_local_put(struct j1939_priv *priv, u64 name);
 
 /* conversion function between (struct sock | struct sk_buff)->sk_priority
  * from linux and j1939 priority field
@@ -134,12 +134,12 @@ static inline int j1939_to_sk_priority(int j1939_prio)
 	return 7 - j1939_prio;
 }
 
-static inline int j1939_address_is_valid(uint8_t sa)
+static inline int j1939_address_is_valid(u8 sa)
 {
 	return sa != J1939_NO_ADDR;
 }
 
-static inline int j1939_address_is_unicast(uint8_t sa)
+static inline int j1939_address_is_unicast(u8 sa)
 {
 	return sa <= SA_MAX_UNICAST;
 }
@@ -175,12 +175,12 @@ static inline void j1939_ecu_remove_sa(struct j1939_ecu *ecu)
 	write_unlock_bh(&ecu->priv->lock);
 }
 
-extern int j1939_name_to_sa(uint64_t name, int ifindex);
-extern struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex);
-extern struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex);
+int j1939_name_to_sa(u64 name, int ifindex);
+struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex);
+struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex);
 /* find_by_name, with kref & read_lock taken */
-extern struct j1939_ecu *j1939_ecu_find_priv_default_tx(
-		int ifindex, name_t *pname, uint8_t *paddr);
+struct j1939_ecu *j1939_ecu_find_priv_default_tx(int ifindex, name_t *pname,
+						 u8 *paddr);
 
 extern struct proc_dir_entry *j1939_procdir;
 extern const char j1939_procname[];
@@ -204,8 +204,8 @@ extern struct j1939_ecu *j1939_ecu_find_priv_default_tx(
 struct j1939_sk_buff_cb {
 	pgn_t pgn;
 	priority_t priority;
-	uint8_t srcaddr;
-	uint8_t dstaddr;
+	u8 srcaddr;
+	u8 dstaddr;
 	name_t srcname;
 	name_t dstname;
 
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 1aefd0d..f8d3365 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -46,7 +46,7 @@ struct j1939_sock {
 		name_t dst;
 		pgn_t pgn;
 
-		uint8_t sa, da;
+		u8 sa, da;
 	} addr;
 
 	struct j1939_filter *filters;
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 05ae976..e3d4c40 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -82,9 +82,9 @@ struct session {
 	 * this means that the tx may run after cts is received that should
 	 * have stopped tx, but this time discrepancy is never avoided anyhow
 	 */
-	uint8_t last_cmd, last_txcmd;
-	uint8_t transmission;
-	uint8_t extd;
+	u8 last_cmd, last_txcmd;
+	u8 transmission;
+	u8 extd;
 	struct {
 		/* these do not require 16 bit, they should fit in u8
 		 * but putting in int makes it easier to deal with
@@ -243,7 +243,7 @@ static int j1939tp_im_involved_anydir(struct sk_buff *skb)
 }
 
 /* extract pgn from flow-ctl message */
-static inline pgn_t j1939xtp_ctl_to_pgn(const uint8_t *dat)
+static inline pgn_t j1939xtp_ctl_to_pgn(const u8 *dat)
 {
 	pgn_t pgn;
 
@@ -253,15 +253,17 @@ static inline pgn_t j1939xtp_ctl_to_pgn(const uint8_t *dat)
 	return pgn;
 }
 
-static inline unsigned int j1939tp_ctl_to_size(const uint8_t *dat)
+static inline unsigned int j1939tp_ctl_to_size(const u8 *dat)
 {
 	return (dat[2] << 8) + (dat[1] << 0);
 }
-static inline unsigned int j1939etp_ctl_to_packet(const uint8_t *dat)
+
+static inline unsigned int j1939etp_ctl_to_packet(const u8 *dat)
 {
 	return (dat[4] << 16) | (dat[3] << 8) | (dat[2] << 0);
 }
-static inline unsigned int j1939etp_ctl_to_size(const uint8_t *dat)
+
+static inline unsigned int j1939etp_ctl_to_size(const u8 *dat)
 {
 	return (dat[4] << 24) | (dat[3] << 16) |
 		(dat[2] << 8) | (dat[1] << 0);
@@ -333,7 +335,7 @@ static struct session *j1939tp_find(struct list_head *root,
 static void j1939_skbcb_swap(struct j1939_sk_buff_cb *cb)
 {
 	name_t name;
-	uint8_t addr;
+	u8 addr;
 	int flags;
 
 	name = cb->dstname;
@@ -350,11 +352,11 @@ static void j1939_skbcb_swap(struct j1939_sk_buff_cb *cb)
 }
 /* TP transmit packet functions */
 static int j1939tp_tx_dat(struct sk_buff *related, int extd,
-		const uint8_t *dat, int len)
+			  const u8 *dat, int len)
 {
 	struct sk_buff *skb;
 	struct j1939_sk_buff_cb *skb_cb;
-	uint8_t *skdat;
+	u8 *skdat;
 
 	skb = alloc_skb(sizeof(struct can_frame) + sizeof(struct can_skb_priv),
 			GFP_ATOMIC);
@@ -384,11 +386,11 @@ static int j1939tp_tx_dat(struct sk_buff *related, int extd,
 }
 
 static int j1939xtp_do_tx_ctl(struct sk_buff *related, int extd,
-		int swap_src_dst, pgn_t pgn, const uint8_t dat[5])
+			      int swap_src_dst, pgn_t pgn, const u8 dat[5])
 {
 	struct sk_buff *skb;
 	struct j1939_sk_buff_cb *skb_cb;
-	uint8_t *skdat;
+	u8 *skdat;
 
 	if (!j1939tp_im_involved(related, swap_src_dst))
 		return 0;
@@ -425,7 +427,7 @@ static int j1939xtp_do_tx_ctl(struct sk_buff *related, int extd,
 }
 
 static inline int j1939tp_tx_ctl(struct session *session,
-		int swap_src_dst, const uint8_t dat[8])
+				 int swap_src_dst, const u8 dat[8])
 {
 	return j1939xtp_do_tx_ctl(session->skb, session->extd, swap_src_dst,
 			session->cb->pgn, dat);
@@ -434,7 +436,7 @@ static inline int j1939tp_tx_ctl(struct session *session,
 static int j1939xtp_tx_abort(struct sk_buff *related, int extd,
 		int swap_src_dst, int err, pgn_t pgn)
 {
-	uint8_t dat[5];
+	u8 dat[5];
 
 	if (!j1939tp_im_involved(related, swap_src_dst))
 		return 0;
@@ -627,7 +629,7 @@ static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
 	struct session *session;
 	pgn_t pgn;
 	unsigned int pkt;
-	const uint8_t *dat;
+	const u8 *dat;
 
 	dat = skb->data;
 	pgn = j1939xtp_ctl_to_pgn(skb->data);
@@ -684,7 +686,7 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
 	struct session *session;
 	int len;
-	const uint8_t *dat;
+	const u8 *dat;
 	pgn_t pgn;
 
 	dat = skb->data;
@@ -793,7 +795,7 @@ static void j1939xtp_rx_dpo(struct sk_buff *skb, int extd)
 {
 	struct session *session;
 	pgn_t pgn;
-	const uint8_t *dat = skb->data;
+	const u8 *dat = skb->data;
 
 	pgn = j1939xtp_ctl_to_pgn(dat);
 	session = j1939tp_find(sessionq(extd), skb, 0);
@@ -819,8 +821,8 @@ static void j1939xtp_rx_dpo(struct sk_buff *skb, int extd)
 static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
 {
 	struct session *session;
-	const uint8_t *dat;
-	uint8_t *tpdat;
+	const u8 *dat;
+	u8 *tpdat;
 	int offset;
 	int nbytes;
 	int final;
@@ -907,8 +909,8 @@ static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
 /* transmit function */
 static int j1939tp_txnext(struct session *session)
 {
-	uint8_t dat[8];
-	const uint8_t *tpdat;
+	u8 dat[8];
+	const u8 *tpdat;
 	int ret, offset, pkt_done, pkt_end;
 	unsigned int pkt, len, pdelay;
 
@@ -1195,7 +1197,7 @@ int j1939_send_transport(struct sk_buff *skb)
 int j1939_recv_transport(struct sk_buff *skb)
 {
 	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
-	const uint8_t *dat;
+	const u8 *dat;
 
 	switch (cb->pgn) {
 	case etp_pgn_dat:
-- 
1.9.1


From bc25ff5360d330215e0496acd9ee33bde52ca568 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 17:26:31 +0200
Subject: [PATCH 026/113] j1939: remove extern from declarations

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 34 +++++++++++++++++-----------------
 1 file changed, 17 insertions(+), 17 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 19f832a..8dcb269 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -100,8 +100,8 @@ struct j1939_priv {
 };
 #define to_j1939_priv(x) container_of((x), struct j1939_priv, dev)
 
-extern void put_j1939_ecu(struct j1939_ecu *ecu);
-extern void put_j1939_priv(struct j1939_priv *segment);
+void put_j1939_ecu(struct j1939_ecu *ecu);
+void put_j1939_priv(struct j1939_priv *segment);
 static inline void get_j1939_ecu(struct j1939_ecu *dut)
 {
 	kref_get(&dut->kref);
@@ -232,14 +232,14 @@ static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
 	return (!skcb->dstname && (skcb->dstaddr >= 0xff));
 }
 
-extern int j1939_send(struct sk_buff *);
-extern void j1939_recv(struct sk_buff *);
+int j1939_send(struct sk_buff *);
+void j1939_recv(struct sk_buff *);
 
 /* stack entries */
-extern int j1939_send_transport(struct sk_buff *);
-extern int j1939_recv_transport(struct sk_buff *);
-extern int j1939_fixup_address_claim(struct sk_buff *);
-extern void j1939_recv_address_claim(struct sk_buff *, struct j1939_priv *priv);
+int j1939_send_transport(struct sk_buff *);
+int j1939_recv_transport(struct sk_buff *);
+int j1939_fixup_address_claim(struct sk_buff *);
+void j1939_recv_address_claim(struct sk_buff *, struct j1939_priv *priv);
 
 /* network management */
 
@@ -250,10 +250,10 @@ static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
 extern struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv,
 		name_t name, int create_if_necessary);
 /* unregister must be called with lock held */
-extern void _j1939_ecu_unregister(struct j1939_ecu *);
+void _j1939_ecu_unregister(struct j1939_ecu *);
 
-extern int j1939_netdev_start(struct net_device *);
-extern void j1939_netdev_stop(struct net_device *);
+int j1939_netdev_start(struct net_device *);
+void j1939_netdev_stop(struct net_device *);
 
 static inline struct j1939_priv *dev_j1939_priv(struct net_device *dev)
 {
@@ -285,16 +285,16 @@ static inline struct j1939_priv *j1939_priv_find(int ifindex)
 }
 
 /* notify/alert all j1939 sockets bound to ifindex */
-extern void j1939sk_netdev_event(int ifindex, int error_code);
-extern int j1939tp_rmdev_notifier(struct net_device *netdev);
+void j1939sk_netdev_event(int ifindex, int error_code);
+int j1939tp_rmdev_notifier(struct net_device *netdev);
 
 /* decrement pending skb for a j1939 socket */
-extern void j1939_sock_pending_del(struct sock *sk);
+void j1939_sock_pending_del(struct sock *sk);
 
-/* seperate module-init/modules-exit's */
-extern __init int j1939tp_module_init(void);
+/* separate module-init/modules-exit's */
+__init int j1939tp_module_init(void);
 
-extern void j1939tp_module_exit(void);
+void j1939tp_module_exit(void);
 
 /* CAN protocol */
 extern const struct can_proto j1939_can_proto;
-- 
1.9.1


From 252b69d9321c1a98d8881a3a9fe062f3afb1ccf3 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 17:24:41 +0200
Subject: [PATCH 027/113] j1939: don't initialize static variables with 0

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/main.c      | 2 +-
 net/can/j1939/transport.c | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index f0c10c3..4842c16 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -41,7 +41,7 @@
 #define CAN_FTR	(sizeof(struct can_frame)-CAN_HDR-\
 		sizeof(((struct can_frame *)0)->data))
 
-static unsigned int padding = 0;
+static unsigned int padding;
 
 module_param_named(padding, padding, uint, 0644);
 
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index e3d4c40..60d2fea 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -50,7 +50,7 @@
 static unsigned int block = 255;
 static unsigned int max_packet_size = 1024*100;
 static unsigned int retry_ms = 20;
-static unsigned int packet_delay = 0;
+static unsigned int packet_delay;
 
 module_param_named(transport_burst_count, block, uint, 0644);
 module_param_named(transport_max_size, max_packet_size, uint, 0644);
-- 
1.9.1


From f87a9db0c9b2353c8c85c7a92b7b446f9ada506d Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 17:34:38 +0200
Subject: [PATCH 028/113] j1939: remove return at the end of void functions

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/transport.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 60d2fea..d0f32f6 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -561,7 +561,6 @@ static void j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
 	_j1939xtp_rx_bad_message(skb, extd);
 	/* restore skb */
 	j1939_skbcb_swap(cb);
-	return;
 }
 
 static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd)
@@ -597,7 +596,6 @@ static inline void j1939xtp_rx_abort(struct sk_buff *skb, int extd)
 	_j1939xtp_rx_abort(skb, extd);
 	/* restore skb */
 	j1939_skbcb_swap(cb);
-	return;
 }
 
 static void j1939xtp_rx_eof(struct sk_buff *skb, int extd)
@@ -788,7 +786,6 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 	 * so, only release here, at the end
 	 */
 	put_session(session); /* ~j1939tp_find */
-	return;
 }
 
 static void j1939xtp_rx_dpo(struct sk_buff *skb, int extd)
-- 
1.9.1


From c664341ff306e7f28979845f7fbed5d71fa0c774 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 17:48:55 +0200
Subject: [PATCH 029/113] j1939: do not assign to multiple variables at a time

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/transport.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index d0f32f6..f3c7ca2 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -765,7 +765,8 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 			session->pkt.total = dat[3];
 			session->pkt.block = dat[4];
 		}
-		session->pkt.done = session->pkt.tx = 0;
+		session->pkt.done = 0;
+		session->pkt.tx = 0;
 		get_session(session); /* equivalent to j1939tp_find() */
 		sessionlist_lock();
 		list_add_tail(&session->list, sessionq(extd));
-- 
1.9.1


From 8fd2b12014c32fd8c2a3c5a0ecb865d815fe4c85 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Mon, 19 Sep 2016 10:20:50 +0200
Subject: [PATCH 030/113] j1939: transport: make sparse happy, move constant of
 comparison to RHS

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/transport.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index f3c7ca2..3ffa087 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -712,7 +712,7 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 			skb->skb_iif, cb->srcaddr, cb->dstaddr);
 		return;
 	}
-	if (session && (0 != session->last_cmd)) {
+	if (session && (session->last_cmd != 0)) {
 		/* we received a second rts on the same connection */
 		pr_alert("%s: connection exists (%i %02x %02x)\n", __func__,
 				skb->skb_iif, cb->srcaddr, cb->dstaddr);
-- 
1.9.1


From f6f5ab6f8d6e72f5ba33200887f962ed26d83565 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 10:04:12 +0200
Subject: [PATCH 031/113] j1939: fix indention

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 include/uapi/linux/can.h       |   5 +-
 include/uapi/linux/can/j1939.h |   6 +-
 net/can/j1939/address-claim.c  |  18 ++---
 net/can/j1939/bus.c            |   9 ++-
 net/can/j1939/j1939-priv.h     |  28 +++----
 net/can/j1939/main.c           |  45 +++++------
 net/can/j1939/socket.c         |  63 ++++++++-------
 net/can/j1939/transport.c      | 173 +++++++++++++++++++++--------------------
 8 files changed, 180 insertions(+), 167 deletions(-)

diff --git a/include/uapi/linux/can.h b/include/uapi/linux/can.h
index 8d1298a..270ea3a 100644
--- a/include/uapi/linux/can.h
+++ b/include/uapi/linux/can.h
@@ -172,7 +172,10 @@ struct sockaddr_can {
 	int         can_ifindex;
 	union {
 		/* transport protocol class address information (e.g. ISOTP) */
-		struct { canid_t rx_id, tx_id; } tp;
+		struct {
+			canid_t rx_id;
+			canid_t tx_id;
+		} tp;
 
 		/* J1939 address information */
 		struct {
diff --git a/include/uapi/linux/can/j1939.h b/include/uapi/linux/can/j1939.h
index 9ca1737..4d0d23e 100644
--- a/include/uapi/linux/can/j1939.h
+++ b/include/uapi/linux/can/j1939.h
@@ -16,9 +16,9 @@
 #include <linux/can.h>
 
 #define J1939_IDLE_ADDR	0xfe
-#define J1939_NO_ADDR	0xff
-#define J1939_NO_NAME	0
-#define J1939_NO_PGN	0x40000
+#define J1939_NO_ADDR 0xff
+#define J1939_NO_NAME 0
+#define J1939_NO_PGN 0x40000
 
 /* J1939 Parameter Group Number
  *
diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
index 07f0f0a..7cf2f93 100644
--- a/net/can/j1939/address-claim.c
+++ b/net/can/j1939/address-claim.c
@@ -82,7 +82,7 @@ int j1939_fixup_address_claim(struct sk_buff *skb)
 		if (ret < 0)
 			return ret;
 		ecu = j1939_ecu_find_by_name(skcb->srcname,
-				skb->dev->ifindex);
+					     skb->dev->ifindex);
 		if (!ecu)
 			return -ENODEV;
 
@@ -94,9 +94,9 @@ int j1939_fixup_address_claim(struct sk_buff *skb)
 		/* assign source address */
 		sa = j1939_name_to_sa(skcb->srcname, skb->dev->ifindex);
 		if (!j1939_address_is_unicast(sa) &&
-				!ac_msg_is_request_for_ac(skb)) {
-			j1939_notice("tx drop: invalid sa for name "
-					"0x%016llx\n", skcb->srcname);
+		    !ac_msg_is_request_for_ac(skb)) {
+			j1939_notice("tx drop: invalid sa for name 0x%016llx\n",
+				     skcb->srcname);
 			return -EADDRNOTAVAIL;
 		}
 		skcb->srcaddr = sa;
@@ -106,8 +106,8 @@ int j1939_fixup_address_claim(struct sk_buff *skb)
 	if (skcb->dstname) {
 		sa = j1939_name_to_sa(skcb->dstname, skb->dev->ifindex);
 		if (!j1939_address_is_unicast(sa)) {
-			j1939_notice("tx drop: invalid da for name "
-					"0x%016llx\n", skcb->dstname);
+			j1939_notice("tx drop: invalid da for name 0x%016llx\n",
+				     skcb->dstname);
 			return -EADDRNOTAVAIL;
 		}
 		skcb->dstaddr = sa;
@@ -146,7 +146,7 @@ static void j1939_process_address_claim(struct sk_buff *skb)
 	write_lock_bh(&priv->lock);
 
 	ecu = _j1939_ecu_get_register(priv, name,
-			j1939_address_is_unicast(skcb->srcaddr));
+				      j1939_address_is_unicast(skcb->srcaddr));
 	if (IS_ERR(ecu))
 		goto done;
 
@@ -175,10 +175,10 @@ static void j1939_process_address_claim(struct sk_buff *skb)
 
 	/* schedule timer in 250 msec to commit address change */
 	hrtimer_start(&ecu->ac_timer, ktime_set(0, 250000000),
-			HRTIMER_MODE_REL);
+		      HRTIMER_MODE_REL);
 	/* rxtime administration */
 	ecu->rxtime = ktime_get();
-done:
+ done:
 	write_unlock_bh(&priv->lock);
 	put_j1939_priv(priv);
 }
diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index 27a55a4..efa7f60 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -41,17 +41,18 @@ static enum hrtimer_restart j1939_ecu_timer_handler(struct hrtimer *hrtimer)
 
 static void cb_put_j1939_ecu(struct kref *kref)
 {
-	struct j1939_ecu *ecu =container_of(kref, struct j1939_ecu, kref);
+	struct j1939_ecu *ecu = container_of(kref, struct j1939_ecu, kref);
 
 	kfree(ecu);
 }
+
 void put_j1939_ecu(struct j1939_ecu *ecu)
 {
 	kref_put(&ecu->kref, cb_put_j1939_ecu);
 }
 
 struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv, name_t name,
-		int create_if_necessary)
+					  int create_if_necessary)
 {
 	struct j1939_ecu *ecu, *dut;
 
@@ -143,7 +144,7 @@ int j1939_name_to_sa(u64 name, int ifindex)
 
 /* ecu lookup helper */
 static struct j1939_ecu *_j1939_ecu_find_by_name(name_t name,
-		struct j1939_priv *priv)
+						 struct j1939_priv *priv)
 {
 	struct j1939_ecu *ecu;
 
@@ -155,7 +156,7 @@ static struct j1939_ecu *_j1939_ecu_find_by_name(name_t name,
 		}
 	}
 	ecu = NULL;
-found_on_intf:
+ found_on_intf:
 	read_unlock_bh(&priv->lock);
 	return ecu;
 }
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 8dcb269..3c71900 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -26,11 +26,11 @@
 
 /* TODO: return ENETRESET on busoff. */
 
-#define PGN_REQUEST		0x0ea00
-#define PGN_ADDRESS_CLAIMED	0x0ee00
-#define PGN_MAX			0x3ffff
+#define PGN_REQUEST 0x0ea00
+#define PGN_ADDRESS_CLAIMED 0x0ee00
+#define PGN_MAX 0x3ffff
 
-#define SA_MAX_UNICAST	0xfd
+#define SA_MAX_UNICAST 0xfd
 
 /* j1939 devices */
 struct j1939_ecu {
@@ -188,12 +188,12 @@ struct j1939_ecu *j1939_ecu_find_priv_default_tx(int ifindex, name_t *pname,
 /* j1939 printk */
 #define j1939_printk(level, ...) printk(level "J1939 " __VA_ARGS__)
 
-#define j1939_err(...)		j1939_printk(KERN_ERR , __VA_ARGS__)
-#define j1939_warning(...)	j1939_printk(KERN_WARNING , __VA_ARGS__)
-#define j1939_notice(...)	j1939_printk(KERN_NOTICE , __VA_ARGS__)
-#define j1939_info(...)		j1939_printk(KERN_INFO , __VA_ARGS__)
+#define j1939_err(...)		j1939_printk(KERN_ERR, __VA_ARGS__)
+#define j1939_warning(...)	j1939_printk(KERN_WARNING, __VA_ARGS__)
+#define j1939_notice(...)	j1939_printk(KERN_NOTICE, __VA_ARGS__)
+#define j1939_info(...)		j1939_printk(KERN_INFO, __VA_ARGS__)
 #ifdef DEBUG
-#define j1939_debug(...)	j1939_printk(KERN_DEBUG , __VA_ARGS__)
+#define j1939_debug(...)	j1939_printk(KERN_DEBUG, __VA_ARGS__)
 #else
 #define j1939_debug(...)
 #endif
@@ -214,7 +214,7 @@ struct j1939_sk_buff_cb {
 	 */
 	int srcflags;
 	int dstflags;
-	#define ECU_LOCAL	1
+#define ECU_LOCAL 1
 	/* for tx, MSG_SYN will be used to sync on sockets */
 	int msg_flags;
 	/* j1939 clones incoming skb's.
@@ -224,8 +224,8 @@ struct j1939_sk_buff_cb {
 	struct sock *insock;
 };
 
-#define J1939_MSG_RESERVED	MSG_SYN
-#define J1939_MSG_SYNC		MSG_SYN
+#define J1939_MSG_RESERVED MSG_SYN
+#define J1939_MSG_SYNC MSG_SYN
 
 static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
 {
@@ -247,8 +247,8 @@ static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
  * 'create' & 'register' & 'get' new ecu
  * when a matching ecu already exists, then that is returned
  */
-extern struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv,
-		name_t name, int create_if_necessary);
+struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv,
+					  name_t name, int create_if_necessary);
 /* unregister must be called with lock held */
 void _j1939_ecu_unregister(struct j1939_ecu *);
 
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 4842c16..18544d8 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -36,10 +36,11 @@
 /* LOWLEVEL CAN interface */
 
 /* CAN_HDR: #bytes before can_frame data part */
-#define CAN_HDR	(offsetof(struct can_frame, data))
+#define CAN_HDR (offsetof(struct can_frame, data))
+
 /* CAN_FTR: #bytes beyond data part */
-#define CAN_FTR	(sizeof(struct can_frame)-CAN_HDR-\
-		sizeof(((struct can_frame *)0)->data))
+#define CAN_FTR (sizeof(struct can_frame) - CAN_HDR - \
+		 sizeof(((struct can_frame *)0)->data))
 
 static unsigned int padding;
 
@@ -108,11 +109,11 @@ static void j1939_can_recv(struct sk_buff *iskb, void *data)
 	/* update localflags */
 	read_lock_bh(&priv->lock);
 	if (j1939_address_is_unicast(skcb->srcaddr) &&
-			priv->ents[skcb->srcaddr].nusers)
+	    priv->ents[skcb->srcaddr].nusers)
 		skcb->srcflags |= ECU_LOCAL;
 	if (j1939_address_is_valid(skcb->dstaddr) ||
-			(j1939_address_is_unicast(skcb->dstaddr) &&
-				priv->ents[skcb->dstaddr].nusers))
+	    (j1939_address_is_unicast(skcb->dstaddr) &&
+	     priv->ents[skcb->dstaddr].nusers))
 		skcb->dstflags |= ECU_LOCAL;
 	read_unlock_bh(&priv->lock);
 
@@ -123,7 +124,7 @@ static void j1939_can_recv(struct sk_buff *iskb, void *data)
 		/* this means the transport layer processed the message */
 		goto done;
 	j1939_recv(skb);
-done:
+ done:
 	kfree_skb(skb);
 }
 
@@ -175,7 +176,7 @@ int j1939_send(struct sk_buff *skb)
 		cf->can_dlc = dlc;
 
 	return can_send(skb, 1);
-failed:
+ failed:
 	consume_skb(skb);
 	return ret;
 }
@@ -206,8 +207,8 @@ static void j1939_priv_ac_task(unsigned long val)
 /* NETDEV MANAGEMENT */
 
 /* values for can_rx_(un)register */
-#define J1939_CAN_ID	CAN_EFF_FLAG
-#define J1939_CAN_MASK	(CAN_EFF_FLAG | CAN_RTR_FLAG)
+#define J1939_CAN_ID CAN_EFF_FLAG
+#define J1939_CAN_MASK (CAN_EFF_FLAG | CAN_RTR_FLAG)
 
 static DEFINE_MUTEX(j1939_netdev_lock);
 
@@ -251,13 +252,13 @@ int j1939_netdev_start(struct net_device *netdev)
 
 	can_ml_priv->j1939_priv = priv;
 	dev_hold(netdev);
-done:
+ done:
 	mutex_unlock(&j1939_netdev_lock);
 	return 0;
 
-fail_can:
+ fail_can:
 	kfree(priv);
-fail_mem:
+ fail_mem:
 	mutex_unlock(&j1939_netdev_lock);
 	return ret;
 }
@@ -320,7 +321,7 @@ void put_j1939_priv(struct j1939_priv *segment)
 }
 
 static int j1939_netdev_notify(struct notifier_block *nb,
-			unsigned long msg, void *data)
+			       unsigned long msg, void *data)
 {
 	struct net_device *netdev = (struct net_device *)data;
 
@@ -366,7 +367,7 @@ static int j1939_proc_show_addr(struct seq_file *sqf, void *v)
 			if (!priv->ents[j].nusers)
 				continue;
 			seq_printf(sqf, "%s\t%02x\t%i\n",
-					netdev->name, j, priv->ents[j].nusers);
+				   netdev->name, j, priv->ents[j].nusers);
 		}
 		read_unlock_bh(&priv->lock);
 	}
@@ -389,9 +390,9 @@ static int j1939_proc_show_name(struct seq_file *sqf, void *v)
 		read_lock_bh(&priv->lock);
 		list_for_each_entry(ecu, &priv->ecus, list)
 			seq_printf(sqf, "%s\t%016llx\t%02x%s\t%i\n",
-					netdev->name, ecu->name, ecu->sa,
-				(priv->ents[ecu->sa].ecu == ecu) ? "" : "?",
-					ecu->nusers);
+				   netdev->name, ecu->name, ecu->sa,
+				   (priv->ents[ecu->sa].ecu == ecu) ? "" : "?",
+				   ecu->nusers);
 		read_unlock_bh(&priv->lock);
 	}
 	rcu_read_unlock();
@@ -454,13 +455,13 @@ static __init int j1939_module_init(void)
 	return 0;
 
 	remove_proc_entry("name", j1939_procdir);
-fail_name:
+ fail_name:
 	remove_proc_entry("addr", j1939_procdir);
-fail_addr:
+ fail_addr:
 	j1939tp_module_exit();
-fail_tp:
+ fail_tp:
 	can_proto_unregister(&j1939_can_proto);
-fail_sk:
+ fail_sk:
 	unregister_netdevice_notifier(&j1939_netdev_notifier);
 	proc_remove(j1939_procdir);
 	j1939_procdir = NULL;
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index f8d3365..fdebf3d 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -34,10 +34,11 @@ struct j1939_sock {
 	struct list_head list;
 
 	int state;
-	#define JSK_BOUND	BIT(0)
-	#define JSK_CONNECTED	BIT(1)
-	#define PROMISC		BIT(2)
-	#define RECV_OWN	BIT(3)
+
+#define JSK_BOUND BIT(0)
+#define JSK_CONNECTED BIT(1)
+#define PROMISC BIT(2)
+#define RECV_OWN BIT(3)
 
 	int ifindex_started; /* ifindex of netdev */
 
@@ -112,7 +113,7 @@ static inline int j1939_no_address(const struct sock *sk)
 
 /* matches skb control buffer (addr) with a j1939 filter */
 static inline int packet_match(const struct j1939_sk_buff_cb *skcb,
-		const struct j1939_filter *f, int nfilter)
+			       const struct j1939_filter *f, int nfilter)
 {
 	if (!nfilter)
 		/* receive all when no filters are assigned */
@@ -143,14 +144,14 @@ static void j1939sk_recv_skb(struct sk_buff *oskb, struct j1939_sock *jsk)
 	if (!(jsk->state & (JSK_BOUND | JSK_CONNECTED)))
 		return;
 	if (jsk->sk.sk_bound_dev_if &&
-			(jsk->sk.sk_bound_dev_if != oskb->skb_iif))
+	    (jsk->sk.sk_bound_dev_if != oskb->skb_iif))
 		/* this socket does not take packets from this iface */
 		return;
 	if (!(jsk->state & PROMISC)) {
 		if (jsk->addr.src) {
 			/* reject message for other destinations */
 			if (skcb->dstname &&
-				(skcb->dstname != jsk->addr.src))
+			    (skcb->dstname != jsk->addr.src))
 				/* the msg is not destined for the name
 				 * that the socket is bound to
 				 */
@@ -158,7 +159,7 @@ static void j1939sk_recv_skb(struct sk_buff *oskb, struct j1939_sock *jsk)
 		} else {
 			/* reject messages for other destination addresses */
 			if (j1939_address_is_unicast(skcb->dstaddr) &&
-				(skcb->dstaddr != jsk->addr.sa))
+			    (skcb->dstaddr != jsk->addr.sa))
 				/* the msg is not destined for the name
 				 * that the socket is bound to
 				 */
@@ -317,7 +318,7 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 
 	ret = 0;
 
-fail_locked:
+ fail_locked:
 	if (!jsk->sk.sk_bound_dev_if && jsk->ifindex_started) {
 		/* started j1939 on this netdev during this call,
 		 * so we revert that
@@ -330,7 +331,7 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 }
 
 static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
-		int len, int flags)
+			   int len, int flags)
 {
 	int ret;
 	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
@@ -395,13 +396,13 @@ static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
 	jsk->state |= JSK_CONNECTED;
 	ret = 0;
 
-fail_locked:
+ fail_locked:
 	release_sock(sock->sk);
 	return ret;
 }
 
 static void j1939sk_sock2sockaddr_can(struct sockaddr_can *addr,
-		const struct j1939_sock *jsk, int peer)
+				      const struct j1939_sock *jsk, int peer)
 {
 	addr->can_family = AF_CAN;
 	addr->can_ifindex = jsk->sk.sk_bound_dev_if;
@@ -411,7 +412,7 @@ static void j1939sk_sock2sockaddr_can(struct sockaddr_can *addr,
 }
 
 static int j1939sk_getname(struct socket *sock, struct sockaddr *uaddr,
-		int *len, int peer)
+			   int *len, int peer)
 {
 	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
 	struct sock *sk = sock->sk;
@@ -428,7 +429,7 @@ static int j1939sk_getname(struct socket *sock, struct sockaddr *uaddr,
 	j1939sk_sock2sockaddr_can(addr, jsk, peer);
 	*len = J1939_MIN_NAMELEN;
 
-failure:
+ failure:
 	release_sock(sk);
 
 	return ret;
@@ -467,8 +468,8 @@ static int j1939sk_release(struct socket *sock)
 	return 0;
 }
 
-static int j1939sk_setsockopt_flag(struct j1939_sock *jsk,
-		char __user *optval, unsigned int optlen, int flag)
+static int j1939sk_setsockopt_flag(struct j1939_sock *jsk, char __user *optval,
+				   unsigned int optlen, int flag)
 {
 	int tmp;
 
@@ -486,7 +487,7 @@ static int j1939sk_setsockopt_flag(struct j1939_sock *jsk,
 }
 
 static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
-		char __user *optval, unsigned int optlen)
+			      char __user *optval, unsigned int optlen)
 {
 	struct sock *sk = sock->sk;
 	struct j1939_sock *jsk = j1939_sk(sk);
@@ -545,7 +546,7 @@ static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
 }
 
 static int j1939sk_getsockopt(struct socket *sock, int level, int optname,
-		char __user *optval, int __user *optlen)
+			      char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
 	struct j1939_sock *jsk = j1939_sk(sk);
@@ -590,13 +591,13 @@ static int j1939sk_getsockopt(struct socket *sock, int level, int optname,
 		ret = -EFAULT;
 	else
 		ret = 0;
-no_copy:
+ no_copy:
 	release_sock(&jsk->sk);
 	return ret;
 }
 
 static int j1939sk_recvmsg(struct socket *sock, struct msghdr *msg,
-		size_t size, int flags)
+			   size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb;
@@ -621,14 +622,14 @@ static int j1939sk_recvmsg(struct socket *sock, struct msghdr *msg,
 	skcb = (void *)skb->cb;
 	if (j1939_address_is_valid(skcb->dstaddr))
 		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_ADDR,
-				sizeof(skcb->dstaddr), &skcb->dstaddr);
+			 sizeof(skcb->dstaddr), &skcb->dstaddr);
 
 	if (skcb->dstname)
 		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_NAME,
-				sizeof(skcb->dstname), &skcb->dstname);
+			 sizeof(skcb->dstname), &skcb->dstname);
 
 	put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_PRIO,
-			sizeof(skcb->priority), &skcb->priority);
+		 sizeof(skcb->priority), &skcb->priority);
 
 	if (msg->msg_name) {
 		struct sockaddr_can *paddr = msg->msg_name;
@@ -686,8 +687,12 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	if (!dev)
 		return -ENXIO;
 
-	skb = sock_alloc_send_skb(sk, size + sizeof(struct can_frame) - sizeof(((struct can_frame*)NULL)->data) + sizeof(struct can_skb_priv),
-			msg->msg_flags & MSG_DONTWAIT, &ret);
+	skb = sock_alloc_send_skb(sk,
+				  size +
+				  sizeof(struct can_frame) -
+				  sizeof(((struct can_frame *)NULL)->data) +
+				  sizeof(struct can_skb_priv),
+				  msg->msg_flags & MSG_DONTWAIT, &ret);
 	if (!skb)
 		goto put_dev;
 
@@ -716,7 +721,7 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 		struct sockaddr_can *addr = msg->msg_name;
 
 		if (addr->can_addr.j1939.name ||
-				(addr->can_addr.j1939.addr != J1939_NO_ADDR)) {
+		    (addr->can_addr.j1939.addr != J1939_NO_ADDR)) {
 			skcb->dstname = addr->can_addr.j1939.name;
 			skcb->dstaddr = addr->can_addr.j1939.addr;
 		}
@@ -735,7 +740,7 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 				ret = -EAGAIN;
 		} else {
 			ret = wait_event_interruptible(jsk->waitq,
-					j1939_sock_pending_add_first(&jsk->sk));
+						       j1939_sock_pending_add_first(&jsk->sk));
 		}
 		if (ret < 0)
 			goto free_skb;
@@ -750,9 +755,9 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	dev_put(dev);
 	return (ret < 0) ? ret : size;
 
-free_skb:
+ free_skb:
 	kfree_skb(skb);
-put_dev:
+ put_dev:
 	dev_put(dev);
 	return ret;
 }
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 3ffa087..e6e68b1 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -18,37 +18,37 @@
 #include <linux/can/skb.h>
 #include "j1939-priv.h"
 
-#define REGULAR		0
-#define EXTENDED	1
-
-#define etp_pgn_ctl	0xc800
-#define etp_pgn_dat	0xc700
-#define tp_pgn_ctl	0xec00
-#define tp_pgn_dat	0xeb00
-
-#define  tp_cmd_bam	0x20
-#define  tp_cmd_rts	0x10
-#define  tp_cmd_cts	0x11
-#define  tp_cmd_eof	0x13
-#define  tp_cmd_abort	0xff
-
-#define etp_cmd_rts	0x14
-#define etp_cmd_cts	0x15
-#define etp_cmd_dpo	0x16
-#define etp_cmd_eof	0x17
-#define etp_cmd_abort	0xff
-
-#define ABORT_BUSY	1
-#define ABORT_RESOURCE	2
-#define ABORT_TIMEOUT	3
-#define ABORT_GENERIC	4
-#define ABORT_FAULT	5
-
-#define MAX_TP_PACKET_SIZE	(7*255)
-#define MAX_ETP_PACKET_SIZE	(7*0xffffff)
+#define REGULAR 0
+#define EXTENDED 1
+
+#define etp_pgn_ctl 0xc800
+#define etp_pgn_dat 0xc700
+#define tp_pgn_ctl 0xec00
+#define tp_pgn_dat 0xeb00
+
+#define tp_cmd_bam 0x20
+#define tp_cmd_rts 0x10
+#define tp_cmd_cts 0x11
+#define tp_cmd_eof 0x13
+#define tp_cmd_abort 0xff
+
+#define etp_cmd_rts 0x14
+#define etp_cmd_cts 0x15
+#define etp_cmd_dpo 0x16
+#define etp_cmd_eof 0x17
+#define etp_cmd_abort 0xff
+
+#define ABORT_BUSY 1
+#define ABORT_RESOURCE 2
+#define ABORT_TIMEOUT 3
+#define ABORT_GENERIC 4
+#define ABORT_FAULT 5
+
+#define MAX_TP_PACKET_SIZE (7 * 0xff)
+#define MAX_ETP_PACKET_SIZE (7 * 0x00ffffff)
 
 static unsigned int block = 255;
-static unsigned int max_packet_size = 1024*100;
+static unsigned int max_packet_size = 1024 * 100;
 static unsigned int retry_ms = 20;
 static unsigned int packet_delay;
 
@@ -102,7 +102,8 @@ struct session {
 /* forward declarations */
 static struct session *j1939session_new(struct sk_buff *skb);
 static struct session *j1939session_fresh_new(int size,
-		struct sk_buff *rel_skb, pgn_t pgn);
+					      struct sk_buff *rel_skb,
+					      pgn_t pgn);
 static void j1939tp_del_work(struct work_struct *work);
 
 /* local variables */
@@ -150,7 +151,7 @@ static void j1939tp_del_work(struct work_struct *work)
 			break;
 		}
 		session = list_first_entry(&tp_delsessionq,
-				struct session, list);
+					   struct session, list);
 		list_del_init(&session->list);
 		spin_unlock_bh(&tp_dellock);
 		j1939session_destroy(session);
@@ -273,10 +274,10 @@ static inline unsigned int j1939etp_ctl_to_size(const u8 *dat)
  * reverse: swap cb's src & dst
  * there is no problem with matching broadcasts, since
  * broadcasts (no dst, no da) would never call this
- * with reverse==1
+ * with reverse == 1
  */
 static int j1939tp_match(struct session *session, struct sk_buff *skb,
-		int reverse)
+			 int reverse)
 {
 	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
 
@@ -309,7 +310,7 @@ static int j1939tp_match(struct session *session, struct sk_buff *skb,
 }
 
 static struct session *_j1939tp_find(struct list_head *root,
-		struct sk_buff *skb, int reverse)
+				     struct sk_buff *skb, int reverse)
 {
 	struct session *session;
 
@@ -323,7 +324,7 @@ static struct session *_j1939tp_find(struct list_head *root,
 }
 
 static struct session *j1939tp_find(struct list_head *root,
-		struct sk_buff *skb, int reverse)
+				    struct sk_buff *skb, int reverse)
 {
 	struct session *session;
 	sessionlist_lock();
@@ -430,11 +431,11 @@ static inline int j1939tp_tx_ctl(struct session *session,
 				 int swap_src_dst, const u8 dat[8])
 {
 	return j1939xtp_do_tx_ctl(session->skb, session->extd, swap_src_dst,
-			session->cb->pgn, dat);
+				  session->cb->pgn, dat);
 }
 
 static int j1939xtp_tx_abort(struct sk_buff *related, int extd,
-		int swap_src_dst, int err, pgn_t pgn)
+			     int swap_src_dst, int err, pgn_t pgn)
 {
 	u8 dat[5];
 
@@ -455,22 +456,23 @@ static inline void j1939session_schedule_txnow(struct session *session)
 }
 static enum hrtimer_restart j1939tp_txtimer(struct hrtimer *hrtimer)
 {
-	struct session *session =
-		container_of(hrtimer, struct session, txtimer);
+	struct session *session;
+
+	session = container_of(hrtimer, struct session, txtimer);
 	j1939session_schedule_txnow(session);
 	return HRTIMER_NORESTART;
 }
 static inline void j1939tp_schedule_txtimer(struct session *session, int msec)
 {
 	hrtimer_start(&session->txtimer,
-			ktime_set(msec / 1000, (msec % 1000)*1000000UL),
-			HRTIMER_MODE_REL);
+		      ktime_set(msec / 1000, (msec % 1000) * 1000000UL),
+		      HRTIMER_MODE_REL);
 }
 static inline void j1939tp_set_rxtimeout(struct session *session, int msec)
 {
 	hrtimer_start(&session->rxtimer,
-			ktime_set(msec / 1000, (msec % 1000)*1000000UL),
-			HRTIMER_MODE_REL);
+		      ktime_set(msec / 1000, (msec % 1000) * 1000000UL),
+		      HRTIMER_MODE_REL);
 }
 
 /* session completion functions */
@@ -505,8 +507,8 @@ static void j1939session_cancel(struct session *session, int err)
 		if (!j1939cb_is_broadcast(session->cb)) {
 			/* do not send aborts on incoming broadcasts */
 			j1939xtp_tx_abort(session->skb, session->extd,
-				!(session->cb->srcflags & ECU_LOCAL),
-				err, session->cb->pgn);
+					  !(session->cb->srcflags & ECU_LOCAL),
+					  err, session->cb->pgn);
 		}
 	}
 	j1939session_drop(session);
@@ -514,8 +516,8 @@ static void j1939session_cancel(struct session *session, int err)
 
 static enum hrtimer_restart j1939tp_rxtimer(struct hrtimer *hrtimer)
 {
-	struct session *session =
-		container_of(hrtimer, struct session, rxtimer);
+	struct session *session = container_of(hrtimer, struct session,
+					       rxtimer);
 	tasklet_schedule(&session->rxtask);
 	return HRTIMER_NORESTART;
 }
@@ -590,7 +592,7 @@ static inline void j1939xtp_rx_abort(struct sk_buff *skb, int extd)
 	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
 
 	pr_info("%s %i, %05x\n", __func__, skb->skb_iif,
-			j1939xtp_ctl_to_pgn(skb->data));
+		j1939xtp_ctl_to_pgn(skb->data));
 	_j1939xtp_rx_abort(skb, extd);
 	j1939_skbcb_swap(cb);
 	_j1939xtp_rx_abort(skb, extd);
@@ -673,7 +675,7 @@ static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
 	}
 	put_session(session); /* ~j1939tp_find */
 	return;
-bad_fmt:
+ bad_fmt:
 	session_unlock(session);
 	j1939session_cancel(session, ABORT_FAULT);
 	put_session(session); /* ~j1939tp_find */
@@ -692,7 +694,7 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 
 	if ((tp_cmd_rts == dat[0]) && j1939cb_is_broadcast(cb)) {
 		pr_alert("%s: rts without destination (%i %02x)\n", __func__,
-			skb->skb_iif, cb->srcaddr);
+			 skb->skb_iif, cb->srcaddr);
 		return;
 	}
 
@@ -709,13 +711,13 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 		return;
 	} else if (!session && j1939tp_im_transmitter(skb)) {
 		pr_alert("%s: I should tx (%i %02x %02x)\n", __func__,
-			skb->skb_iif, cb->srcaddr, cb->dstaddr);
+			 skb->skb_iif, cb->srcaddr, cb->dstaddr);
 		return;
 	}
 	if (session && (session->last_cmd != 0)) {
 		/* we received a second rts on the same connection */
 		pr_alert("%s: connection exists (%i %02x %02x)\n", __func__,
-				skb->skb_iif, cb->srcaddr, cb->dstaddr);
+			 skb->skb_iif, cb->srcaddr, cb->dstaddr);
 		j1939session_cancel(session, ABORT_BUSY);
 		put_session(session); /* ~j1939tp_find */
 		return;
@@ -755,13 +757,13 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 		}
 		session->extd = extd;
 		/* initialize the control buffer: plain copy */
-		session->pkt.total = (len+6)/7;
+		session->pkt.total = (len + 6) / 7;
 		session->pkt.block = 0xff;
 		if (!extd) {
 			if (dat[3] != session->pkt.total)
-				pr_alert("%s: strange total,"
-						" %u != %u\n", __func__,
-						session->pkt.total, dat[3]);
+				pr_alert("%s: strange total, %u != %u\n",
+					 __func__, session->pkt.total,
+					 dat[3]);
 			session->pkt.total = dat[3];
 			session->pkt.block = dat[4];
 		}
@@ -851,14 +853,14 @@ static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
 			break;
 	default:
 		pr_info("%s: last %02x\n", __func__,
-				session->last_cmd);
+			session->last_cmd);
 		goto strange_packet;
 	}
 
-	packet = (dat[0]-1+session->pkt.dpo);
+	packet = (dat[0] - 1 + session->pkt.dpo);
 	offset = packet * 7;
 	if ((packet > session->pkt.total) ||
-			(session->pkt.done+1) > session->pkt.total) {
+	    (session->pkt.done + 1) > session->pkt.total) {
 		pr_info("%s: should have been completed\n", __func__);
 		goto strange_packet;
 	}
@@ -867,7 +869,7 @@ static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
 		nbytes = 7;
 	if ((nbytes <= 0) || ((nbytes + 1) > skb->len)) {
 		pr_info("%s: nbytes %i, len %i\n", __func__, nbytes,
-				skb->len);
+			skb->len);
 		goto strange_packet;
 	}
 	tpdat = session->skb->data;
@@ -896,10 +898,10 @@ static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
 	put_session(session); /* ~j1939tp_find */
 	return;
 
-strange_packet:
+ strange_packet:
 	/* unlock session (spinlock) before trying to send */
 	session_unlock(session);
-strange_packet_unlocked:
+ strange_packet_unlocked:
 	j1939session_cancel(session, ABORT_FAULT);
 	put_session(session); /* ~j1939tp_find */
 }
@@ -924,8 +926,8 @@ static int j1939tp_txnext(struct session *session)
 		dat[3] = session->pkt.total;
 		if (session->extd) {
 			dat[0] = etp_cmd_rts;
-			dat[1] = (session->skb->len >>  0) & 0xff;
-			dat[2] = (session->skb->len >>  8) & 0xff;
+			dat[1] = (session->skb->len >> 0) & 0xff;
+			dat[2] = (session->skb->len >> 8) & 0xff;
 			dat[3] = (session->skb->len >> 16) & 0xff;
 			dat[4] = (session->skb->len >> 24) & 0xff;
 		} else if (j1939cb_is_broadcast(session->cb)) {
@@ -952,13 +954,13 @@ static int j1939tp_txnext(struct session *session)
 	case etp_cmd_rts:
 		if (!j1939tp_im_receiver(session->skb))
 			break;
-tx_cts:
+ tx_cts:
 		ret = 0;
 		len = session->pkt.total - session->pkt.done;
 		len = min(max(len, session->pkt.block), block ?: 255);
 
 		if (session->extd) {
-			pkt = session->pkt.done+1;
+			pkt = session->pkt.done + 1;
 			dat[0] = etp_cmd_cts;
 			dat[1] = len;
 			dat[2] = (pkt >>  0) & 0xff;
@@ -967,7 +969,7 @@ static int j1939tp_txnext(struct session *session)
 		} else {
 			dat[0] = tp_cmd_cts;
 			dat[1] = len;
-			dat[2] = session->pkt.done+1;
+			dat[2] = session->pkt.done + 1;
 		}
 		if (dat[0] == session->last_txcmd)
 			/* done already */
@@ -1002,7 +1004,7 @@ static int j1939tp_txnext(struct session *session)
 	case 0xff: /* did some data */
 	case etp_cmd_dpo:
 		if ((session->extd || !j1939cb_is_broadcast(session->cb)) &&
-		     j1939tp_im_receiver(session->skb)) {
+		    j1939tp_im_receiver(session->skb)) {
 			if (session->pkt.done >= session->pkt.total) {
 				if (session->extd) {
 					dat[0] = etp_cmd_eof;
@@ -1041,14 +1043,14 @@ static int j1939tp_txnext(struct session *session)
 			? session->pkt.total : session->pkt.last;
 
 		while (session->pkt.tx < pkt_end) {
-			dat[0] = session->pkt.tx - session->pkt.dpo+1;
+			dat[0] = session->pkt.tx - session->pkt.dpo + 1;
 			offset = session->pkt.tx * 7;
 			len = session->skb->len - offset;
 			if (len > 7)
 				len = 7;
 			memcpy(&dat[1], &tpdat[offset], len);
 			ret = j1939tp_tx_dat(session->skb, session->extd,
-					dat, len+1);
+					     dat, len + 1);
 			if (ret < 0)
 				break;
 			session->last_txcmd = 0xff;
@@ -1069,7 +1071,7 @@ static int j1939tp_txnext(struct session *session)
 	}
 	put_session(session);
 	return 0;
-failed:
+ failed:
 	put_session(session);
 	return ret;
 }
@@ -1127,7 +1129,7 @@ int j1939_send_transport(struct sk_buff *skb)
 		/* avoid conflict */
 		return -EDOM;
 	else if ((skb->len > MAX_ETP_PACKET_SIZE) ||
-			(max_packet_size && (skb->len > max_packet_size)))
+		 (max_packet_size && (skb->len > max_packet_size)))
 		return -EMSGSIZE;
 
 	if (skb->len > MAX_TP_PACKET_SIZE) {
@@ -1145,8 +1147,8 @@ int j1939_send_transport(struct sk_buff *skb)
 	if (!priv)
 		return -EINVAL;
 	if (!j1939_address_is_valid(cb->dstaddr) ||
-			(j1939_address_is_unicast(cb->dstaddr) &&
-				priv->ents[cb->dstaddr].nusers))
+	    (j1939_address_is_unicast(cb->dstaddr) &&
+	     priv->ents[cb->dstaddr].nusers))
 		cb->dstflags |= ECU_LOCAL;
 	put_j1939_priv(priv);
 	/* src is always local, I'm sending ... */
@@ -1160,7 +1162,7 @@ int j1939_send_transport(struct sk_buff *skb)
 	session->skb_iif = can_skb_prv(skb)->ifindex;
 	session->extd = (skb->len > MAX_TP_PACKET_SIZE) ? EXTENDED : REGULAR;
 	session->transmission = 1;
-	session->pkt.total = (skb->len + 6)/7;
+	session->pkt.total = (skb->len + 6) / 7;
 	session->pkt.block = session->extd ? 255 :
 		min(block ?: 255, session->pkt.total);
 	if (j1939cb_is_broadcast(session->cb))
@@ -1172,7 +1174,7 @@ int j1939_send_transport(struct sk_buff *skb)
 		ret = j1939session_insert(session) ? 0 : -EAGAIN;
 	else
 		ret = wait_event_interruptible(tp_wait,
-				j1939session_insert(session));
+					       j1939session_insert(session));
 	if (ret < 0)
 		goto failed;
 
@@ -1183,7 +1185,7 @@ int j1939_send_transport(struct sk_buff *skb)
 	sessionlist_lock();
 	list_del_init(&session->list);
 	sessionlist_unlock();
-failed:
+ failed:
 	/* hide the skb from j1939session_drop, as it would
 	 * kfree_skb, but our caller will kfree_skb(skb) too.
 	 */
@@ -1263,7 +1265,8 @@ int j1939_recv_transport(struct sk_buff *skb)
 }
 
 static struct session *j1939session_fresh_new(int size,
-		struct sk_buff *rel_skb, pgn_t pgn)
+					      struct sk_buff *rel_skb,
+					      pgn_t pgn)
 {
 	struct sk_buff *skb;
 	struct j1939_sk_buff_cb *cb;
@@ -1337,7 +1340,7 @@ int j1939tp_rmdev_notifier(struct net_device *netdev)
 
 /* PROC */
 static int j1939tp_proc_show_session(struct seq_file *sqf,
-		struct session *session)
+				     struct session *session)
 {
 	seq_printf(sqf, "%i", session->skb_iif);
 	if (session->cb->srcname)
@@ -1351,7 +1354,7 @@ static int j1939tp_proc_show_session(struct seq_file *sqf,
 	else
 		seq_printf(sqf, "\t-");
 	seq_printf(sqf, "\t%05x\t%u/%u\n", session->cb->pgn,
-			session->pkt.done*7, session->skb->len);
+		   session->pkt.done * 7, session->skb->len);
 	return 0;
 }
 
@@ -1375,11 +1378,11 @@ static int j1939tp_proc_open(struct inode *inode, struct file *file)
 }
 
 static const struct file_operations j1939tp_proc_ops = {
-	.owner		= THIS_MODULE,
-	.open		= j1939tp_proc_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+	.owner = THIS_MODULE,
+	.open = j1939tp_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
 };
 
 /* module init */
-- 
1.9.1


From 56189d7f0fe11d6193b3f9ec72a25335096f53c3 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 18:02:44 +0200
Subject: [PATCH 032/113] j1939: add empty lines to make code more readable

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/address-claim.c |  3 ++-
 net/can/j1939/bus.c           |  3 ++-
 net/can/j1939/j1939-priv.h    | 14 ++++++++++++++
 net/can/j1939/main.c          |  3 +++
 net/can/j1939/socket.c        |  4 +++-
 net/can/j1939/transport.c     | 26 ++++++++++++++++++++++++++
 6 files changed, 50 insertions(+), 3 deletions(-)

diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
index 7cf2f93..6fafbbc 100644
--- a/net/can/j1939/address-claim.c
+++ b/net/can/j1939/address-claim.c
@@ -37,7 +37,9 @@ static inline int ac_msg_is_request_for_ac(struct sk_buff *skb)
 
 	if ((skb->len < 3) || (skcb->pgn != PGN_REQUEST))
 		return 0;
+
 	req_pgn = skb->data[0] | (skb->data[1] << 8) | (skb->data[2] << 16);
+
 	return req_pgn == PGN_ADDRESS_CLAIMED;
 }
 
@@ -208,4 +210,3 @@ void j1939_recv_address_claim(struct sk_buff *skb, struct j1939_priv *priv)
 		put_j1939_ecu(ecu);
 	}
 }
-
diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index efa7f60..337379f 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -208,6 +208,7 @@ void j1939_name_local_get(struct j1939_priv *priv, u64 name)
 
 	if (!name)
 		return;
+
 	write_lock_bh(&priv->lock);
 	ecu = _j1939_ecu_get_register(priv, name, 1);
 	if (!IS_ERR(ecu)) {
@@ -226,6 +227,7 @@ void j1939_name_local_put(struct j1939_priv *priv, u64 name)
 
 	if (!name)
 		return;
+
 	write_lock_bh(&priv->lock);
 	ecu = _j1939_ecu_get_register(priv, name, 0);
 	if (!IS_ERR(ecu)) {
@@ -237,4 +239,3 @@ void j1939_name_local_put(struct j1939_priv *priv, u64 name)
 	}
 	write_unlock_bh(&priv->lock);
 }
-
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 3c71900..1f445b3 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -50,9 +50,11 @@ struct j1939_ecu {
 	struct hrtimer ac_timer;
 	struct kref kref;
 	struct j1939_priv *priv;
+
 	/* count users, to help transport protocol decide for interaction */
 	int nusers;
 };
+
 #define to_j1939_ecu(x) container_of((x), struct j1939_ecu, dev)
 
 struct j1939_priv {
@@ -98,14 +100,17 @@ struct j1939_priv {
 	 */
 	int nusers;
 };
+
 #define to_j1939_priv(x) container_of((x), struct j1939_priv, dev)
 
 void put_j1939_ecu(struct j1939_ecu *ecu);
 void put_j1939_priv(struct j1939_priv *segment);
+
 static inline void get_j1939_ecu(struct j1939_ecu *dut)
 {
 	kref_get(&dut->kref);
 }
+
 static inline void get_j1939_priv(struct j1939_priv *dut)
 {
 	kref_get(&dut->kref);
@@ -129,6 +134,7 @@ static inline int j1939_prio(int sk_priority)
 	else
 		return 7 - sk_priority;
 }
+
 static inline int j1939_to_sk_priority(int j1939_prio)
 {
 	return 7 - j1939_prio;
@@ -214,9 +220,12 @@ struct j1939_sk_buff_cb {
 	 */
 	int srcflags;
 	int dstflags;
+
 #define ECU_LOCAL 1
+
 	/* for tx, MSG_SYN will be used to sync on sockets */
 	int msg_flags;
+
 	/* j1939 clones incoming skb's.
 	 * insock saves the incoming skb->sk
 	 * to determine local generated packets
@@ -249,6 +258,7 @@ static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
  */
 struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv,
 					  name_t name, int create_if_necessary);
+
 /* unregister must be called with lock held */
 void _j1939_ecu_unregister(struct j1939_ecu *);
 
@@ -267,8 +277,10 @@ static inline struct j1939_priv *dev_j1939_priv(struct net_device *dev)
 
 	can_ml_priv = dev->ml_priv;
 	priv = can_ml_priv ? can_ml_priv->j1939_priv : NULL;
+
 	if (priv)
 		get_j1939_priv(priv);
+
 	return priv;
 }
 
@@ -279,8 +291,10 @@ static inline struct j1939_priv *j1939_priv_find(int ifindex)
 
 	netdev = dev_get_by_index(&init_net, ifindex);
 	priv = dev_j1939_priv(netdev);
+
 	if (netdev)
 		dev_put(netdev);
+
 	return priv;
 }
 
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 18544d8..948fedc 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -75,12 +75,14 @@ static void j1939_can_recv(struct sk_buff *iskb, void *data)
 	 */
 	cf = (void *)skb->data;
 	skb_pull(skb, CAN_HDR);
+
 	/* fix length, set to dlc, with 8 maximum */
 	skb_trim(skb, min_t(uint8_t, cf->can_dlc, 8));
 
 	/* set addr */
 	skcb = (struct j1939_sk_buff_cb *)skb->cb;
 	memset(skcb, 0, sizeof(*skcb));
+
 	/* save incoming socket, without assigning the skb to it */
 	skcb->insock = iskb->sk;
 	skcb->priority = (cf->can_id & 0x1c000000) >> 26;
@@ -195,6 +197,7 @@ static void j1939_priv_ac_task(unsigned long val)
 		/* next 2 (read & set) could be merged into xxx? */
 		if (!atomic_read(&ecu->ac_delay_expired))
 			continue;
+
 		atomic_set(&ecu->ac_delay_expired, 0);
 		if (j1939_address_is_unicast(ecu->sa)) {
 			ecu->priv->ents[ecu->sa].ecu = ecu;
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index fdebf3d..62fb105 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -108,6 +108,7 @@ void j1939_sock_pending_del(struct sock *sk)
 static inline int j1939_no_address(const struct sock *sk)
 {
 	const struct j1939_sock *jsk = j1939_sk(sk);
+
 	return (jsk->addr.sa == J1939_NO_ADDR) && !jsk->addr.src;
 }
 
@@ -304,7 +305,6 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 	jsk->addr.src = addr->can_addr.j1939.name;
 	jsk->addr.sa = addr->can_addr.j1939.addr;
 
-
 	/* set default transmit pgn */
 	if (pgn_is_valid(addr->can_addr.j1939.pgn))
 		jsk->addr.pgn = addr->can_addr.j1939.pgn;
@@ -351,6 +351,7 @@ static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
 
 	/* bind to device ... */
 	bound_dev_if = jsk->sk.sk_bound_dev_if;
+
 	/* copy netdev info */
 	if (!bound_dev_if && addr->can_ifindex)
 		bound_dev_if = addr->can_ifindex;
@@ -361,6 +362,7 @@ static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
 			goto fail_locked;
 		}
 	}
+
 	/* start j1939 */
 	if (bound_dev_if && bound_dev_if != jsk->ifindex_started) {
 		if (jsk->ifindex_started) {
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index e6e68b1..3d4cbd9 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -158,6 +158,7 @@ static void j1939tp_del_work(struct work_struct *work)
 		++cnt;
 	} while (1);
 }
+
 /* reference counter */
 static inline void get_session(struct session *session)
 {
@@ -289,6 +290,7 @@ static int j1939tp_match(struct session *session, struct sk_buff *skb,
 				return 0;
 		} else if (session->cb->srcaddr != cb->srcaddr)
 			return 0;
+
 		if (session->cb->dstname) {
 			if (session->cb->dstname != cb->dstname)
 				return 0;
@@ -306,6 +308,7 @@ static int j1939tp_match(struct session *session, struct sk_buff *skb,
 		} else if (session->cb->dstaddr != cb->srcaddr)
 			return 0;
 	}
+
 	return 1;
 }
 
@@ -320,6 +323,7 @@ static struct session *_j1939tp_find(struct list_head *root,
 			return session;
 		put_session(session);
 	}
+
 	return NULL;
 }
 
@@ -327,9 +331,11 @@ static struct session *j1939tp_find(struct list_head *root,
 				    struct sk_buff *skb, int reverse)
 {
 	struct session *session;
+
 	sessionlist_lock();
 	session = _j1939tp_find(root, skb, reverse);
 	sessionlist_unlock();
+
 	return session;
 }
 
@@ -351,6 +357,7 @@ static void j1939_skbcb_swap(struct j1939_sk_buff_cb *cb)
 	cb->dstflags = cb->srcflags;
 	cb->srcflags = flags;
 }
+
 /* TP transmit packet functions */
 static int j1939tp_tx_dat(struct sk_buff *related, int extd,
 			  const u8 *dat, int len)
@@ -454,20 +461,24 @@ static inline void j1939session_schedule_txnow(struct session *session)
 {
 	tasklet_schedule(&session->txtask);
 }
+
 static enum hrtimer_restart j1939tp_txtimer(struct hrtimer *hrtimer)
 {
 	struct session *session;
 
 	session = container_of(hrtimer, struct session, txtimer);
 	j1939session_schedule_txnow(session);
+
 	return HRTIMER_NORESTART;
 }
+
 static inline void j1939tp_schedule_txtimer(struct session *session, int msec)
 {
 	hrtimer_start(&session->txtimer,
 		      ktime_set(msec / 1000, (msec % 1000) * 1000000UL),
 		      HRTIMER_MODE_REL);
 }
+
 static inline void j1939tp_set_rxtimeout(struct session *session, int msec)
 {
 	hrtimer_start(&session->rxtimer,
@@ -518,6 +529,7 @@ static enum hrtimer_restart j1939tp_rxtimer(struct hrtimer *hrtimer)
 {
 	struct session *session = container_of(hrtimer, struct session,
 					       rxtimer);
+
 	tasklet_schedule(&session->rxtask);
 	return HRTIMER_NORESTART;
 }
@@ -558,9 +570,11 @@ static void j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
 	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
 
 	pr_info("%s, pgn %05x\n", __func__, j1939xtp_ctl_to_pgn(skb->data));
+
 	_j1939xtp_rx_bad_message(skb, extd);
 	j1939_skbcb_swap(cb);
 	_j1939xtp_rx_bad_message(skb, extd);
+
 	/* restore skb */
 	j1939_skbcb_swap(cb);
 }
@@ -581,11 +595,13 @@ static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd)
 		 */
 	} else if (session->cb->pgn == pgn)
 		j1939session_drop(session);
+
 	/* TODO: maybe cancel current connection
 	 * as another pgn was communicated
 	 */
 	put_session(session); /* ~j1939tp_find */
 }
+
 /* abort packets may come in 2 directions */
 static inline void j1939xtp_rx_abort(struct sk_buff *skb, int extd)
 {
@@ -593,9 +609,11 @@ static inline void j1939xtp_rx_abort(struct sk_buff *skb, int extd)
 
 	pr_info("%s %i, %05x\n", __func__, skb->skb_iif,
 		j1939xtp_ctl_to_pgn(skb->data));
+
 	_j1939xtp_rx_abort(skb, extd);
 	j1939_skbcb_swap(cb);
 	_j1939xtp_rx_abort(skb, extd);
+
 	/* restore skb */
 	j1939_skbcb_swap(cb);
 }
@@ -638,6 +656,7 @@ static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
 		/* 'CTS shall be ignored' */
 		return;
 	}
+
 	if (session->cb->pgn != pgn) {
 		/* what to do? */
 		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
@@ -645,6 +664,7 @@ static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
 		put_session(session); /* ~j1939tp_find */
 		return;
 	}
+
 	session_lock(session);
 	pkt = extd ? j1939etp_ctl_to_packet(dat) : dat[2];
 	if (!dat[0])
@@ -663,6 +683,7 @@ static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
 		/* TODO: do not set tx here, do it in txtask */
 		session->pkt.tx = session->pkt.done;
 	}
+
 	session->last_cmd = dat[0];
 	session_unlock(session);
 	if (dat[1]) {
@@ -731,6 +752,7 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 		session->cb->dstaddr = cb->dstaddr;
 	} else {
 		int abort = 0;
+
 		if (extd) {
 			len = j1939etp_ctl_to_size(dat);
 			if (len > MAX_ETP_PACKET_SIZE)
@@ -756,6 +778,7 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 			return;
 		}
 		session->extd = extd;
+
 		/* initialize the control buffer: plain copy */
 		session->pkt.total = (len + 6) / 7;
 		session->pkt.block = 0xff;
@@ -811,6 +834,7 @@ static void j1939xtp_rx_dpo(struct sk_buff *skb, int extd)
 		put_session(session); /* ~j1939tp_find */
 		return;
 	}
+
 	/* transmitted without problems */
 	session->pkt.dpo = j1939etp_ctl_to_packet(skb->data);
 	session->last_cmd = dat[0];
@@ -1292,10 +1316,12 @@ static struct session *j1939session_fresh_new(int size,
 	}
 	session->skb_iif = rel_skb->skb_iif;
 	skb->dev = rel_skb->dev;
+
 	/* alloc data area */
 	skb_put(skb, size);
 	return session;
 }
+
 static struct session *j1939session_new(struct sk_buff *skb)
 {
 	struct session *session;
-- 
1.9.1


From 3d3c11524852e06bd7577ece986bbc62d3679737 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 17:18:16 +0200
Subject: [PATCH 033/113] j1939: use braces on both legs of if...else
 expression

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/address-claim.c |  4 ++--
 net/can/j1939/main.c          |  3 ++-
 net/can/j1939/socket.c        | 11 ++++++-----
 net/can/j1939/transport.c     | 28 +++++++++++++++++-----------
 4 files changed, 27 insertions(+), 19 deletions(-)

diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
index 6fafbbc..4c16d9a 100644
--- a/net/can/j1939/address-claim.c
+++ b/net/can/j1939/address-claim.c
@@ -191,9 +191,9 @@ void j1939_recv_address_claim(struct sk_buff *skb, struct j1939_priv *priv)
 	struct j1939_ecu *ecu;
 
 	/* network mgmt */
-	if (skcb->pgn == PGN_ADDRESS_CLAIMED)
+	if (skcb->pgn == PGN_ADDRESS_CLAIMED) {
 		j1939_process_address_claim(skb);
-	else if (j1939_address_is_unicast(skcb->srcaddr)) {
+	} else if (j1939_address_is_unicast(skcb->srcaddr)) {
 		ecu = j1939_ecu_find_by_addr(skcb->srcaddr, skb->skb_iif);
 		if (ecu) {
 			/* source administration */
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 948fedc..dec1c47 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -174,8 +174,9 @@ int j1939_send(struct sk_buff *skb)
 	if (padding) {
 		memset(cf->data + dlc, 0xff, 8 - dlc);
 		cf->can_dlc = 8;
-	} else
+	} else {
 		cf->can_dlc = dlc;
+	}
 
 	return can_send(skb, 1);
  failed:
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 62fb105..e4a1c7e 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -77,8 +77,9 @@ static inline int j1939_sock_pending_add_first(struct sock *sk)
 	if (!jsk->skb_pending) {
 		++jsk->skb_pending;
 		saved = 1;
-	} else
+	} else {
 		saved = 0;
+	}
 	spin_unlock_bh(&jsk->lock);
 	return saved;
 }
@@ -265,9 +266,9 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 	/* bind to device ... */
 	bound_dev_if = jsk->sk.sk_bound_dev_if;
 	/* copy netdev info */
-	if (!bound_dev_if && addr->can_ifindex)
+	if (!bound_dev_if && addr->can_ifindex) {
 		bound_dev_if = addr->can_ifindex;
-	else if (bound_dev_if && addr->can_ifindex) {
+	} else if (bound_dev_if && addr->can_ifindex) {
 		/* do netdev */
 		if (bound_dev_if != addr->can_ifindex) {
 			ret = -EBUSY;
@@ -353,9 +354,9 @@ static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
 	bound_dev_if = jsk->sk.sk_bound_dev_if;
 
 	/* copy netdev info */
-	if (!bound_dev_if && addr->can_ifindex)
+	if (!bound_dev_if && addr->can_ifindex) {
 		bound_dev_if = addr->can_ifindex;
-	else if (bound_dev_if && addr->can_ifindex) {
+	} else if (bound_dev_if && addr->can_ifindex) {
 		/* do netdev */
 		if (bound_dev_if != addr->can_ifindex) {
 			ret = -EBUSY;
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 3d4cbd9..584e0ed 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -288,25 +288,30 @@ static int j1939tp_match(struct session *session, struct sk_buff *skb,
 		if (session->cb->srcname) {
 			if (session->cb->srcname != cb->srcname)
 				return 0;
-		} else if (session->cb->srcaddr != cb->srcaddr)
+		} else if (session->cb->srcaddr != cb->srcaddr) {
 			return 0;
+		}
 
 		if (session->cb->dstname) {
 			if (session->cb->dstname != cb->dstname)
 				return 0;
-		} else if (session->cb->dstaddr != cb->dstaddr)
+		} else if (session->cb->dstaddr != cb->dstaddr) {
 			return 0;
+		}
 	} else {
 		if (session->cb->srcname) {
 			if (session->cb->srcname != cb->dstname)
 				return 0;
-		} else if (session->cb->srcaddr != cb->dstaddr)
+		} else if (session->cb->srcaddr != cb->dstaddr) {
 			return 0;
+		}
+
 		if (session->cb->dstname) {
 			if (session->cb->dstname != cb->srcname)
 				return 0;
-		} else if (session->cb->dstaddr != cb->srcaddr)
+		} else if (session->cb->dstaddr != cb->srcaddr) {
 			return 0;
+		}
 	}
 
 	return 1;
@@ -593,8 +598,9 @@ static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd)
 		 * do not drop session when a transmit session did not
 		 * start yet
 		 */
-	} else if (session->cb->pgn == pgn)
+	} else if (session->cb->pgn == pgn) {
 		j1939session_drop(session);
+	}
 
 	/* TODO: maybe cancel current connection
 	 * as another pgn was communicated
@@ -626,11 +632,12 @@ static void j1939xtp_rx_eof(struct sk_buff *skb, int extd)
 	/* end of tx cycle */
 	pgn = j1939xtp_ctl_to_pgn(skb->data);
 	session = j1939tp_find(sessionq(extd), skb, 1);
-	if (!session)
+	if (!session) {
 		/* strange, we had EOF on closed connection
 		 * do nothing, as EOF closes the connection anyway
 		 */
 		return;
+	}
 
 	if (session->cb->pgn != pgn) {
 		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
@@ -667,13 +674,13 @@ static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
 
 	session_lock(session);
 	pkt = extd ? j1939etp_ctl_to_packet(dat) : dat[2];
-	if (!dat[0])
+	if (!dat[0]) {
 		hrtimer_cancel(&session->txtimer);
-	else if (!pkt)
+	} else if (!pkt) {
 		goto bad_fmt;
-	else if (dat[1] > session->pkt.block /* 0xff for etp */)
+	} else if (dat[1] > session->pkt.block /* 0xff for etp */) {
 		goto bad_fmt;
-	else {
+	} else {
 		/* set packet counters only when not CTS(0) */
 		session->pkt.done = pkt - 1;
 		session->pkt.last = session->pkt.done + dat[1];
@@ -1438,4 +1445,3 @@ void j1939tp_module_exit(void)
 	sessionlist_unlock();
 	flush_scheduled_work();
 }
-
-- 
1.9.1


From 33c9daa06369e87344b7c0792744d8e11e290f6e Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Mon, 19 Sep 2016 10:19:00 +0200
Subject: [PATCH 034/113] j1939: make j1939_procname a local symbol

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 1 -
 net/can/j1939/main.c       | 2 +-
 2 files changed, 1 insertion(+), 2 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 1f445b3..eb7a4fa 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -189,7 +189,6 @@ struct j1939_ecu *j1939_ecu_find_priv_default_tx(int ifindex, name_t *pname,
 						 u8 *paddr);
 
 extern struct proc_dir_entry *j1939_procdir;
-extern const char j1939_procname[];
 
 /* j1939 printk */
 #define j1939_printk(level, ...) printk(level "J1939 " __VA_ARGS__)
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index dec1c47..51bb9f9 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -30,7 +30,7 @@
 MODULE_AUTHOR("EIA Electronics (Kurt Van Dijck & Pieter Beyens)");
 MODULE_ALIAS("can-proto-" __stringify(CAN_J1939));
 
-const char j1939_procname[] = "can-j1939";
+static const char j1939_procname[] = "can-j1939";
 struct proc_dir_entry *j1939_procdir;
 
 /* LOWLEVEL CAN interface */
-- 
1.9.1


From 6abec4c1d36cad73d1f1478af6fe8abe977f604f Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 17:27:44 +0200
Subject: [PATCH 035/113] j1939: no need to check for NULL pointers before
 calling kfree()

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index e4a1c7e..6ebd2f2 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -523,8 +523,7 @@ static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
 		jsk->filters = filters;
 		jsk->nfilters = count;
 		spin_unlock_bh(&j1939_socks_lock);
-		if (ofilters)
-			kfree(ofilters);
+		kfree(ofilters);
 		return 0;
 	case SO_J1939_PROMISC:
 		return j1939sk_setsockopt_flag(jsk, optval, optlen, PROMISC);
-- 
1.9.1


From 296786c844d03f76b8fdb2d9b402e95444f2fa72 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 17:23:22 +0200
Subject: [PATCH 036/113] j1939: convert seq_printf() of const strings to
 seq_puts()

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/main.c      | 4 ++--
 net/can/j1939/transport.c | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 51bb9f9..2a6a956 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -360,7 +360,7 @@ static int j1939_proc_show_addr(struct seq_file *sqf, void *v)
 	struct j1939_priv *priv;
 	int j;
 
-	seq_printf(sqf, "iface\tsa\t#users\n");
+	seq_puts(sqf, "iface\tsa\t#users\n");
 	rcu_read_lock();
 	for_each_netdev_rcu(&init_net, netdev) {
 		priv = dev_j1939_priv(netdev);
@@ -385,7 +385,7 @@ static int j1939_proc_show_name(struct seq_file *sqf, void *v)
 	struct j1939_priv *priv;
 	struct j1939_ecu *ecu;
 
-	seq_printf(sqf, "iface\tname\tsa\t#users\n");
+	seq_puts(sqf, "iface\tname\tsa\t#users\n");
 	rcu_read_lock();
 	for_each_netdev_rcu(&init_net, netdev) {
 		priv = dev_j1939_priv(netdev);
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 584e0ed..d1130cd 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -1385,7 +1385,7 @@ static int j1939tp_proc_show_session(struct seq_file *sqf,
 	else if (j1939_address_is_unicast(session->cb->dstaddr))
 		seq_printf(sqf, "\t%02x", session->cb->dstaddr);
 	else
-		seq_printf(sqf, "\t-");
+		seq_puts(sqf, "\t-");
 	seq_printf(sqf, "\t%05x\t%u/%u\n", session->cb->pgn,
 		   session->pkt.done * 7, session->skb->len);
 	return 0;
@@ -1395,7 +1395,7 @@ static int j1939tp_proc_show(struct seq_file *sqf, void *v)
 {
 	struct session *session;
 
-	seq_printf(sqf, "iface\tsrc\tdst\tpgn\tdone/total\n");
+	seq_puts(sqf, "iface\tsrc\tdst\tpgn\tdone/total\n");
 	sessionlist_lock();
 	list_for_each_entry(session, &tp_sessionq, list)
 		j1939tp_proc_show_session(sqf, session);
-- 
1.9.1


From 931d6557e95bb465b0f55b1e012770d66e9365d4 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 8 Sep 2016 17:21:31 +0200
Subject: [PATCH 037/113] j1939: remove BUG() from code

...do not crash the whole kernel.

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/bus.c        | 1 -
 net/can/j1939/j1939-priv.h | 2 --
 net/can/j1939/main.c       | 4 +---
 net/can/j1939/transport.c  | 3 ---
 4 files changed, 1 insertion(+), 9 deletions(-)

diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index 337379f..651de57 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -87,7 +87,6 @@ struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv, name_t name,
 
 void _j1939_ecu_unregister(struct j1939_ecu *ecu)
 {
-	BUG_ON(!ecu);
 	ecu_dbg(ecu, "unregister\n");
 	hrtimer_try_to_cancel(&ecu->ac_timer);
 
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index eb7a4fa..46300e3 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -269,8 +269,6 @@ static inline struct j1939_priv *dev_j1939_priv(struct net_device *dev)
 	struct can_dev_rcv_lists *can_ml_priv;
 	struct j1939_priv *priv;
 
-	BUG_ON(!dev);
-
 	if (dev->type != ARPHRD_CAN)
 		return NULL;
 
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 2a6a956..a766fa7 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -157,7 +157,7 @@ int j1939_send(struct sk_buff *skb)
 
 	/* re-claim the CAN_HDR from the SKB */
 	cf = (void *)skb_push(skb, CAN_HDR);
-	BUG_ON(!cf);
+
 	/* make it a full can frame again */
 	skb_put(skb, CAN_FTR + (8 - dlc));
 
@@ -222,7 +222,6 @@ int j1939_netdev_start(struct net_device *netdev)
 	struct j1939_priv *priv;
 	struct can_dev_rcv_lists *can_ml_priv;
 
-	BUG_ON(!netdev);
 	if (netdev->type != ARPHRD_CAN)
 		return -EAFNOSUPPORT;
 
@@ -272,7 +271,6 @@ void j1939_netdev_stop(struct net_device *netdev)
 	struct can_dev_rcv_lists *can_ml_priv;
 	struct j1939_priv *priv;
 
-	BUG_ON(!netdev);
 	if (netdev->type != ARPHRD_CAN)
 		return;
 	can_ml_priv = netdev->ml_priv;
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index d1130cd..56bc5bf 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -167,12 +167,9 @@ static inline void get_session(struct session *session)
 
 static void put_session(struct session *session)
 {
-	BUG_ON(!session);
 	if (atomic_add_return(-1, &session->refs) >= 0)
 		/* not the last one */
 		return;
-	/* it should have been removed from any list long time ago */
-	BUG_ON(!list_empty(&session->list));
 
 	hrtimer_try_to_cancel(&session->rxtimer);
 	hrtimer_try_to_cancel(&session->txtimer);
-- 
1.9.1


From 8579d6d9d0eae1c3a8a86a852686082a6f078a50 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Mon, 19 Sep 2016 10:21:58 +0200
Subject: [PATCH 038/113] j1939: main: j1939_can_recv: just crash if called
 without priv, this should not happen.

---
 net/can/j1939/main.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index a766fa7..fed3fcae 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -59,9 +59,6 @@ static void j1939_can_recv(struct sk_buff *iskb, void *data)
 
 	BUILD_BUG_ON(sizeof(*skcb) > sizeof(skb->cb));
 
-	if (!priv)
-		return;
-
 	/* create a copy of the skb
 	 * j1939 only delivers the real data bytes,
 	 * the header goes into sockaddr.
-- 
1.9.1


From 176f32aa9539c6ef137c3f2c9af1abc02850121f Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Mon, 19 Sep 2016 10:24:58 +0200
Subject: [PATCH 039/113] j1939: j1939_sock: convert skb_pending to atomic_t

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 43 ++++++++++++++++++-------------------------
 1 file changed, 18 insertions(+), 25 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 6ebd2f2..96e80a0 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -57,8 +57,7 @@ struct j1939_sock {
 	 * when transport protocol comes in.
 	 * To allow emitting in order, keep a 'pending' nr. of packets
 	 */
-	int skb_pending;
-	spinlock_t lock;
+	atomic_t skb_pending;
 	wait_queue_head_t waitq;
 };
 
@@ -67,43 +66,37 @@ static inline struct j1939_sock *j1939_sk(const struct sock *sk)
 	return container_of(sk, struct j1939_sock, sk);
 }
 
-/* skb_pending issues */
+/* j1939_sock_pending_add_first
+ * Succeeds when the first pending SKB is scheduled
+ * Fails when SKB are already pending
+ */
 static inline int j1939_sock_pending_add_first(struct sock *sk)
 {
-	int saved;
 	struct j1939_sock *jsk = j1939_sk(sk);
 
-	spin_lock_bh(&jsk->lock);
-	if (!jsk->skb_pending) {
-		++jsk->skb_pending;
-		saved = 1;
-	} else {
-		saved = 0;
-	}
-	spin_unlock_bh(&jsk->lock);
-	return saved;
+	/* atomic_cmpxchg returns the old value
+	 * When it was 0, it is exchanged with 1 and this function
+	 * succeeded. (return 1)
+	 * When it was != 0, it is not exchanged, and this fuction
+	 * fails (returns 0).
+	 */
+	return !atomic_cmpxchg(&jsk->skb_pending, 0, 1);
 }
 
 static inline void j1939_sock_pending_add(struct sock *sk)
 {
 	struct j1939_sock *jsk = j1939_sk(sk);
 
-	spin_lock_bh(&jsk->lock);
-	++jsk->skb_pending;
-	spin_unlock_bh(&jsk->lock);
+	atomic_inc(&jsk->skb_pending);
 }
 
 void j1939_sock_pending_del(struct sock *sk)
 {
 	struct j1939_sock *jsk = j1939_sk(sk);
-	int saved;
-
-	spin_lock_bh(&jsk->lock);
-	--jsk->skb_pending;
-	saved = jsk->skb_pending;
-	spin_unlock_bh(&jsk->lock);
-	if (!saved)
-		wake_up(&jsk->waitq);
+
+	/* atomic_dec_return returns the new value */
+	if (!atomic_dec_return(&jsk->skb_pending))
+		wake_up(&jsk->waitq);	/* no pending SKB's */
 }
 
 static inline int j1939_no_address(const struct sock *sk)
@@ -209,13 +202,13 @@ static int j1939sk_init(struct sock *sk)
 	struct j1939_sock *jsk = j1939_sk(sk);
 
 	INIT_LIST_HEAD(&jsk->list);
-	spin_lock_init(&jsk->lock);
 	init_waitqueue_head(&jsk->waitq);
 	jsk->sk.sk_priority = j1939_to_sk_priority(6);
 	jsk->sk.sk_reuse = 1; /* per default */
 	jsk->addr.sa = J1939_NO_ADDR;
 	jsk->addr.da = J1939_NO_ADDR;
 	jsk->addr.pgn = J1939_NO_PGN;
+	atomic_set(&jsk->skb_pending, 0);
 	return 0;
 }
 
-- 
1.9.1


From a6c57c5fbfb7297765dccd4150b08c76d1e1ab9f Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 20 Sep 2016 10:01:31 +0200
Subject: [PATCH 040/113] j1939: transport: j1939tp_txnext(): add missing break
 and fallthtough annotations

As discussed in: Message-ID: <20160920092234.7accf5f8@erd980>

Suggested-by: David Jander <david@protonic.nl>
Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/transport.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 56bc5bf..26c2a32 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -979,7 +979,7 @@ static int j1939tp_txnext(struct session *session)
 		j1939tp_set_rxtimeout(session, 1250);
 		break;
 	case tp_cmd_rts:
-	case etp_cmd_rts:
+	case etp_cmd_rts: /* fallthrough */
 		if (!j1939tp_im_receiver(session->skb))
 			break;
  tx_cts:
@@ -1028,9 +1028,10 @@ static int j1939tp_txnext(struct session *session)
 			j1939tp_set_rxtimeout(session, 1250);
 			session->pkt.tx = session->pkt.done;
 		}
-	case tp_cmd_cts:
-	case 0xff: /* did some data */
-	case etp_cmd_dpo:
+		/* fallthrough */
+	case tp_cmd_cts: /* fallthrough */
+	case 0xff: /* did some data */			/* FIXME: let David Jander recheck this */
+	case etp_cmd_dpo: /* fallthrough */
 		if ((session->extd || !j1939cb_is_broadcast(session->cb)) &&
 		    j1939tp_im_receiver(session->skb)) {
 			if (session->pkt.done >= session->pkt.total) {
@@ -1061,7 +1062,7 @@ static int j1939tp_txnext(struct session *session)
 				goto tx_cts;
 			}
 		}
-	case tp_cmd_bam:
+	case tp_cmd_bam: /* fallthrough */
 		if (!j1939tp_im_transmitter(session->skb))
 			break;
 		tpdat = session->skb->data;
-- 
1.9.1


From 36b65ee51fb20456fb1f39b1150142c9bf566c77 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 20 Sep 2016 10:58:59 +0200
Subject: [PATCH 041/113] j1939: transport: convert fixed-size array function
 parameters to pointers

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/transport.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 26c2a32..bb7e356 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -396,7 +396,7 @@ static int j1939tp_tx_dat(struct sk_buff *related, int extd,
 }
 
 static int j1939xtp_do_tx_ctl(struct sk_buff *related, int extd,
-			      int swap_src_dst, pgn_t pgn, const u8 dat[5])
+			      int swap_src_dst, pgn_t pgn, const u8 *dat)
 {
 	struct sk_buff *skb;
 	struct j1939_sk_buff_cb *skb_cb;
@@ -437,7 +437,7 @@ static int j1939xtp_do_tx_ctl(struct sk_buff *related, int extd,
 }
 
 static inline int j1939tp_tx_ctl(struct session *session,
-				 int swap_src_dst, const u8 dat[8])
+				 int swap_src_dst, const u8 *dat)
 {
 	return j1939xtp_do_tx_ctl(session->skb, session->extd, swap_src_dst,
 				  session->cb->pgn, dat);
-- 
1.9.1


From 8c369df904508327a050f921e5fc22a17505f40c Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 20 Sep 2016 11:47:56 +0200
Subject: [PATCH 042/113] j1939: transport: remove unneeded & 0xff, as dat and
 skdat are u8

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/transport.c | 30 +++++++++++++++---------------
 1 file changed, 15 insertions(+), 15 deletions(-)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index bb7e356..d2995fd 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -429,9 +429,9 @@ static int j1939xtp_do_tx_ctl(struct sk_buff *related, int extd,
 
 	skdat = skb_put(skb, 8);
 	memcpy(skdat, dat, 5);
-	skdat[7] = (pgn >> 16) & 0xff;
-	skdat[6] = (pgn >>  8) & 0xff;
-	skdat[5] = (pgn >>  0) & 0xff;
+	skdat[5] = (pgn >> 0);
+	skdat[6] = (pgn >> 8);
+	skdat[7] = (pgn >> 16);
 
 	return j1939_send(skb);
 }
@@ -949,15 +949,15 @@ static int j1939tp_txnext(struct session *session)
 	case 0:
 		if (!j1939tp_im_transmitter(session->skb))
 			break;
-		dat[1] = (session->skb->len >> 0) & 0xff;
-		dat[2] = (session->skb->len >> 8) & 0xff;
+		dat[1] = (session->skb->len >> 0);
+		dat[2] = (session->skb->len >> 8);
 		dat[3] = session->pkt.total;
 		if (session->extd) {
 			dat[0] = etp_cmd_rts;
-			dat[1] = (session->skb->len >> 0) & 0xff;
-			dat[2] = (session->skb->len >> 8) & 0xff;
-			dat[3] = (session->skb->len >> 16) & 0xff;
-			dat[4] = (session->skb->len >> 24) & 0xff;
+			dat[1] = (session->skb->len >> 0);
+			dat[2] = (session->skb->len >> 8);
+			dat[3] = (session->skb->len >> 16);
+			dat[4] = (session->skb->len >> 24);
 		} else if (j1939cb_is_broadcast(session->cb)) {
 			dat[0] = tp_cmd_bam;
 			/* fake cts for broadcast */
@@ -991,9 +991,9 @@ static int j1939tp_txnext(struct session *session)
 			pkt = session->pkt.done + 1;
 			dat[0] = etp_cmd_cts;
 			dat[1] = len;
-			dat[2] = (pkt >>  0) & 0xff;
-			dat[3] = (pkt >>  8) & 0xff;
-			dat[4] = (pkt >> 16) & 0xff;
+			dat[2] = (pkt >> 0);
+			dat[3] = (pkt >> 8);
+			dat[4] = (pkt >> 16);
 		} else {
 			dat[0] = tp_cmd_cts;
 			dat[1] = len;
@@ -1018,9 +1018,9 @@ static int j1939tp_txnext(struct session *session)
 			session->pkt.dpo = session->pkt.done;
 			pkt = session->pkt.dpo;
 			dat[1] = session->pkt.last - session->pkt.done;
-			dat[2] = (pkt >>  0) & 0xff;
-			dat[3] = (pkt >>  8) & 0xff;
-			dat[4] = (pkt >> 16) & 0xff;
+			dat[2] = (pkt >> 0);
+			dat[3] = (pkt >> 8);
+			dat[4] = (pkt >> 16);
 			ret = j1939tp_tx_ctl(session, 0, dat);
 			if (ret < 0)
 				goto failed;
-- 
1.9.1


From c06e107ef6d1e622a3e6f390f5cf8ba252394d7c Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 20 Sep 2016 11:47:56 +0200
Subject: [PATCH 043/113] j1939: main: remove unneeded & 0xff, as srcaddr and
 dstaddr are u8

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/main.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index fed3fcae..6092506 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -83,11 +83,11 @@ static void j1939_can_recv(struct sk_buff *iskb, void *data)
 	/* save incoming socket, without assigning the skb to it */
 	skcb->insock = iskb->sk;
 	skcb->priority = (cf->can_id & 0x1c000000) >> 26;
-	skcb->srcaddr = cf->can_id & 0xff;
+	skcb->srcaddr = cf->can_id;
 	skcb->pgn = (cf->can_id & 0x3ffff00) >> 8;
 	if (pgn_is_pdu1(skcb->pgn)) {
 		/* Type 1: with destination address */
-		skcb->dstaddr = skcb->pgn & 0xff;
+		skcb->dstaddr = skcb->pgn;
 		/* normalize pgn: strip dst address */
 		skcb->pgn &= 0x3ff00;
 	} else {
@@ -159,11 +159,11 @@ int j1939_send(struct sk_buff *skb)
 	skb_put(skb, CAN_FTR + (8 - dlc));
 
 	canid = CAN_EFF_FLAG |
-		(skcb->srcaddr & 0xff) |
+		(skcb->srcaddr) |
 		((skcb->priority & 0x7) << 26);
 	if (pgn_is_pdu1(skcb->pgn))
 		canid |= ((skcb->pgn & 0x3ff00) << 8) |
-			((skcb->dstaddr & 0xff) << 8);
+			(skcb->dstaddr << 8);
 	else
 		canid |= ((skcb->pgn & 0x3ffff) << 8);
 
-- 
1.9.1


From b3c929eaae70bf47319261f5f23c54ad18a8fa3d Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 20 Sep 2016 11:49:58 +0200
Subject: [PATCH 044/113] j1939: j1939-priv: remove comparison if dstaddr is
 bigger than 0xff, it's an u8

---
 net/can/j1939/j1939-priv.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 46300e3..3ae19cc 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -237,7 +237,7 @@ struct j1939_sk_buff_cb {
 
 static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
 {
-	return (!skcb->dstname && (skcb->dstaddr >= 0xff));
+	return (!skcb->dstname && (skcb->dstaddr == 0xff));
 }
 
 int j1939_send(struct sk_buff *);
-- 
1.9.1


From 9b200f261648dc21b58c27c2f1002eadee2d29c4 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Mon, 3 Oct 2016 13:31:55 +0200
Subject: [PATCH 045/113] j1939: required_size: convert to uppercase, exchange
 arguments

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 include/linux/can/core.h | 7 +++----
 net/can/bcm.c            | 4 ++--
 net/can/j1939/socket.c   | 2 +-
 net/can/raw.c            | 4 ++--
 4 files changed, 8 insertions(+), 9 deletions(-)

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index bd5afce..9e8bd80 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -41,14 +41,13 @@ struct can_proto {
 	struct proto *prot;
 };
 
-/*
- * required_size
+/* required_size
  * macro to find the minimum size of a struct
  * that includes a requested member
  */
-#define required_size(member, struct_type) \
+#define REQUIRED_SIZE(struct_type, member) \
 	(offsetof(typeof(struct_type), member) + \
-	 sizeof(((typeof(struct_type) *)(0))->member))
+	 sizeof(((typeof(struct_type) *)(NULL))->member))
 
 /* function prototypes for the CAN networklayer core (af_can.c) */
 
diff --git a/net/can/bcm.c b/net/can/bcm.c
index 528f321..062b7ef 100644
--- a/net/can/bcm.c
+++ b/net/can/bcm.c
@@ -1328,7 +1328,7 @@ static int bcm_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 		/* no bound device as default => check msg_name */
 		DECLARE_SOCKADDR(struct sockaddr_can *, addr, msg->msg_name);
 
-		if (msg->msg_namelen < required_size(can_ifindex, *addr))
+		if (msg->msg_namelen < REQUIRED_SIZE(*addr, can_ifindex))
 			return -EINVAL;
 
 		if (addr->can_family != AF_CAN)
@@ -1569,7 +1569,7 @@ static int bcm_connect(struct socket *sock, struct sockaddr *uaddr, int len,
 	struct net *net = sock_net(sk);
 	int ret = 0;
 
-	if (len < required_size(can_ifindex, *addr))
+	if (len < REQUIRED_SIZE(*addr, can_ifindex))
 		return -EINVAL;
 
 	lock_sock(sk);
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 96e80a0..f79b844 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -23,7 +23,7 @@
 #include <linux/can/j1939.h>
 #include "j1939-priv.h"
 
-#define J1939_MIN_NAMELEN required_size(can_addr.j1939, struct sockaddr_can)
+#define J1939_MIN_NAMELEN REQUIRED_SIZE(struct sockaddr_can, can_addr.j1939)
 
 /* list of sockets */
 static struct list_head j1939_socks = LIST_HEAD_INIT(j1939_socks);
diff --git a/net/can/raw.c b/net/can/raw.c
index 23fd13b..4bf0046 100644
--- a/net/can/raw.c
+++ b/net/can/raw.c
@@ -397,7 +397,7 @@ static int raw_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 	int err = 0;
 	int notify_enetdown = 0;
 
-	if (len < required_size(can_ifindex, *addr))
+	if (len < REQUIRED_SIZE(*addr, can_ifindex))
 		return -EINVAL;
 	if (addr->can_family != AF_CAN)
 		return -EINVAL;
@@ -734,7 +734,7 @@ static int raw_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	if (msg->msg_name) {
 		DECLARE_SOCKADDR(struct sockaddr_can *, addr, msg->msg_name);
 
-		if (msg->msg_namelen < required_size(can_ifindex, *addr))
+		if (msg->msg_namelen < REQUIRED_SIZE(*addr, can_ifindex))
 			return -EINVAL;
 
 		if (addr->can_family != AF_CAN)
-- 
1.9.1


From bdeb97cde8a70c37ef0a123f7d9a543d512f761d Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Mon, 3 Oct 2016 14:02:42 +0200
Subject: [PATCH 046/113] j1939: clean up Makefile

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/Makefile | 16 +++++++---------
 1 file changed, 7 insertions(+), 9 deletions(-)

diff --git a/net/can/j1939/Makefile b/net/can/j1939/Makefile
index 77b6bfa..dda03af 100644
--- a/net/can/j1939/Makefile
+++ b/net/can/j1939/Makefile
@@ -1,12 +1,10 @@
+cppflags-$(CONFIG_CAN_J1939_DEBUG) += -DDEBUG
 
-obj-$(CONFIG_CAN_J1939)	+= can-j1939.o
+obj-$(CONFIG_CAN_J1939) += can-j1939.o
 
-can-j1939-objs := main.o \
+can-j1939-objs := \
+	address-claim.o \
 	bus.o \
-	address-claim.o transport.o \
-	socket.o
-
-ifeq ($(CONFIG_CAN_J1939_DEBUG),y)
-	EXTRA_CFLAGS += -DDEBUG
-endif
-
+	main.o \
+	socket.o \
+	transport.o
-- 
1.9.1


From 040394d0bbc8d78b35cfbd378a9bea5bae004cfb Mon Sep 17 00:00:00 2001
From: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Date: Thu, 6 Oct 2016 10:28:46 +0200
Subject: [PATCH 047/113] j1939: Pad TP data packets only

Padding regular PGN's should be done in userspace

Signed-off-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
---
 net/can/j1939/main.c      | 13 +------------
 net/can/j1939/transport.c |  5 +++++
 2 files changed, 6 insertions(+), 12 deletions(-)

diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 6092506..a167bc2 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -42,12 +42,6 @@
 #define CAN_FTR (sizeof(struct can_frame) - CAN_HDR - \
 		 sizeof(((struct can_frame *)0)->data))
 
-static unsigned int padding;
-
-module_param_named(padding, padding, uint, 0644);
-
-MODULE_PARM_DESC(padding, "Pad all packets to 8 bytes, and stuff with 0xff");
-
 /* lowest layer */
 static void j1939_can_recv(struct sk_buff *iskb, void *data)
 {
@@ -168,12 +162,7 @@ int j1939_send(struct sk_buff *skb)
 		canid |= ((skcb->pgn & 0x3ffff) << 8);
 
 	cf->can_id = canid;
-	if (padding) {
-		memset(cf->data + dlc, 0xff, 8 - dlc);
-		cf->can_dlc = 8;
-	} else {
-		cf->can_dlc = dlc;
-	}
+	cf->can_dlc = dlc;
 
 	return can_send(skb, 1);
  failed:
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index d2995fd..4c770ab 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -51,16 +51,19 @@
 static unsigned int max_packet_size = 1024 * 100;
 static unsigned int retry_ms = 20;
 static unsigned int packet_delay;
+static unsigned int padding;
 
 module_param_named(transport_burst_count, block, uint, 0644);
 module_param_named(transport_max_size, max_packet_size, uint, 0644);
 module_param_named(transport_retry_time, retry_ms, uint, 0644);
 module_param_named(transport_packet_delay, packet_delay, uint, 0644);
+module_param_named(transport_padding, padding, uint, 0644);
 
 MODULE_PARM_DESC(transport_burst_count, "Number of packets to send in burst between flow control (1..255, default 255)");
 MODULE_PARM_DESC(transport_max_size, "Maximum packet size (default 100k)");
 MODULE_PARM_DESC(transport_retry_time, "Packet retransmission timeout in msecs, used in case of buffer full. (default 20)");
 MODULE_PARM_DESC(transport_packet_delay, "Delay between packets to avoid buffer overruns (default 0)");
+MODULE_PARM_DESC(transport_padding, "Pad all data packets to 8 bytes, and stuff with 0xff");
 
 struct session {
 	struct list_head list;
@@ -392,6 +395,8 @@ static int j1939tp_tx_dat(struct sk_buff *related, int extd,
 
 	skdat = skb_put(skb, len);
 	memcpy(skdat, dat, len);
+	if (padding && len < 8)
+		memset(skb_put(skb, 8 - len), 0xff, 8 - len);
 	return j1939_send(skb);
 }
 
-- 
1.9.1


From f21c09ef6ba6b787f739ba410f5c2a5892b4ef3e Mon Sep 17 00:00:00 2001
From: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Date: Thu, 6 Oct 2016 12:20:00 +0200
Subject: [PATCH 048/113] j1939: change j1939 defaults to strict specification

Signed-off-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
---
 net/can/j1939/transport.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 4c770ab..f799f3b 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -48,10 +48,10 @@
 #define MAX_ETP_PACKET_SIZE (7 * 0x00ffffff)
 
 static unsigned int block = 255;
-static unsigned int max_packet_size = 1024 * 100;
+static unsigned int max_packet_size = MAX_ETP_PACKET_SIZE;
 static unsigned int retry_ms = 20;
 static unsigned int packet_delay;
-static unsigned int padding;
+static unsigned int padding = 1;
 
 module_param_named(transport_burst_count, block, uint, 0644);
 module_param_named(transport_max_size, max_packet_size, uint, 0644);
-- 
1.9.1


From 14b09909e1d10c9229adf71e53721e674b10b9be Mon Sep 17 00:00:00 2001
From: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Date: Thu, 6 Oct 2016 12:20:28 +0200
Subject: [PATCH 049/113] j1939: change module parameters to sysctl

Signed-off-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
---
 net/can/j1939/transport.c | 81 ++++++++++++++++++++++++++++++++++++++++-------
 1 file changed, 70 insertions(+), 11 deletions(-)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index f799f3b..854231b 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -53,17 +53,17 @@
 static unsigned int packet_delay;
 static unsigned int padding = 1;
 
-module_param_named(transport_burst_count, block, uint, 0644);
-module_param_named(transport_max_size, max_packet_size, uint, 0644);
-module_param_named(transport_retry_time, retry_ms, uint, 0644);
-module_param_named(transport_packet_delay, packet_delay, uint, 0644);
-module_param_named(transport_padding, padding, uint, 0644);
-
-MODULE_PARM_DESC(transport_burst_count, "Number of packets to send in burst between flow control (1..255, default 255)");
-MODULE_PARM_DESC(transport_max_size, "Maximum packet size (default 100k)");
-MODULE_PARM_DESC(transport_retry_time, "Packet retransmission timeout in msecs, used in case of buffer full. (default 20)");
-MODULE_PARM_DESC(transport_packet_delay, "Delay between packets to avoid buffer overruns (default 0)");
-MODULE_PARM_DESC(transport_padding, "Pad all data packets to 8 bytes, and stuff with 0xff");
+/* the limit values for sysctl */
+static int block_min = 1;
+static int block_max = 255;
+static int max_size_min = 8;
+static int max_size_max = MAX_ETP_PACKET_SIZE;
+static int retry_min = 1;
+static int retry_max = 1250;
+static int packet_delay_min = 0;
+static int packet_delay_max = 1250;
+static int padding_min = 0;
+static int padding_max = 1;
 
 struct session {
 	struct list_head list;
@@ -1421,11 +1421,69 @@ static int j1939tp_proc_open(struct inode *inode, struct file *file)
 	.release = single_release,
 };
 
+static struct ctl_table canj1939_sysctl_table[] = {
+	{
+		.procname	= "transport_burst_count",
+		.data		= &block,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &block_min,
+		.extra2		= &block_max,
+	},
+	{
+		.procname	= "transport_max_size",
+		.data		= &max_packet_size,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &max_size_min,
+		.extra2		= &max_size_max,
+	},
+	{
+		.procname	= "transport_retry_time",
+		.data		= &retry_ms,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &retry_min,
+		.extra2		= &retry_max,
+	},
+	{
+		.procname	= "transport_packet_delay",
+		.data		= &packet_delay,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &packet_delay_min,
+		.extra2		= &packet_delay_max,
+	},
+	{
+		.procname	= "transport_padding",
+		.data		= &padding,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &padding_min,
+		.extra2		= &padding_max,
+	},
+	{},
+};
+
+static struct ctl_table_header *sysctl_hdr;
+
 /* module init */
 int __init j1939tp_module_init(void)
 {
 	if (!proc_create("transport", 0444, j1939_procdir, &j1939tp_proc_ops))
 		return -ENOMEM;
+
+	sysctl_hdr = register_net_sysctl(&init_net, "net/can-j1939",
+					 canj1939_sysctl_table);
+	if (!sysctl_hdr) {
+		remove_proc_entry("transport", j1939_procdir);
+		return -ENOMEM;
+	}
 	return 0;
 }
 
@@ -1435,6 +1493,7 @@ void j1939tp_module_exit(void)
 
 	wake_up_all(&tp_wait);
 
+	unregister_net_sysctl_table(sysctl_hdr);
 	remove_proc_entry("transport", j1939_procdir);
 	sessionlist_lock();
 	list_for_each_entry_safe(session, saved, &tp_extsessionq, list) {
-- 
1.9.1


From 06a2782cdbc97b9ec6304be480e4f377be3358d1 Mon Sep 17 00:00:00 2001
From: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Date: Thu, 6 Oct 2016 13:31:07 +0200
Subject: [PATCH 050/113] j1939: add /proc/sys/ documentation

Signed-off-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
---
 Documentation/sysctl/net.txt | 46 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 46 insertions(+)

diff --git a/Documentation/sysctl/net.txt b/Documentation/sysctl/net.txt
index 28596e0..2385168 100644
--- a/Documentation/sysctl/net.txt
+++ b/Documentation/sysctl/net.txt
@@ -27,6 +27,7 @@ Table : Subdirectories in /proc/sys/net
  ipx       IPX                 token-ring IBM token ring
  bridge    Bridging            decnet     DEC net
  ipv6      IP version 6        tipc       TIPC
+ can-j1939 SAE J1939
 ..............................................................................
 
 1. /proc/sys/net/core - Network core options
@@ -382,3 +383,48 @@ originally may have been issued in the correct sequential order.
 If named_timeout is nonzero, failed topology updates will be placed on a defer
 queue until another event arrives that clears the error, or until the timeout
 expires. Value is in milliseconds.
+
+7. SAE J1939
+-------------------------------------------------------
+
+transport_burst_count
+---------------------
+
+This tunable controls how many fragments to receive in a burst for the transport
+protocol. The value must be between 1 and 255. Transport protocol is more
+efficient with higher values, therefore, the default is 255.
+
+transport_max_size
+------------------
+
+The kernel needs to allocate a buffer for each packet received with transport
+protocol, before it can decide that the packet is not needed locally.
+This tunable controls the maximum size for packets to allocate.
+Packets that are announced with a bigger size are not received, i.e. aborted
+for private transport protocol sessions, and ignored for broadcasted sessions.
+
+transport_retry_time
+--------------------
+
+After the first fragment of a transport protocol sessions has been sent, the
+subsequent fragments will be delivered to best effert, including a retry when
+recoverable failures pass.
+This parameter controls the time before a retry is attempted. The time is
+expressed in milliseconds.
+
+transport_packet_delay
+----------------------
+
+This parameter controls the time in milliseconds between outgoing fragments
+of a single transport protocol session. This is normally 0, which indicates
+as fast as possible. Slower ECU's on the bus may require a delay in order
+to keep up receiving fragments.
+
+transport_padding
+-----------------
+
+SAE J1939 requires transport protocol data fragments to fill all 8 bytes of
+the CAN frame, and to pad the unused bytes with 0xff.
+This parameters (default 1) allow to turn off (0) padding. The CAN frame's DLC
+is then adjusted. This increases effiency (a tiny bit), makes the packets on
+the wire easier to read, but break strict compliancy to the standard.
-- 
1.9.1


From c542a0ac7f76c80d63a707c74ff72ce7534c60d8 Mon Sep 17 00:00:00 2001
From: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Date: Thu, 6 Oct 2016 14:24:27 +0200
Subject: [PATCH 051/113] mailmap: update email address

This commit replaces my company's email address with a stable private
address.

Signed-off-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 .mailmap | 1 +
 1 file changed, 1 insertion(+)

diff --git a/.mailmap b/.mailmap
index 5273cfd..2c4956b 100644
--- a/.mailmap
+++ b/.mailmap
@@ -94,6 +94,7 @@ Koushik <raghavendra.koushik@neterion.com>
 Krzysztof Kozlowski <krzk@kernel.org> <k.kozlowski@samsung.com>
 Krzysztof Kozlowski <krzk@kernel.org> <k.kozlowski.k@gmail.com>
 Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
+<dev.kurt@vandijck-laurijssen.be> <kurt.van.dijck@eia.be>
 Leonid I Ananiev <leonid.i.ananiev@intel.com>
 Linas Vepstas <linas@austin.ibm.com>
 Linus Lssing <linus.luessing@c0d3.blue> <linus.luessing@web.de>
-- 
1.9.1


From adcabcfd7e63d11e18bfeb4914475fcfbf8c3280 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Fri, 3 Mar 2017 15:41:17 +0100
Subject: [PATCH 052/113] j1939: af_can: don't use void pointer for struct
 dev_rcv_lists::j1939_priv

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/af_can.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/can/af_can.h b/net/can/af_can.h
index 9c15cf9..0c5ee8c 100644
--- a/net/can/af_can.h
+++ b/net/can/af_can.h
@@ -73,7 +73,7 @@ struct can_dev_rcv_lists {
 	struct hlist_head rx_eff[CAN_EFF_RCV_ARRAY_SZ];
 	int entries;
 #ifdef CAN_J1939
-	void *j1939_priv;
+	struct j1939_priv *j1939_priv;
 #endif
 };
 
-- 
1.9.1


From 3ae912af2a2484634cb10550159508514229fb10 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Fri, 3 Mar 2017 16:32:14 +0100
Subject: [PATCH 053/113] j1939: core.h: remove obsolete netlink.h include

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 include/linux/can/core.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index 9e8bd80..17c92e3 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -16,7 +16,6 @@
 #include <linux/can.h>
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
-#include <net/rtnetlink.h>
 
 #define CAN_VERSION "20170425"
 
-- 
1.9.1


From 52363300c4dc74469cc6e04282b3b35cedfd7cd7 Mon Sep 17 00:00:00 2001
From: Maxime Jayat <maxime.jayat@mobile-devices.fr>
Date: Thu, 9 Mar 2017 10:33:04 +0100
Subject: [PATCH 054/113] j1939: fix ecu allocation at bad time

In _j1939_ecu_get_register, create_if_necessary was ignored, which
lead to memory corruption (because of a bad refcount) when rebinding a
socket to a NAME corresponding to an ecu which had been unregistered
by an external address claim.

During the bind, in j1939_name_local_put, the ecu was reallocated, added
to the list of ecus and then freed immediately. So the list contained an
invalid item.

For instance, this created the problem:

- Bind a J1939 socket to source address 0x80 with name
    0x7777777777777777
- Send an address claim for this source address
- Another "external" ECU sends an address claim for 0x80 with name
    0x1111111111111111 (which has higher priority, so "wins" the source
    address).
- Re-bind the J1939 socket to source address 0x81.

Signed-off-by: Maxime Jayat <maxime.jayat@mobile-devices.fr>
Acked-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/bus.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index 651de57..411f6b1 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -62,6 +62,10 @@ struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv, name_t name,
 		if (dut->name == name)
 			return dut;
 	}
+
+	if (!create_if_necessary)
+		return ERR_PTR(-ENODEV);
+
 	/* alloc */
 	ecu = kzalloc(sizeof(*ecu), gfp_any());
 	if (!ecu)
-- 
1.9.1


From 1e81e762f11b47ff6ae4b9617a9ed9bb7b110838 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Fri, 12 May 2017 16:43:50 +0200
Subject: [PATCH 055/113] j1939: address-claim: fix sparse warning

This patch fixes the following sparse warning:

net/can/j1939/address-claim.c:132:16: warning: incorrect type in argument 1 (different base types)
net/can/j1939/address-claim.c:132:16:    expected restricted __le64 const [usertype] *p
net/can/j1939/address-claim.c:132:16:    got unsigned long long [usertype] *<noident>

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/address-claim.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
index 4c16d9a..bb92938 100644
--- a/net/can/j1939/address-claim.c
+++ b/net/can/j1939/address-claim.c
@@ -28,7 +28,10 @@
 
 #include "j1939-priv.h"
 
-#define CANDATA2NAME(data) le64_to_cpup((uint64_t *)data)
+static inline name_t candata_to_name(const struct sk_buff *skb)
+{
+	return le64_to_cpup((__le64 *)skb->data);
+}
 
 static inline int ac_msg_is_request_for_ac(struct sk_buff *skb)
 {
@@ -52,7 +55,7 @@ static int j1939_verify_outgoing_address_claim(struct sk_buff *skb)
 		return -EPROTO;
 	}
 
-	if (skcb->srcname != CANDATA2NAME(skb->data)) {
+	if (skcb->srcname != candata_to_name(skb)) {
 		j1939_notice("tx address claim with different name\n");
 		return -EPROTO;
 	}
@@ -129,7 +132,7 @@ static void j1939_process_address_claim(struct sk_buff *skb)
 		return;
 	}
 
-	name = CANDATA2NAME(skb->data);
+	name = candata_to_name(skb);
 	skcb->srcname = name;
 	if (!name) {
 		j1939_notice("rx address claim without name\n");
-- 
1.9.1


From 5ac6aa0937afb28dd34aaa41ca426af6ac59bf29 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Mon, 15 May 2017 16:11:17 +0200
Subject: [PATCH 056/113] j1939: convert j1939_LEVEL() output to standard
 pr_LEVEL()

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/address-claim.c | 20 +++++++++++---------
 net/can/j1939/j1939-priv.h    | 16 ----------------
 net/can/j1939/socket.c        |  4 +++-
 3 files changed, 14 insertions(+), 26 deletions(-)

diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
index bb92938..afbaca5 100644
--- a/net/can/j1939/address-claim.c
+++ b/net/can/j1939/address-claim.c
@@ -23,6 +23,8 @@
  * this is the responsibility of a user space application or daemon.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/skbuff.h>
 #include <linux/byteorder/generic.h>
 
@@ -51,23 +53,23 @@ static int j1939_verify_outgoing_address_claim(struct sk_buff *skb)
 	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
 
 	if (skb->len != 8) {
-		j1939_notice("tx address claim with dlc %i\n", skb->len);
+		pr_notice("tx address claim with dlc %i\n", skb->len);
 		return -EPROTO;
 	}
 
 	if (skcb->srcname != candata_to_name(skb)) {
-		j1939_notice("tx address claim with different name\n");
+		pr_notice("tx address claim with different name\n");
 		return -EPROTO;
 	}
 
 	if (skcb->srcaddr == J1939_NO_ADDR) {
-		j1939_notice("tx address claim with broadcast sa\n");
+		pr_notice("tx address claim with broadcast sa\n");
 		return -EPROTO;
 	}
 
 	/* ac must always be a broadcast */
 	if (skcb->dstname || (skcb->dstaddr != J1939_NO_ADDR)) {
-		j1939_notice("tx address claim with dest, not broadcast\n");
+		pr_notice("tx address claim with dest, not broadcast\n");
 		return -EPROTO;
 	}
 	return 0;
@@ -100,7 +102,7 @@ int j1939_fixup_address_claim(struct sk_buff *skb)
 		sa = j1939_name_to_sa(skcb->srcname, skb->dev->ifindex);
 		if (!j1939_address_is_unicast(sa) &&
 		    !ac_msg_is_request_for_ac(skb)) {
-			j1939_notice("tx drop: invalid sa for name 0x%016llx\n",
+			pr_notice("tx drop: invalid sa for name 0x%016llx\n",
 				     skcb->srcname);
 			return -EADDRNOTAVAIL;
 		}
@@ -111,7 +113,7 @@ int j1939_fixup_address_claim(struct sk_buff *skb)
 	if (skcb->dstname) {
 		sa = j1939_name_to_sa(skcb->dstname, skb->dev->ifindex);
 		if (!j1939_address_is_unicast(sa)) {
-			j1939_notice("tx drop: invalid da for name 0x%016llx\n",
+			pr_notice("tx drop: invalid da for name 0x%016llx\n",
 				     skcb->dstname);
 			return -EADDRNOTAVAIL;
 		}
@@ -128,19 +130,19 @@ static void j1939_process_address_claim(struct sk_buff *skb)
 	name_t name;
 
 	if (skb->len != 8) {
-		j1939_notice("rx address claim with wrong dlc %i\n", skb->len);
+		pr_notice("rx address claim with wrong dlc %i\n", skb->len);
 		return;
 	}
 
 	name = candata_to_name(skb);
 	skcb->srcname = name;
 	if (!name) {
-		j1939_notice("rx address claim without name\n");
+		pr_notice("rx address claim without name\n");
 		return;
 	}
 
 	if (!j1939_address_is_valid(skcb->srcaddr)) {
-		j1939_notice("rx address claim with broadcast sa\n");
+		pr_notice("rx address claim with broadcast sa\n");
 		return;
 	}
 
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 3ae19cc..0fc2833 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -187,24 +187,8 @@ static inline void j1939_ecu_remove_sa(struct j1939_ecu *ecu)
 /* find_by_name, with kref & read_lock taken */
 struct j1939_ecu *j1939_ecu_find_priv_default_tx(int ifindex, name_t *pname,
 						 u8 *paddr);
-
 extern struct proc_dir_entry *j1939_procdir;
 
-/* j1939 printk */
-#define j1939_printk(level, ...) printk(level "J1939 " __VA_ARGS__)
-
-#define j1939_err(...)		j1939_printk(KERN_ERR, __VA_ARGS__)
-#define j1939_warning(...)	j1939_printk(KERN_WARNING, __VA_ARGS__)
-#define j1939_notice(...)	j1939_printk(KERN_NOTICE, __VA_ARGS__)
-#define j1939_info(...)		j1939_printk(KERN_INFO, __VA_ARGS__)
-#ifdef DEBUG
-#define j1939_debug(...)	j1939_printk(KERN_DEBUG, __VA_ARGS__)
-#else
-#define j1939_debug(...)
-#endif
-
-struct sk_buff;
-
 /* control buffer of the sk_buff */
 struct j1939_sk_buff_cb {
 	pgn_t pgn;
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index f79b844..824b898 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -10,6 +10,8 @@
  * as published by the Free Software Foundation
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -171,7 +173,7 @@ static void j1939sk_recv_skb(struct sk_buff *oskb, struct j1939_sock *jsk)
 
 	skb = skb_clone(oskb, GFP_ATOMIC);
 	if (!skb) {
-		j1939_warning("skb clone failed\n");
+		pr_warn("skb clone failed\n");
 		return;
 	}
 	skcb = (void *)skb->cb;
-- 
1.9.1


From b05376e7f9c6e7fe17c0822b1649a3a13ef8c0cf Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 1 Jun 2017 10:04:22 +0200
Subject: [PATCH 057/113] j1939: transport: j1939_skbcb_swap() make use of
 swap() instead of open coding it

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/transport.c | 18 +++---------------
 1 file changed, 3 insertions(+), 15 deletions(-)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 854231b..3b42517 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -346,21 +346,9 @@ static struct session *j1939tp_find(struct list_head *root,
 
 static void j1939_skbcb_swap(struct j1939_sk_buff_cb *cb)
 {
-	name_t name;
-	u8 addr;
-	int flags;
-
-	name = cb->dstname;
-	cb->dstname = cb->srcname;
-	cb->srcname = name;
-
-	addr = cb->dstaddr;
-	cb->dstaddr = cb->srcaddr;
-	cb->srcaddr = addr;
-
-	flags = cb->dstflags;
-	cb->dstflags = cb->srcflags;
-	cb->srcflags = flags;
+	swap(cb->dstname, cb->srcname);
+	swap(cb->dstaddr, cb->srcaddr);
+	swap(cb->dstflags, cb->srcflags);
 }
 
 /* TP transmit packet functions */
-- 
1.9.1


From d75d990db480599fe56d24ff9a76e7bfa3a9d11d Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 1 Jun 2017 11:09:32 +0200
Subject: [PATCH 058/113] j1939: introduce j1939_get_cb() and make use of it

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/address-claim.c | 10 +++++-----
 net/can/j1939/j1939-priv.h    |  7 +++++++
 net/can/j1939/main.c          |  6 ++----
 net/can/j1939/socket.c        |  8 ++++----
 net/can/j1939/transport.c     | 26 +++++++++++++-------------
 5 files changed, 31 insertions(+), 26 deletions(-)

diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
index afbaca5..931a534 100644
--- a/net/can/j1939/address-claim.c
+++ b/net/can/j1939/address-claim.c
@@ -37,7 +37,7 @@ static inline name_t candata_to_name(const struct sk_buff *skb)
 
 static inline int ac_msg_is_request_for_ac(struct sk_buff *skb)
 {
-	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *skcb = j1939_get_cb(skb);
 	int req_pgn;
 
 	if ((skb->len < 3) || (skcb->pgn != PGN_REQUEST))
@@ -50,7 +50,7 @@ static inline int ac_msg_is_request_for_ac(struct sk_buff *skb)
 
 static int j1939_verify_outgoing_address_claim(struct sk_buff *skb)
 {
-	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *skcb = j1939_get_cb(skb);
 
 	if (skb->len != 8) {
 		pr_notice("tx address claim with dlc %i\n", skb->len);
@@ -78,7 +78,7 @@ static int j1939_verify_outgoing_address_claim(struct sk_buff *skb)
 int j1939_fixup_address_claim(struct sk_buff *skb)
 {
 	int ret, sa;
-	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *skcb = j1939_get_cb(skb);
 
 	/* network mgmt: address claiming msgs */
 	if (skcb->pgn == PGN_ADDRESS_CLAIMED) {
@@ -124,7 +124,7 @@ int j1939_fixup_address_claim(struct sk_buff *skb)
 
 static void j1939_process_address_claim(struct sk_buff *skb)
 {
-	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *skcb = j1939_get_cb(skb);
 	struct j1939_ecu *ecu, *prev;
 	struct j1939_priv *priv;
 	name_t name;
@@ -192,7 +192,7 @@ static void j1939_process_address_claim(struct sk_buff *skb)
 
 void j1939_recv_address_claim(struct sk_buff *skb, struct j1939_priv *priv)
 {
-	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *skcb = j1939_get_cb(skb);
 	struct j1939_ecu *ecu;
 
 	/* network mgmt */
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 0fc2833..557d374 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -216,6 +216,13 @@ struct j1939_sk_buff_cb {
 	struct sock *insock;
 };
 
+static inline struct j1939_sk_buff_cb *j1939_get_cb(struct sk_buff *skb)
+{
+	BUILD_BUG_ON(sizeof(struct j1939_sk_buff_cb) > sizeof(skb->cb));
+
+	return (struct j1939_sk_buff_cb *)skb->cb;
+}
+
 #define J1939_MSG_RESERVED MSG_SYN
 #define J1939_MSG_SYNC MSG_SYN
 
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index a167bc2..c33c9bb 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -51,8 +51,6 @@ static void j1939_can_recv(struct sk_buff *iskb, void *data)
 	struct can_frame *cf;
 	struct addr_ent *paddr;
 
-	BUILD_BUG_ON(sizeof(*skcb) > sizeof(skb->cb));
-
 	/* create a copy of the skb
 	 * j1939 only delivers the real data bytes,
 	 * the header goes into sockaddr.
@@ -71,7 +69,7 @@ static void j1939_can_recv(struct sk_buff *iskb, void *data)
 	skb_trim(skb, min_t(uint8_t, cf->can_dlc, 8));
 
 	/* set addr */
-	skcb = (struct j1939_sk_buff_cb *)skb->cb;
+	skcb = j1939_get_cb(skb);
 	memset(skcb, 0, sizeof(*skcb));
 
 	/* save incoming socket, without assigning the skb to it */
@@ -125,7 +123,7 @@ int j1939_send(struct sk_buff *skb)
 {
 	int ret, dlc;
 	canid_t canid;
-	struct j1939_sk_buff_cb *skcb = (struct j1939_sk_buff_cb *)skb->cb;
+	struct j1939_sk_buff_cb *skcb = j1939_get_cb(skb);
 	struct can_frame *cf;
 
 	if (skb->len > 8)
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 824b898..95a873c6 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -136,7 +136,7 @@ static inline int packet_match(const struct j1939_sk_buff_cb *skcb,
 static void j1939sk_recv_skb(struct sk_buff *oskb, struct j1939_sock *jsk)
 {
 	struct sk_buff *skb;
-	struct j1939_sk_buff_cb *skcb = (void *)oskb->cb;
+	struct j1939_sk_buff_cb *skcb = j1939_get_cb(oskb);
 
 	if (!(jsk->state & (JSK_BOUND | JSK_CONNECTED)))
 		return;
@@ -176,7 +176,7 @@ static void j1939sk_recv_skb(struct sk_buff *oskb, struct j1939_sock *jsk)
 		pr_warn("skb clone failed\n");
 		return;
 	}
-	skcb = (void *)skb->cb;
+	skcb = j1939_get_cb(skb);
 	skcb->msg_flags &= ~(MSG_DONTROUTE | MSG_CONFIRM);
 	if (skcb->insock)
 		skcb->msg_flags |= MSG_DONTROUTE;
@@ -616,7 +616,7 @@ static int j1939sk_recvmsg(struct socket *sock, struct msghdr *msg,
 		return ret;
 	}
 
-	skcb = (void *)skb->cb;
+	skcb = j1939_get_cb(skb);
 	if (j1939_address_is_valid(skcb->dstaddr))
 		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_ADDR,
 			 sizeof(skcb->dstaddr), &skcb->dstaddr);
@@ -704,7 +704,7 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 
 	skb->dev = dev;
 
-	skcb = (void *)skb->cb;
+	skcb = j1939_get_cb(skb);
 	memset(skcb, 0, sizeof(*skcb));
 	skcb->msg_flags = msg->msg_flags;
 	skcb->srcname = jsk->addr.src;
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 3b42517..65efb33 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -218,7 +218,7 @@ static inline void sessionlist_unlock(void)
  */
 static inline int j1939tp_im_receiver(struct sk_buff *skb)
 {
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
 
 	return cb->dstflags & ECU_LOCAL;
 }
@@ -226,7 +226,7 @@ static inline int j1939tp_im_receiver(struct sk_buff *skb)
 /* see if we are sender */
 static inline int j1939tp_im_transmitter(struct sk_buff *skb)
 {
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
 
 	return cb->srcflags & ECU_LOCAL;
 }
@@ -239,7 +239,7 @@ static int j1939tp_im_involved(struct sk_buff *skb, int swap)
 
 static int j1939tp_im_involved_anydir(struct sk_buff *skb)
 {
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
 
 	return (cb->srcflags | cb->dstflags) & ECU_LOCAL;
 }
@@ -280,7 +280,7 @@ static inline unsigned int j1939etp_ctl_to_size(const u8 *dat)
 static int j1939tp_match(struct session *session, struct sk_buff *skb,
 			 int reverse)
 {
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
 
 	if (session->skb_iif != skb->skb_iif)
 		return 0;
@@ -376,7 +376,7 @@ static int j1939tp_tx_dat(struct sk_buff *related, int extd,
 	skb->ip_summed = related->ip_summed;
 
 	memcpy(skb->cb, related->cb, sizeof(skb->cb));
-	skb_cb = (void *)skb->cb;
+	skb_cb = j1939_get_cb(skb);
 	fix_cb(skb_cb);
 	/* fix pgn */
 	skb_cb->pgn = extd ? etp_pgn_dat : tp_pgn_dat;
@@ -414,7 +414,7 @@ static int j1939xtp_do_tx_ctl(struct sk_buff *related, int extd,
 	skb->ip_summed = related->ip_summed;
 
 	memcpy(skb->cb, related->cb, sizeof(skb->cb));
-	skb_cb = (void *)skb->cb;
+	skb_cb = j1939_get_cb(skb);
 	fix_cb(skb_cb);
 	if (swap_src_dst)
 		j1939_skbcb_swap(skb_cb);
@@ -562,7 +562,7 @@ static void _j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
 /* abort packets may come in 2 directions */
 static void j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
 {
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
 
 	pr_info("%s, pgn %05x\n", __func__, j1939xtp_ctl_to_pgn(skb->data));
 
@@ -601,7 +601,7 @@ static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd)
 /* abort packets may come in 2 directions */
 static inline void j1939xtp_rx_abort(struct sk_buff *skb, int extd)
 {
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
 
 	pr_info("%s %i, %05x\n", __func__, skb->skb_iif,
 		j1939xtp_ctl_to_pgn(skb->data));
@@ -701,7 +701,7 @@ static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
 
 static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 {
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
 	struct session *session;
 	int len;
 	const u8 *dat;
@@ -1141,7 +1141,7 @@ static int j1939session_insert(struct session *session)
 /* j1939 main intf */
 int j1939_send_transport(struct sk_buff *skb)
 {
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
 	struct session *session;
 	int ret;
 	struct j1939_priv *priv;
@@ -1218,7 +1218,7 @@ int j1939_send_transport(struct sk_buff *skb)
 
 int j1939_recv_transport(struct sk_buff *skb)
 {
-	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
 	const u8 *dat;
 
 	switch (cb->pgn) {
@@ -1302,7 +1302,7 @@ static struct session *j1939session_fresh_new(int size,
 	if (!skb)
 		return NULL;
 
-	cb = (void *)skb->cb;
+	cb = j1939_get_cb(skb);
 	memcpy(cb, rel_skb->cb, sizeof(*cb));
 	fix_cb(cb);
 	cb->pgn = pgn;
@@ -1331,7 +1331,7 @@ static struct session *j1939session_new(struct sk_buff *skb)
 	spin_lock_init(&session->lock);
 	session->skb = skb;
 
-	session->cb = (void *)session->skb->cb;
+	session->cb = j1939_get_cb(session->skb);
 	hrtimer_init(&session->txtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 	session->txtimer.function = j1939tp_txtimer;
 	hrtimer_init(&session->rxtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-- 
1.9.1


From 28845784379f0b34432966dac0c395398ca07701 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 1 Jun 2017 12:43:24 +0200
Subject: [PATCH 059/113] j1939: j1939-priv: use return type bool for boolean
 functions

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 557d374..e24cda8 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -140,23 +140,23 @@ static inline int j1939_to_sk_priority(int j1939_prio)
 	return 7 - j1939_prio;
 }
 
-static inline int j1939_address_is_valid(u8 sa)
+static inline bool j1939_address_is_valid(u8 sa)
 {
 	return sa != J1939_NO_ADDR;
 }
 
-static inline int j1939_address_is_unicast(u8 sa)
+static inline bool j1939_address_is_unicast(u8 sa)
 {
 	return sa <= SA_MAX_UNICAST;
 }
 
-static inline int pgn_is_pdu1(pgn_t pgn)
+static inline bool pgn_is_pdu1(pgn_t pgn)
 {
 	/* ignore dp & res bits for this */
 	return (pgn & 0xff00) < 0xf000;
 }
 
-static inline int pgn_is_valid(pgn_t pgn)
+static inline bool pgn_is_valid(pgn_t pgn)
 {
 	return pgn <= PGN_MAX;
 }
-- 
1.9.1


From 746fc5eb6e8ebb588076cddcc5a07a14744a92e1 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 1 Jun 2017 12:44:46 +0200
Subject: [PATCH 060/113] j1939: bus: use name_t instead of u64

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/bus.c        | 6 +++---
 net/can/j1939/j1939-priv.h | 6 +++---
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index 411f6b1..c246938 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -118,7 +118,7 @@ struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex)
 	return ecu;
 }
 
-int j1939_name_to_sa(u64 name, int ifindex)
+int j1939_name_to_sa(name_t name, int ifindex)
 {
 	struct j1939_ecu *ecu;
 	struct j1939_priv *priv;
@@ -205,7 +205,7 @@ void j1939_addr_local_put(struct j1939_priv *priv, int sa)
 	write_unlock_bh(&priv->lock);
 }
 
-void j1939_name_local_get(struct j1939_priv *priv, u64 name)
+void j1939_name_local_get(struct j1939_priv *priv, name_t name)
 {
 	struct j1939_ecu *ecu;
 
@@ -224,7 +224,7 @@ void j1939_name_local_get(struct j1939_priv *priv, u64 name)
 	write_unlock_bh(&priv->lock);
 }
 
-void j1939_name_local_put(struct j1939_priv *priv, u64 name)
+void j1939_name_local_put(struct j1939_priv *priv, name_t name)
 {
 	struct j1939_ecu *ecu;
 
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index e24cda8..0a3f0c8 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -119,8 +119,8 @@ static inline void get_j1939_priv(struct j1939_priv *dut)
 /* keep the cache of what is local */
 void j1939_addr_local_get(struct j1939_priv *priv, int sa);
 void j1939_addr_local_put(struct j1939_priv *priv, int sa);
-void j1939_name_local_get(struct j1939_priv *priv, u64 name);
-void j1939_name_local_put(struct j1939_priv *priv, u64 name);
+void j1939_name_local_get(struct j1939_priv *priv, name_t name);
+void j1939_name_local_put(struct j1939_priv *priv, name_t name);
 
 /* conversion function between (struct sock | struct sk_buff)->sk_priority
  * from linux and j1939 priority field
@@ -181,7 +181,7 @@ static inline void j1939_ecu_remove_sa(struct j1939_ecu *ecu)
 	write_unlock_bh(&ecu->priv->lock);
 }
 
-int j1939_name_to_sa(u64 name, int ifindex);
+int j1939_name_to_sa(name_t name, int ifindex);
 struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex);
 struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex);
 /* find_by_name, with kref & read_lock taken */
-- 
1.9.1


From 23a6c528580b7826ed6f4be29713356ab19e7ab4 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 1 Jun 2017 12:45:47 +0200
Subject: [PATCH 061/113] j1939: j1939-priv: remove unused defines

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 0a3f0c8..65c675e 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -55,8 +55,6 @@ struct j1939_ecu {
 	int nusers;
 };
 
-#define to_j1939_ecu(x) container_of((x), struct j1939_ecu, dev)
-
 struct j1939_priv {
 	struct list_head ecus;
 	/* local list entry in priv
@@ -101,8 +99,6 @@ struct j1939_priv {
 	int nusers;
 };
 
-#define to_j1939_priv(x) container_of((x), struct j1939_priv, dev)
-
 void put_j1939_ecu(struct j1939_ecu *ecu);
 void put_j1939_priv(struct j1939_priv *segment);
 
-- 
1.9.1


From d33d7919c7b3010be2f24fc82fdc056366240521 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 1 Jun 2017 12:46:11 +0200
Subject: [PATCH 062/113] j1939: j1939-priv: sort includes alphabetically

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 65c675e..083c27d 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -11,16 +11,16 @@
 #ifndef _J1939_PRIV_H_
 #define _J1939_PRIV_H_
 
+#include <linux/atomic.h>
+#include <linux/if_arp.h>
+#include <linux/interrupt.h>
 #include <linux/kref.h>
 #include <linux/list.h>
-#include <net/sock.h>
-
-#include <linux/proc_fs.h>
 #include <linux/module.h>
+#include <linux/proc_fs.h>
 #include <linux/can/j1939.h>
-#include <linux/atomic.h>
-#include <linux/interrupt.h>
-#include <linux/if_arp.h>
+
+#include <net/sock.h>
 
 #include "../af_can.h"
 
-- 
1.9.1


From 2260bf2b17c0c9a7e3b964d0f198f9ac5be6abdb Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 1 Jun 2017 12:58:00 +0200
Subject: [PATCH 063/113] j1939: socket: add J1939_SOCKET prefix to struct
 j1939_sock::state defines

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 34 +++++++++++++++++-----------------
 1 file changed, 17 insertions(+), 17 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 95a873c6..a33732d 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -37,10 +37,10 @@ struct j1939_sock {
 
 	int state;
 
-#define JSK_BOUND BIT(0)
-#define JSK_CONNECTED BIT(1)
-#define PROMISC BIT(2)
-#define RECV_OWN BIT(3)
+#define J1939_SOCK_BOUND BIT(0)
+#define J1939_SOCK_CONNECTED BIT(1)
+#define J1939_SOCK_PROMISC BIT(2)
+#define J1939_SOCK_RECV_OWN BIT(3)
 
 	int ifindex_started; /* ifindex of netdev */
 
@@ -138,13 +138,13 @@ static void j1939sk_recv_skb(struct sk_buff *oskb, struct j1939_sock *jsk)
 	struct sk_buff *skb;
 	struct j1939_sk_buff_cb *skcb = j1939_get_cb(oskb);
 
-	if (!(jsk->state & (JSK_BOUND | JSK_CONNECTED)))
+	if (!(jsk->state & (J1939_SOCK_BOUND | J1939_SOCK_CONNECTED)))
 		return;
 	if (jsk->sk.sk_bound_dev_if &&
 	    (jsk->sk.sk_bound_dev_if != oskb->skb_iif))
 		/* this socket does not take packets from this iface */
 		return;
-	if (!(jsk->state & PROMISC)) {
+	if (!(jsk->state & J1939_SOCK_PROMISC)) {
 		if (jsk->addr.src) {
 			/* reject message for other destinations */
 			if (skcb->dstname &&
@@ -164,7 +164,7 @@ static void j1939sk_recv_skb(struct sk_buff *oskb, struct j1939_sock *jsk)
 		}
 	}
 
-	if ((skcb->insock == &jsk->sk) && !(jsk->state & RECV_OWN))
+	if ((skcb->insock == &jsk->sk) && !(jsk->state & J1939_SOCK_RECV_OWN))
 		/* own message */
 		return;
 
@@ -305,12 +305,12 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 	if (pgn_is_valid(addr->can_addr.j1939.pgn))
 		jsk->addr.pgn = addr->can_addr.j1939.pgn;
 
-	if (!(jsk->state & (JSK_BOUND | JSK_CONNECTED))) {
+	if (!(jsk->state & (J1939_SOCK_BOUND | J1939_SOCK_CONNECTED))) {
 		spin_lock_bh(&j1939_socks_lock);
 		list_add_tail(&jsk->list, &j1939_socks);
 		spin_unlock_bh(&j1939_socks_lock);
 	}
-	jsk->state |= JSK_BOUND;
+	jsk->state |= J1939_SOCK_BOUND;
 
 	ret = 0;
 
@@ -386,12 +386,12 @@ static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
 	if (pgn_is_valid(addr->can_addr.j1939.pgn))
 		jsk->addr.pgn = addr->can_addr.j1939.pgn;
 
-	if (!(jsk->state & (JSK_BOUND | JSK_CONNECTED))) {
+	if (!(jsk->state & (J1939_SOCK_BOUND | J1939_SOCK_CONNECTED))) {
 		spin_lock_bh(&j1939_socks_lock);
 		list_add_tail(&jsk->list, &j1939_socks);
 		spin_unlock_bh(&j1939_socks_lock);
 	}
-	jsk->state |= JSK_CONNECTED;
+	jsk->state |= J1939_SOCK_CONNECTED;
 	ret = 0;
 
  fail_locked:
@@ -419,7 +419,7 @@ static int j1939sk_getname(struct socket *sock, struct sockaddr *uaddr,
 
 	lock_sock(sk);
 
-	if (peer && !(jsk->state & JSK_CONNECTED)) {
+	if (peer && !(jsk->state & J1939_SOCK_CONNECTED)) {
 		ret = -EADDRNOTAVAIL;
 		goto failure;
 	}
@@ -521,9 +521,9 @@ static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
 		kfree(ofilters);
 		return 0;
 	case SO_J1939_PROMISC:
-		return j1939sk_setsockopt_flag(jsk, optval, optlen, PROMISC);
+		return j1939sk_setsockopt_flag(jsk, optval, optlen, J1939_SOCK_PROMISC);
 	case SO_J1939_RECV_OWN:
-		return j1939sk_setsockopt_flag(jsk, optval, optlen, RECV_OWN);
+		return j1939sk_setsockopt_flag(jsk, optval, optlen, J1939_SOCK_RECV_OWN);
 	case SO_J1939_SEND_PRIO:
 		if (optlen != sizeof(tmp))
 			return -EINVAL;
@@ -563,10 +563,10 @@ static int j1939sk_getsockopt(struct socket *sock, int level, int optname,
 	lock_sock(&jsk->sk);
 	switch (optname) {
 	case SO_J1939_PROMISC:
-		tmp = (jsk->state & PROMISC) ? 1 : 0;
+		tmp = (jsk->state & J1939_SOCK_PROMISC) ? 1 : 0;
 		break;
 	case SO_J1939_RECV_OWN:
-		tmp = (jsk->state & RECV_OWN) ? 1 : 0;
+		tmp = (jsk->state & J1939_SOCK_RECV_OWN) ? 1 : 0;
 		break;
 	case SO_J1939_SEND_PRIO:
 		tmp = j1939_prio(jsk->sk.sk_priority);
@@ -659,7 +659,7 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	int ret;
 
 	/* various socket state tests */
-	if (!(jsk->state & JSK_BOUND))
+	if (!(jsk->state & J1939_SOCK_BOUND))
 		return -EBADFD;
 
 	ifindex = jsk->ifindex_started;
-- 
1.9.1


From a8f8f48ceb6e33374429ad37d87883cb4b57c4f8 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 1 Jun 2017 13:14:13 +0200
Subject: [PATCH 064/113] j1939: socket: j1939sk_setsockopt(): initialize
 filters and count

... so that we can get rid of the else branch.

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 7 ++-----
 1 file changed, 2 insertions(+), 5 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index a33732d..4390469 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -489,8 +489,8 @@ static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
 {
 	struct sock *sk = sock->sk;
 	struct j1939_sock *jsk = j1939_sk(sk);
-	int tmp, count;
-	struct j1939_filter *filters, *ofilters;
+	int tmp, count = 0;
+	struct j1939_filter *filters = NULL, *ofilters;
 
 	if (level != SOL_CAN_J1939)
 		return -EINVAL;
@@ -508,9 +508,6 @@ static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
 				kfree(filters);
 				return -EFAULT;
 			}
-		} else {
-			filters = NULL;
-			count = 0;
 		}
 
 		spin_lock_bh(&j1939_socks_lock);
-- 
1.9.1


From 1ebad757570a38859a8d775e06ba723f97174bef Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 1 Jun 2017 13:15:38 +0200
Subject: [PATCH 065/113] j1939: socket: j1939sk_setsockopt(): make use of
 memdup_user()

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 10 +++-------
 1 file changed, 3 insertions(+), 7 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 4390469..f1791e1 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -501,13 +501,9 @@ static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
 			if (optlen % sizeof(*filters) != 0)
 				return -EINVAL;
 			count = optlen / sizeof(*filters);
-			filters = kmalloc(optlen, GFP_KERNEL);
-			if (!filters)
-				return -ENOMEM;
-			if (copy_from_user(filters, optval, optlen)) {
-				kfree(filters);
-				return -EFAULT;
-			}
+			filters = memdup_user(optval, optlen);
+			if (IS_ERR(filters))
+				return PTR_ERR(filters);
 		}
 
 		spin_lock_bh(&j1939_socks_lock);
-- 
1.9.1


From 7e0af54704e4c0b8c269f32dd90066b4bbeab212 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 1 Jun 2017 13:16:10 +0200
Subject: [PATCH 066/113] j1939: socket: j1939sk_setsockopt(): limit number of
 filters to 512

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 include/uapi/linux/can/j1939.h | 2 ++
 net/can/j1939/socket.c         | 4 ++++
 2 files changed, 6 insertions(+)

diff --git a/include/uapi/linux/can/j1939.h b/include/uapi/linux/can/j1939.h
index 4d0d23e..6382f15 100644
--- a/include/uapi/linux/can/j1939.h
+++ b/include/uapi/linux/can/j1939.h
@@ -76,6 +76,8 @@ struct j1939_filter {
 	pgn_t pgn_mask;
 };
 
+#define J1939_FILTER_MAX 512 /* maximum number of j1939_filter set via setsockopt() */
+
 /* RTNETLINK */
 enum {
 	IFLA_J1939_UNSPEC,
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index f1791e1..58ef1cc 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -500,6 +500,10 @@ static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
 		if (optval) {
 			if (optlen % sizeof(*filters) != 0)
 				return -EINVAL;
+
+			if (optlen > J1939_FILTER_MAX * sizeof(struct j1939_filter))
+				return -EINVAL;
+
 			count = optlen / sizeof(*filters);
 			filters = memdup_user(optval, optlen);
 			if (IS_ERR(filters))
-- 
1.9.1


From dc0f65a983e93edb8c91ff313a5ec26920217aa2 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 1 Jun 2017 13:36:53 +0200
Subject: [PATCH 067/113] j1939: socket: use return type bool for boolean
 functions

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 58ef1cc..20faedb 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -101,7 +101,7 @@ void j1939_sock_pending_del(struct sock *sk)
 		wake_up(&jsk->waitq);	/* no pending SKB's */
 }
 
-static inline int j1939_no_address(const struct sock *sk)
+static inline bool j1939_no_address(const struct sock *sk)
 {
 	const struct j1939_sock *jsk = j1939_sk(sk);
 
@@ -109,12 +109,12 @@ static inline int j1939_no_address(const struct sock *sk)
 }
 
 /* matches skb control buffer (addr) with a j1939 filter */
-static inline int packet_match(const struct j1939_sk_buff_cb *skcb,
-			       const struct j1939_filter *f, int nfilter)
+static inline bool packet_match(const struct j1939_sk_buff_cb *skcb,
+				const struct j1939_filter *f, int nfilter)
 {
 	if (!nfilter)
 		/* receive all when no filters are assigned */
-		return 1;
+		return true;
 
 	/* Filters relying on the addr for static addressing _should_ get
 	 * packets from dynamic addressed ECU's too if they match their SA.
@@ -127,9 +127,9 @@ static inline int packet_match(const struct j1939_sk_buff_cb *skcb,
 			continue;
 		if ((skcb->srcname & f->name_mask) != (f->name & f->name_mask))
 			continue;
-		return 1;
+		return true;
 	}
-	return 0;
+	return false;
 }
 
 /* callback per socket, called from j1939_recv */
-- 
1.9.1


From 01dcbf40055633f0f99d0dea46a887018a1699ea Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 1 Jun 2017 22:08:53 +0200
Subject: [PATCH 068/113] j1939: transport: kfree_skb() does tolerate freeing
 of NULL skbs

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/transport.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 65efb33..93b2409 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -131,8 +131,7 @@ static inline struct list_head *sessionq(int extd)
 
 static inline void j1939session_destroy(struct session *session)
 {
-	if (session->skb)
-		kfree_skb(session->skb);
+	kfree_skb(session->skb);
 	hrtimer_cancel(&session->rxtimer);
 	hrtimer_cancel(&session->txtimer);
 	tasklet_disable(&session->rxtask);
-- 
1.9.1


From efaae6611d3df73a30f5da0fde0171cfb79b845d Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 1 Jun 2017 22:10:02 +0200
Subject: [PATCH 069/113] j1939: transport: j1939session_destroy() remove write
 only variable cnt

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/transport.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 93b2409..8e4ac7e0 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -143,7 +143,6 @@ static inline void j1939session_destroy(struct session *session)
 static void j1939tp_del_work(struct work_struct *work)
 {
 	struct session *session;
-	int cnt = 0;
 
 	do {
 		session = NULL;
@@ -157,7 +156,6 @@ static void j1939tp_del_work(struct work_struct *work)
 		list_del_init(&session->list);
 		spin_unlock_bh(&tp_dellock);
 		j1939session_destroy(session);
-		++cnt;
 	} while (1);
 }
 
-- 
1.9.1


From 43adb972cce42c26f864db59ce6fdbd4d3618d45 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sat, 29 Jul 2017 11:56:09 +0200
Subject: [PATCH 070/113] j1939: struct j1939_priv: move comment about ecu ptrs
 to the correct variable

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 083c27d..8f0b274 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -73,6 +73,11 @@ struct j1939_priv {
 
 	int ifindex;
 	struct net_device *netdev;
+
+	/* list of 256 ecu ptrs, that cache the claimed addresses.
+	 * also protected by the above lock
+	 * don't use directly, use j1939_ecu_set_address() instead
+	 */
 	struct addr_ent {
 		ktime_t rxtime;
 		struct j1939_ecu *ecu;
@@ -87,10 +92,6 @@ struct j1939_priv {
 	 */
 	struct tasklet_struct ac_task;
 
-	/* list of 256 ecu ptrs, that cache the claimed addresses.
-	 * also protected by the above lock
-	 * don't use directly, use j1939_ecu_set_address() instead
-	 */
 	struct kref kref;
 
 	/* ref counter that hold the number of active listeners.
-- 
1.9.1


From 09f77d079323e6c3114bda9e5d88558879e3bb3f Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sun, 30 Jul 2017 17:00:51 +0200
Subject: [PATCH 071/113] j1939: j1939_module_init: fix error handling

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/main.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index c33c9bb..b1cd587 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -423,7 +423,9 @@ static __init int j1939_module_init(void)
 	if (!j1939_procdir)
 		return -EINVAL;
 
-	register_netdevice_notifier(&j1939_netdev_notifier);
+	ret = register_netdevice_notifier(&j1939_netdev_notifier);
+	if (ret)
+		goto fail_notifier;
 
 	ret = can_proto_register(&j1939_can_proto);
 	if (ret < 0) {
@@ -440,7 +442,6 @@ static __init int j1939_module_init(void)
 		goto fail_name;
 	return 0;
 
-	remove_proc_entry("name", j1939_procdir);
  fail_name:
 	remove_proc_entry("addr", j1939_procdir);
  fail_addr:
@@ -449,6 +450,7 @@ static __init int j1939_module_init(void)
 	can_proto_unregister(&j1939_can_proto);
  fail_sk:
 	unregister_netdevice_notifier(&j1939_netdev_notifier);
+ fail_notifier:
 	proc_remove(j1939_procdir);
 	j1939_procdir = NULL;
 	return ret;
-- 
1.9.1


From 0c0657f53fa4edbeacbbbcc0df8a56e00e3ce2f7 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sun, 30 Jul 2017 17:01:19 +0200
Subject: [PATCH 072/113] j1939: j1939_netdev_notify: make use of
 netdev_notifier_info_to_dev

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index b1cd587..f258af2 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -309,7 +309,7 @@ void put_j1939_priv(struct j1939_priv *segment)
 static int j1939_netdev_notify(struct notifier_block *nb,
 			       unsigned long msg, void *data)
 {
-	struct net_device *netdev = (struct net_device *)data;
+	struct net_device *netdev = netdev_notifier_info_to_dev(data);
 
 	if (!net_eq(dev_net(netdev), &init_net))
 		return NOTIFY_DONE;
-- 
1.9.1


From 5c7d70fa6aed9128826dd526ba1d694ab5afd8f0 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sun, 30 Jul 2017 21:31:44 +0200
Subject: [PATCH 073/113] j1939: j1939_can_recv: use PGN_ADDRESS_CLAIMED
 instead of 0x0ee00

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index f258af2..48dbf210 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -92,7 +92,7 @@ static void j1939_can_recv(struct sk_buff *iskb, void *data)
 	if (j1939_address_is_unicast(skcb->srcaddr)) {
 		paddr = &priv->ents[skcb->srcaddr];
 		paddr->rxtime = ktime_get();
-		if (paddr->ecu && skcb->pgn != 0x0ee00)
+		if (paddr->ecu && skcb->pgn != PGN_ADDRESS_CLAIMED)
 			paddr->ecu->rxtime = paddr->rxtime;
 	}
 	write_unlock_bh(&priv->lock);
-- 
1.9.1


From ee4ce0b621c31a34d96134be177bbdb7a9261e84 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Wed, 2 Aug 2017 09:30:00 +0200
Subject: [PATCH 074/113] j1939: socket: removed unused header tcp_states

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 20faedb..67354a9 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -18,7 +18,6 @@
 #include <linux/socket.h>
 #include <linux/list.h>
 #include <linux/if_arp.h>
-#include <net/tcp_states.h>
 
 #include <linux/can/core.h>
 #include <linux/can/skb.h>
-- 
1.9.1


From eecec94071363078ee2a61a2776ff8ada64db5f0 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sun, 30 Jul 2017 21:32:17 +0200
Subject: [PATCH 075/113] j1939: j1939_priv_find: fix check if netdev is NULL

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 8f0b274..11b3c91 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -275,10 +275,11 @@ static inline struct j1939_priv *j1939_priv_find(int ifindex)
 	struct net_device *netdev;
 
 	netdev = dev_get_by_index(&init_net, ifindex);
-	priv = dev_j1939_priv(netdev);
+	if (!netdev)
+		return NULL;
 
-	if (netdev)
-		dev_put(netdev);
+	priv = dev_j1939_priv(netdev);
+	dev_put(netdev);
 
 	return priv;
 }
-- 
1.9.1


From 501bb570b16d46cff262c5a9ece16842b4def4c4 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Mon, 31 Jul 2017 00:31:07 +0200
Subject: [PATCH 076/113] j1939: dev_j1939_priv: fold in get_j1939_priv()

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 7 +------
 1 file changed, 1 insertion(+), 6 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 11b3c91..095e748 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -108,11 +108,6 @@ static inline void get_j1939_ecu(struct j1939_ecu *dut)
 	kref_get(&dut->kref);
 }
 
-static inline void get_j1939_priv(struct j1939_priv *dut)
-{
-	kref_get(&dut->kref);
-}
-
 /* keep the cache of what is local */
 void j1939_addr_local_get(struct j1939_priv *priv, int sa);
 void j1939_addr_local_put(struct j1939_priv *priv, int sa);
@@ -264,7 +259,7 @@ static inline struct j1939_priv *dev_j1939_priv(struct net_device *dev)
 	priv = can_ml_priv ? can_ml_priv->j1939_priv : NULL;
 
 	if (priv)
-		get_j1939_priv(priv);
+		kref_get(&priv->kref);
 
 	return priv;
 }
-- 
1.9.1


From 4e1fabbcdb1255684810f928e4c1063f7fea1b82 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Mon, 31 Jul 2017 00:45:23 +0200
Subject: [PATCH 077/113] j1939: rename {get,put}_j1939_priv ->
 j1939_priv_{get,put}

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/address-claim.c | 2 +-
 net/can/j1939/bus.c           | 6 +++---
 net/can/j1939/j1939-priv.h    | 6 +++---
 net/can/j1939/main.c          | 8 ++++----
 net/can/j1939/socket.c        | 8 ++++----
 net/can/j1939/transport.c     | 2 +-
 6 files changed, 16 insertions(+), 16 deletions(-)

diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
index 931a534..4607495 100644
--- a/net/can/j1939/address-claim.c
+++ b/net/can/j1939/address-claim.c
@@ -187,7 +187,7 @@ static void j1939_process_address_claim(struct sk_buff *skb)
 	ecu->rxtime = ktime_get();
  done:
 	write_unlock_bh(&priv->lock);
-	put_j1939_priv(priv);
+	j1939_priv_put(priv);
 }
 
 void j1939_recv_address_claim(struct sk_buff *skb, struct j1939_priv *priv)
diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index c246938..67e989e 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -114,7 +114,7 @@ struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex)
 	if (ecu)
 		get_j1939_ecu(ecu);
 	read_unlock_bh(&priv->lock);
-	put_j1939_priv(priv);
+	j1939_priv_put(priv);
 	return ecu;
 }
 
@@ -141,7 +141,7 @@ int j1939_name_to_sa(name_t name, int ifindex)
 		}
 	}
 	read_unlock_bh(&priv->lock);
-	put_j1939_priv(priv);
+	j1939_priv_put(priv);
 	return sa;
 }
 
@@ -178,7 +178,7 @@ struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex)
 	if (!priv)
 		return NULL;
 	ecu = _j1939_ecu_find_by_name(name, priv);
-	put_j1939_priv(priv);
+	j1939_priv_put(priv);
 	return ecu;
 }
 
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 095e748..83b8955 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -101,7 +101,7 @@ struct j1939_priv {
 };
 
 void put_j1939_ecu(struct j1939_ecu *ecu);
-void put_j1939_priv(struct j1939_priv *segment);
+void j1939_priv_put(struct j1939_priv *segment);
 
 static inline void get_j1939_ecu(struct j1939_ecu *dut)
 {
@@ -247,7 +247,7 @@ struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv,
 int j1939_netdev_start(struct net_device *);
 void j1939_netdev_stop(struct net_device *);
 
-static inline struct j1939_priv *dev_j1939_priv(struct net_device *dev)
+static inline struct j1939_priv *j1939_priv_get(struct net_device *dev)
 {
 	struct can_dev_rcv_lists *can_ml_priv;
 	struct j1939_priv *priv;
@@ -273,7 +273,7 @@ static inline struct j1939_priv *j1939_priv_find(int ifindex)
 	if (!netdev)
 		return NULL;
 
-	priv = dev_j1939_priv(netdev);
+	priv = j1939_priv_get(netdev);
 	dev_put(netdev);
 
 	return priv;
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 48dbf210..f6cf6ac 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -279,7 +279,7 @@ void j1939_netdev_stop(struct net_device *netdev)
 	j1939tp_rmdev_notifier(netdev);
 
 	/* final put */
-	put_j1939_priv(priv);
+	j1939_priv_put(priv);
 	dev_put(netdev);
 }
 
@@ -301,7 +301,7 @@ static void on_put_j1939_priv(struct kref *kref)
 	kfree(priv);
 }
 
-void put_j1939_priv(struct j1939_priv *segment)
+void j1939_priv_put(struct j1939_priv *segment)
 {
 	kref_put(&segment->kref, on_put_j1939_priv);
 }
@@ -345,7 +345,7 @@ static int j1939_proc_show_addr(struct seq_file *sqf, void *v)
 	seq_puts(sqf, "iface\tsa\t#users\n");
 	rcu_read_lock();
 	for_each_netdev_rcu(&init_net, netdev) {
-		priv = dev_j1939_priv(netdev);
+		priv = j1939_priv_get(netdev);
 		if (!priv)
 			continue;
 		read_lock_bh(&priv->lock);
@@ -370,7 +370,7 @@ static int j1939_proc_show_name(struct seq_file *sqf, void *v)
 	seq_puts(sqf, "iface\tname\tsa\t#users\n");
 	rcu_read_lock();
 	for_each_netdev_rcu(&init_net, netdev) {
-		priv = dev_j1939_priv(netdev);
+		priv = j1939_priv_get(netdev);
 		if (!priv)
 			continue;
 		read_lock_bh(&priv->lock);
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 67354a9..63f1542 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -282,7 +282,7 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 		priv = j1939_priv_find(jsk->ifindex_started);
 		j1939_name_local_get(priv, jsk->addr.src);
 		j1939_addr_local_get(priv, jsk->addr.sa);
-		put_j1939_priv(priv);
+		j1939_priv_put(priv);
 	}
 
 	jsk->sk.sk_bound_dev_if = bound_dev_if;
@@ -295,7 +295,7 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 		j1939_name_local_get(priv, addr->can_addr.j1939.name);
 		j1939_addr_local_put(priv, jsk->addr.sa);
 		j1939_addr_local_get(priv, addr->can_addr.j1939.addr);
-		put_j1939_priv(priv);
+		j1939_priv_put(priv);
 	}
 	jsk->addr.src = addr->can_addr.j1939.name;
 	jsk->addr.sa = addr->can_addr.j1939.addr;
@@ -372,7 +372,7 @@ static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
 		priv = j1939_priv_find(jsk->ifindex_started);
 		j1939_name_local_get(priv, jsk->addr.src);
 		j1939_addr_local_get(priv, jsk->addr.sa);
-		put_j1939_priv(priv);
+		j1939_priv_put(priv);
 	}
 
 	/* lookup destination */
@@ -450,7 +450,7 @@ static int j1939sk_release(struct socket *sock)
 		priv = j1939_priv_find(jsk->ifindex_started);
 		j1939_addr_local_put(priv, jsk->addr.sa);
 		j1939_name_local_put(priv, jsk->addr.src);
-		put_j1939_priv(priv);
+		j1939_priv_put(priv);
 
 		j1939_ifindex_stop(jsk->ifindex_started);
 	}
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 8e4ac7e0..bf3b16f 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -1169,7 +1169,7 @@ int j1939_send_transport(struct sk_buff *skb)
 	    (j1939_address_is_unicast(cb->dstaddr) &&
 	     priv->ents[cb->dstaddr].nusers))
 		cb->dstflags |= ECU_LOCAL;
-	put_j1939_priv(priv);
+	j1939_priv_put(priv);
 	/* src is always local, I'm sending ... */
 	cb->srcflags |= ECU_LOCAL;
 
-- 
1.9.1


From d8a191d34734b5ec8c7d355b8b25c113c9c80b2b Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Mon, 31 Jul 2017 00:47:43 +0200
Subject: [PATCH 078/113] j1939: proc: add missing j1939_put()

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/main.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index f6cf6ac..90b8d98 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -356,6 +356,7 @@ static int j1939_proc_show_addr(struct seq_file *sqf, void *v)
 				   netdev->name, j, priv->ents[j].nusers);
 		}
 		read_unlock_bh(&priv->lock);
+		j1939_priv_put(priv);
 	}
 	rcu_read_unlock();
 	return 0;
@@ -380,6 +381,7 @@ static int j1939_proc_show_name(struct seq_file *sqf, void *v)
 				   (priv->ents[ecu->sa].ecu == ecu) ? "" : "?",
 				   ecu->nusers);
 		read_unlock_bh(&priv->lock);
+		j1939_priv_put(priv);
 	}
 	rcu_read_unlock();
 	return 0;
-- 
1.9.1


From fef917f307b420f82e0331ad37d364f1201fb476 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Sun, 30 Jul 2017 16:53:45 +0200
Subject: [PATCH 079/113] j1939: move j1939_priv into can_ml_priv

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 include/linux/can/can-ml.h | 3 +++
 net/can/af_can.h           | 3 ---
 net/can/j1939/j1939-priv.h | 5 +++--
 net/can/j1939/main.c       | 4 ++--
 4 files changed, 8 insertions(+), 7 deletions(-)

diff --git a/include/linux/can/can-ml.h b/include/linux/can/can-ml.h
index 2786b04..9861946 100644
--- a/include/linux/can/can-ml.h
+++ b/include/linux/can/can-ml.h
@@ -18,6 +18,9 @@
 
 struct can_ml_priv {
 	struct can_dev_rcv_lists dev_rcv_lists;
+#ifdef CAN_J1939
+	struct j1939_priv *j1939_priv;
+#endif
 };
 
 #endif /* CAN_ML_H */
diff --git a/net/can/af_can.h b/net/can/af_can.h
index 0c5ee8c..dc198a0 100644
--- a/net/can/af_can.h
+++ b/net/can/af_can.h
@@ -72,9 +72,6 @@ struct can_dev_rcv_lists {
 	struct hlist_head rx_sff[CAN_SFF_RCV_ARRAY_SZ];
 	struct hlist_head rx_eff[CAN_EFF_RCV_ARRAY_SZ];
 	int entries;
-#ifdef CAN_J1939
-	struct j1939_priv *j1939_priv;
-#endif
 };
 
 /* statistic structures */
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 83b8955..bb321db 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -18,6 +18,7 @@
 #include <linux/list.h>
 #include <linux/module.h>
 #include <linux/proc_fs.h>
+#include <linux/can/can-ml.h>
 #include <linux/can/j1939.h>
 
 #include <net/sock.h>
@@ -249,14 +250,14 @@ struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv,
 
 static inline struct j1939_priv *j1939_priv_get(struct net_device *dev)
 {
-	struct can_dev_rcv_lists *can_ml_priv;
+	struct can_ml_priv *can_ml_priv;
 	struct j1939_priv *priv;
 
 	if (dev->type != ARPHRD_CAN)
 		return NULL;
 
 	can_ml_priv = dev->ml_priv;
-	priv = can_ml_priv ? can_ml_priv->j1939_priv : NULL;
+	priv = can_ml_priv->j1939_priv;
 
 	if (priv)
 		kref_get(&priv->kref);
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 90b8d98..4bb9428 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -204,7 +204,7 @@ int j1939_netdev_start(struct net_device *netdev)
 {
 	int ret;
 	struct j1939_priv *priv;
-	struct can_dev_rcv_lists *can_ml_priv;
+	struct can_ml_priv *can_ml_priv;
 
 	if (netdev->type != ARPHRD_CAN)
 		return -EAFNOSUPPORT;
@@ -252,7 +252,7 @@ int j1939_netdev_start(struct net_device *netdev)
 
 void j1939_netdev_stop(struct net_device *netdev)
 {
-	struct can_dev_rcv_lists *can_ml_priv;
+	struct can_ml_priv *can_ml_priv;
 	struct j1939_priv *priv;
 
 	if (netdev->type != ARPHRD_CAN)
-- 
1.9.1


From c642e1d9d70d3972262c73b9e684d726d001d3b3 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 15 Aug 2017 16:27:00 +0200
Subject: [PATCH 080/113] j1939: can.h: add some spaces and newlines for
 readability

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 include/uapi/linux/can.h | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/include/uapi/linux/can.h b/include/uapi/linux/can.h
index 270ea3a..6a3e1c4 100644
--- a/include/uapi/linux/can.h
+++ b/include/uapi/linux/can.h
@@ -181,15 +181,16 @@ struct sockaddr_can {
 		struct {
 			/* 8 byte name when using dynamic addressing */
 			__u64 name;
+
 			/* pgn:
-			 * 8bit: PS in PDU2 case, else 0
-			 * 8bit: PF
-			 * 1bit: DP
-			 * 1bit: reserved
+			 * 8 bit: PS in PDU2 case, else 0
+			 * 8 bit: PF
+			 * 1 bit: DP
+			 * 1 bit: reserved
 			 */
 			__u32 pgn;
 
-			/* 1byte address */
+			/* 1 byte address */
 			__u8 addr;
 		} j1939;
 
-- 
1.9.1


From 30bf8cc9521ca377c808ec6bfe7cc7092f8b4e5f Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 15 Aug 2017 16:27:47 +0200
Subject: [PATCH 081/113] j1939: bus: j1939_addr_local_{get, put} use u8
 instead of int for address

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/bus.c        | 4 ++--
 net/can/j1939/j1939-priv.h | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index 67e989e..966695a 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -187,7 +187,7 @@ struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex)
  * These functions originate from userspace manipulating sockets,
  * so locking is straigforward
  */
-void j1939_addr_local_get(struct j1939_priv *priv, int sa)
+void j1939_addr_local_get(struct j1939_priv *priv, u8 sa)
 {
 	if (!j1939_address_is_unicast(sa))
 		return;
@@ -196,7 +196,7 @@ void j1939_addr_local_get(struct j1939_priv *priv, int sa)
 	write_unlock_bh(&priv->lock);
 }
 
-void j1939_addr_local_put(struct j1939_priv *priv, int sa)
+void j1939_addr_local_put(struct j1939_priv *priv, u8 sa)
 {
 	if (!j1939_address_is_unicast(sa))
 		return;
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index bb321db..6207ed0 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -110,8 +110,8 @@ static inline void get_j1939_ecu(struct j1939_ecu *dut)
 }
 
 /* keep the cache of what is local */
-void j1939_addr_local_get(struct j1939_priv *priv, int sa);
-void j1939_addr_local_put(struct j1939_priv *priv, int sa);
+void j1939_addr_local_get(struct j1939_priv *priv, u8 sa);
+void j1939_addr_local_put(struct j1939_priv *priv, u8 sa);
 void j1939_name_local_get(struct j1939_priv *priv, name_t name);
 void j1939_name_local_put(struct j1939_priv *priv, name_t name);
 
-- 
1.9.1


From 07e383d36fdb3edbf2f55060612d8df753b0df88 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 15 Aug 2017 18:19:43 +0200
Subject: [PATCH 082/113] j1939: rename j1939_priv_find() ->
 j1939_priv_get_by_ifindex()

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/address-claim.c | 2 +-
 net/can/j1939/bus.c           | 6 +++---
 net/can/j1939/j1939-priv.h    | 2 +-
 net/can/j1939/socket.c        | 8 ++++----
 net/can/j1939/transport.c     | 2 +-
 5 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
index 4607495..82414b7 100644
--- a/net/can/j1939/address-claim.c
+++ b/net/can/j1939/address-claim.c
@@ -146,7 +146,7 @@ static void j1939_process_address_claim(struct sk_buff *skb)
 		return;
 	}
 
-	priv = j1939_priv_find(skb->skb_iif);
+	priv = j1939_priv_get_by_ifindex(skb->skb_iif);
 	if (!priv)
 		return;
 
diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index 966695a..3f6a5ec 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -106,7 +106,7 @@ struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex)
 
 	if (!j1939_address_is_unicast(sa))
 		return NULL;
-	priv = j1939_priv_find(ifindex);
+	priv = j1939_priv_get_by_ifindex(ifindex);
 	if (!priv)
 		return NULL;
 	read_lock_bh(&priv->lock);
@@ -126,7 +126,7 @@ int j1939_name_to_sa(name_t name, int ifindex)
 
 	if (!name)
 		return J1939_NO_ADDR;
-	priv = j1939_priv_find(ifindex);
+	priv = j1939_priv_get_by_ifindex(ifindex);
 	if (!priv)
 		return J1939_NO_ADDR;
 
@@ -174,7 +174,7 @@ struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex)
 		return NULL;
 	if (!ifindex)
 		return NULL;
-	priv = j1939_priv_find(ifindex);
+	priv = j1939_priv_get_by_ifindex(ifindex);
 	if (!priv)
 		return NULL;
 	ecu = _j1939_ecu_find_by_name(name, priv);
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 6207ed0..dea2e98 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -265,7 +265,7 @@ static inline struct j1939_priv *j1939_priv_get(struct net_device *dev)
 	return priv;
 }
 
-static inline struct j1939_priv *j1939_priv_find(int ifindex)
+static inline struct j1939_priv *j1939_priv_get_by_ifindex(int ifindex)
 {
 	struct j1939_priv *priv;
 	struct net_device *netdev;
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 63f1542..4dd3d6d 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -279,7 +279,7 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 		if (ret < 0)
 			goto fail_locked;
 		jsk->ifindex_started = bound_dev_if;
-		priv = j1939_priv_find(jsk->ifindex_started);
+		priv = j1939_priv_get_by_ifindex(jsk->ifindex_started);
 		j1939_name_local_get(priv, jsk->addr.src);
 		j1939_addr_local_get(priv, jsk->addr.sa);
 		j1939_priv_put(priv);
@@ -289,7 +289,7 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 
 	/* set addr + name */
 	if (jsk->ifindex_started) {
-		priv = j1939_priv_find(jsk->ifindex_started);
+		priv = j1939_priv_get_by_ifindex(jsk->ifindex_started);
 		/* priv should be set when ifindex_started is nonzero */
 		j1939_name_local_put(priv, jsk->addr.src);
 		j1939_name_local_get(priv, addr->can_addr.j1939.name);
@@ -369,7 +369,7 @@ static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
 			goto fail_locked;
 		jsk->ifindex_started = bound_dev_if;
 		/* make sure that this is in sync */
-		priv = j1939_priv_find(jsk->ifindex_started);
+		priv = j1939_priv_get_by_ifindex(jsk->ifindex_started);
 		j1939_name_local_get(priv, jsk->addr.src);
 		j1939_addr_local_get(priv, jsk->addr.sa);
 		j1939_priv_put(priv);
@@ -447,7 +447,7 @@ static int j1939sk_release(struct socket *sock)
 	spin_unlock_bh(&j1939_socks_lock);
 
 	if (jsk->ifindex_started) {
-		priv = j1939_priv_find(jsk->ifindex_started);
+		priv = j1939_priv_get_by_ifindex(jsk->ifindex_started);
 		j1939_addr_local_put(priv, jsk->addr.sa);
 		j1939_name_local_put(priv, jsk->addr.src);
 		j1939_priv_put(priv);
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index bf3b16f..86bd49f 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -1162,7 +1162,7 @@ int j1939_send_transport(struct sk_buff *skb)
 		return ret;
 
 	/* fix dstflags, it may be used there soon */
-	priv = j1939_priv_find(can_skb_prv(skb)->ifindex);
+	priv = j1939_priv_get_by_ifindex(can_skb_prv(skb)->ifindex);
 	if (!priv)
 		return -EINVAL;
 	if (!j1939_address_is_valid(cb->dstaddr) ||
-- 
1.9.1


From 97a8e7119c84110ba039b4f53f10a896b38f8972 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Wed, 16 Aug 2017 13:12:57 +0200
Subject: [PATCH 083/113] j1939: priv: introduce struct j1939_addr

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index dea2e98..e9ff2ea 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -182,6 +182,15 @@ struct j1939_ecu *j1939_ecu_find_priv_default_tx(int ifindex, name_t *pname,
 						 u8 *paddr);
 extern struct proc_dir_entry *j1939_procdir;
 
+struct j1939_addr {
+	name_t src_name;
+	name_t dst_name;
+	pgn_t pgn;
+
+	u8 sa;
+	u8 da;
+};
+
 /* control buffer of the sk_buff */
 struct j1939_sk_buff_cb {
 	pgn_t pgn;
-- 
1.9.1


From dbeefb5c490f29f73ba9c7ae7239fac88b6cac54 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Wed, 16 Aug 2017 13:20:31 +0200
Subject: [PATCH 084/113] j1939: socket: use struct j1939_addr for struct
 j1939_sock::addr

The conversion is done with:

sed -i \
	-e "s/addr\.src/addr.src_name/g" \
	-e "s/addr\.dst/addr.dst_name/g" \
	net/can/j1939/*.[ch]

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 35 ++++++++++++++---------------------
 1 file changed, 14 insertions(+), 21 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 4dd3d6d..913a594 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -43,14 +43,7 @@ struct j1939_sock {
 
 	int ifindex_started; /* ifindex of netdev */
 
-	struct {
-		name_t src;
-		name_t dst;
-		pgn_t pgn;
-
-		u8 sa, da;
-	} addr;
-
+	struct j1939_addr addr;
 	struct j1939_filter *filters;
 	int nfilters;
 
@@ -104,7 +97,7 @@ static inline bool j1939_no_address(const struct sock *sk)
 {
 	const struct j1939_sock *jsk = j1939_sk(sk);
 
-	return (jsk->addr.sa == J1939_NO_ADDR) && !jsk->addr.src;
+	return (jsk->addr.sa == J1939_NO_ADDR) && !jsk->addr.src_name;
 }
 
 /* matches skb control buffer (addr) with a j1939 filter */
@@ -144,10 +137,10 @@ static void j1939sk_recv_skb(struct sk_buff *oskb, struct j1939_sock *jsk)
 		/* this socket does not take packets from this iface */
 		return;
 	if (!(jsk->state & J1939_SOCK_PROMISC)) {
-		if (jsk->addr.src) {
+		if (jsk->addr.src_name) {
 			/* reject message for other destinations */
 			if (skcb->dstname &&
-			    (skcb->dstname != jsk->addr.src))
+			    (skcb->dstname != jsk->addr.src_name))
 				/* the msg is not destined for the name
 				 * that the socket is bound to
 				 */
@@ -280,7 +273,7 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 			goto fail_locked;
 		jsk->ifindex_started = bound_dev_if;
 		priv = j1939_priv_get_by_ifindex(jsk->ifindex_started);
-		j1939_name_local_get(priv, jsk->addr.src);
+		j1939_name_local_get(priv, jsk->addr.src_name);
 		j1939_addr_local_get(priv, jsk->addr.sa);
 		j1939_priv_put(priv);
 	}
@@ -291,13 +284,13 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 	if (jsk->ifindex_started) {
 		priv = j1939_priv_get_by_ifindex(jsk->ifindex_started);
 		/* priv should be set when ifindex_started is nonzero */
-		j1939_name_local_put(priv, jsk->addr.src);
+		j1939_name_local_put(priv, jsk->addr.src_name);
 		j1939_name_local_get(priv, addr->can_addr.j1939.name);
 		j1939_addr_local_put(priv, jsk->addr.sa);
 		j1939_addr_local_get(priv, addr->can_addr.j1939.addr);
 		j1939_priv_put(priv);
 	}
-	jsk->addr.src = addr->can_addr.j1939.name;
+	jsk->addr.src_name = addr->can_addr.j1939.name;
 	jsk->addr.sa = addr->can_addr.j1939.addr;
 
 	/* set default transmit pgn */
@@ -370,13 +363,13 @@ static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
 		jsk->ifindex_started = bound_dev_if;
 		/* make sure that this is in sync */
 		priv = j1939_priv_get_by_ifindex(jsk->ifindex_started);
-		j1939_name_local_get(priv, jsk->addr.src);
+		j1939_name_local_get(priv, jsk->addr.src_name);
 		j1939_addr_local_get(priv, jsk->addr.sa);
 		j1939_priv_put(priv);
 	}
 
 	/* lookup destination */
-	jsk->addr.dst = addr->can_addr.j1939.name;
+	jsk->addr.dst_name = addr->can_addr.j1939.name;
 	jsk->addr.da = addr->can_addr.j1939.addr;
 
 	/* start assigning, no problem can occur at this point anymore */
@@ -403,7 +396,7 @@ static void j1939sk_sock2sockaddr_can(struct sockaddr_can *addr,
 {
 	addr->can_family = AF_CAN;
 	addr->can_ifindex = jsk->sk.sk_bound_dev_if;
-	addr->can_addr.j1939.name = peer ? jsk->addr.dst : jsk->addr.src;
+	addr->can_addr.j1939.name = peer ? jsk->addr.dst_name : jsk->addr.src_name;
 	addr->can_addr.j1939.pgn = jsk->addr.pgn;
 	addr->can_addr.j1939.addr = peer ? jsk->addr.da : jsk->addr.sa;
 }
@@ -449,7 +442,7 @@ static int j1939sk_release(struct socket *sock)
 	if (jsk->ifindex_started) {
 		priv = j1939_priv_get_by_ifindex(jsk->ifindex_started);
 		j1939_addr_local_put(priv, jsk->addr.sa);
-		j1939_name_local_put(priv, jsk->addr.src);
+		j1939_name_local_put(priv, jsk->addr.src_name);
 		j1939_priv_put(priv);
 
 		j1939_ifindex_stop(jsk->ifindex_started);
@@ -662,7 +655,7 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	if (!ifindex)
 		return -EBADFD;
 
-	if (jsk->addr.sa == J1939_NO_ADDR && !jsk->addr.src)
+	if (jsk->addr.sa == J1939_NO_ADDR && !jsk->addr.src_name)
 		/* no address assigned yet */
 		return -EBADFD;
 
@@ -703,8 +696,8 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	skcb = j1939_get_cb(skb);
 	memset(skcb, 0, sizeof(*skcb));
 	skcb->msg_flags = msg->msg_flags;
-	skcb->srcname = jsk->addr.src;
-	skcb->dstname = jsk->addr.dst;
+	skcb->srcname = jsk->addr.src_name;
+	skcb->dstname = jsk->addr.dst_name;
 	skcb->pgn = jsk->addr.pgn;
 	skcb->priority = j1939_prio(jsk->sk.sk_priority);
 	skcb->srcaddr = jsk->addr.sa;
-- 
1.9.1


From 556ae1772cd2eb7b0a24d64380f0d5dbd26f2427 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Wed, 16 Aug 2017 13:26:14 +0200
Subject: [PATCH 085/113] j1939: use struct j1939_addr in struct
 j1939_sk_buff_cb

The conversion is done with:

sed -i \
	-e "s/cb->pgn/cb->addr.pgn/g" \
	-e "s/cb->\(src\|dst\)name/cb->addr.\1_name/g" \
	-e "s/cb->srcaddr/cb->addr.sa/g" \
	-e "s/cb->dstaddr/cb->addr.da/g" \
	net/can/j1939/*.[ch]

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/address-claim.c | 56 +++++++++++++--------------
 net/can/j1939/j1939-priv.h    |  8 +---
 net/can/j1939/main.c          | 40 ++++++++++----------
 net/can/j1939/socket.c        | 46 +++++++++++-----------
 net/can/j1939/transport.c     | 88 +++++++++++++++++++++----------------------
 5 files changed, 117 insertions(+), 121 deletions(-)

diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
index 82414b7..d136b26 100644
--- a/net/can/j1939/address-claim.c
+++ b/net/can/j1939/address-claim.c
@@ -40,7 +40,7 @@ static inline int ac_msg_is_request_for_ac(struct sk_buff *skb)
 	struct j1939_sk_buff_cb *skcb = j1939_get_cb(skb);
 	int req_pgn;
 
-	if ((skb->len < 3) || (skcb->pgn != PGN_REQUEST))
+	if ((skb->len < 3) || (skcb->addr.pgn != PGN_REQUEST))
 		return 0;
 
 	req_pgn = skb->data[0] | (skb->data[1] << 8) | (skb->data[2] << 16);
@@ -57,18 +57,18 @@ static int j1939_verify_outgoing_address_claim(struct sk_buff *skb)
 		return -EPROTO;
 	}
 
-	if (skcb->srcname != candata_to_name(skb)) {
+	if (skcb->addr.src_name != candata_to_name(skb)) {
 		pr_notice("tx address claim with different name\n");
 		return -EPROTO;
 	}
 
-	if (skcb->srcaddr == J1939_NO_ADDR) {
+	if (skcb->addr.sa == J1939_NO_ADDR) {
 		pr_notice("tx address claim with broadcast sa\n");
 		return -EPROTO;
 	}
 
 	/* ac must always be a broadcast */
-	if (skcb->dstname || (skcb->dstaddr != J1939_NO_ADDR)) {
+	if (skcb->addr.dst_name || (skcb->addr.da != J1939_NO_ADDR)) {
 		pr_notice("tx address claim with dest, not broadcast\n");
 		return -EPROTO;
 	}
@@ -81,43 +81,43 @@ int j1939_fixup_address_claim(struct sk_buff *skb)
 	struct j1939_sk_buff_cb *skcb = j1939_get_cb(skb);
 
 	/* network mgmt: address claiming msgs */
-	if (skcb->pgn == PGN_ADDRESS_CLAIMED) {
+	if (skcb->addr.pgn == PGN_ADDRESS_CLAIMED) {
 		struct j1939_ecu *ecu;
 
 		ret = j1939_verify_outgoing_address_claim(skb);
 		/* return both when failure & when successful */
 		if (ret < 0)
 			return ret;
-		ecu = j1939_ecu_find_by_name(skcb->srcname,
+		ecu = j1939_ecu_find_by_name(skcb->addr.src_name,
 					     skb->dev->ifindex);
 		if (!ecu)
 			return -ENODEV;
 
-		if (ecu->sa != skcb->srcaddr)
+		if (ecu->sa != skcb->addr.sa)
 			/* hold further traffic for ecu, remove from parent */
 			j1939_ecu_remove_sa(ecu);
 		put_j1939_ecu(ecu);
-	} else if (skcb->srcname) {
+	} else if (skcb->addr.src_name) {
 		/* assign source address */
-		sa = j1939_name_to_sa(skcb->srcname, skb->dev->ifindex);
+		sa = j1939_name_to_sa(skcb->addr.src_name, skb->dev->ifindex);
 		if (!j1939_address_is_unicast(sa) &&
 		    !ac_msg_is_request_for_ac(skb)) {
 			pr_notice("tx drop: invalid sa for name 0x%016llx\n",
-				     skcb->srcname);
+				     skcb->addr.src_name);
 			return -EADDRNOTAVAIL;
 		}
-		skcb->srcaddr = sa;
+		skcb->addr.sa = sa;
 	}
 
 	/* assign destination address */
-	if (skcb->dstname) {
-		sa = j1939_name_to_sa(skcb->dstname, skb->dev->ifindex);
+	if (skcb->addr.dst_name) {
+		sa = j1939_name_to_sa(skcb->addr.dst_name, skb->dev->ifindex);
 		if (!j1939_address_is_unicast(sa)) {
 			pr_notice("tx drop: invalid da for name 0x%016llx\n",
-				     skcb->dstname);
+				     skcb->addr.dst_name);
 			return -EADDRNOTAVAIL;
 		}
-		skcb->dstaddr = sa;
+		skcb->addr.da = sa;
 	}
 	return 0;
 }
@@ -135,13 +135,13 @@ static void j1939_process_address_claim(struct sk_buff *skb)
 	}
 
 	name = candata_to_name(skb);
-	skcb->srcname = name;
+	skcb->addr.src_name = name;
 	if (!name) {
 		pr_notice("rx address claim without name\n");
 		return;
 	}
 
-	if (!j1939_address_is_valid(skcb->srcaddr)) {
+	if (!j1939_address_is_valid(skcb->addr.sa)) {
 		pr_notice("rx address claim with broadcast sa\n");
 		return;
 	}
@@ -153,23 +153,23 @@ static void j1939_process_address_claim(struct sk_buff *skb)
 	write_lock_bh(&priv->lock);
 
 	ecu = _j1939_ecu_get_register(priv, name,
-				      j1939_address_is_unicast(skcb->srcaddr));
+				      j1939_address_is_unicast(skcb->addr.sa));
 	if (IS_ERR(ecu))
 		goto done;
 
-	if (skcb->srcaddr >= J1939_IDLE_ADDR) {
+	if (skcb->addr.sa >= J1939_IDLE_ADDR) {
 		_j1939_ecu_unregister(ecu);
 		goto done;
 	}
 
 	/* save new SA */
-	if (skcb->srcaddr != ecu->sa)
+	if (skcb->addr.sa != ecu->sa)
 		_j1939_ecu_remove_sa(ecu);
 	/* cancel pending (previous) address claim */
 	hrtimer_try_to_cancel(&ecu->ac_timer);
-	ecu->sa = skcb->srcaddr;
+	ecu->sa = skcb->addr.sa;
 
-	prev = priv->ents[skcb->srcaddr].ecu;
+	prev = priv->ents[skcb->addr.sa].ecu;
 	if (prev && prev != ecu) {
 		if (ecu->name > prev->name) {
 			_j1939_ecu_unregister(ecu);
@@ -196,22 +196,22 @@ void j1939_recv_address_claim(struct sk_buff *skb, struct j1939_priv *priv)
 	struct j1939_ecu *ecu;
 
 	/* network mgmt */
-	if (skcb->pgn == PGN_ADDRESS_CLAIMED) {
+	if (skcb->addr.pgn == PGN_ADDRESS_CLAIMED) {
 		j1939_process_address_claim(skb);
-	} else if (j1939_address_is_unicast(skcb->srcaddr)) {
-		ecu = j1939_ecu_find_by_addr(skcb->srcaddr, skb->skb_iif);
+	} else if (j1939_address_is_unicast(skcb->addr.sa)) {
+		ecu = j1939_ecu_find_by_addr(skcb->addr.sa, skb->skb_iif);
 		if (ecu) {
 			/* source administration */
 			ecu->rxtime = ktime_get();
-			skcb->srcname = ecu->name;
+			skcb->addr.src_name = ecu->name;
 			put_j1939_ecu(ecu);
 		}
 	}
 
 	/* assign destination stuff */
-	ecu = j1939_ecu_find_by_addr(skcb->dstaddr, skb->skb_iif);
+	ecu = j1939_ecu_find_by_addr(skcb->addr.da, skb->skb_iif);
 	if (ecu) {
-		skcb->dstname = ecu->name;
+		skcb->addr.dst_name = ecu->name;
 		put_j1939_ecu(ecu);
 	}
 }
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index e9ff2ea..4e89d00 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -193,12 +193,8 @@ struct j1939_addr {
 
 /* control buffer of the sk_buff */
 struct j1939_sk_buff_cb {
-	pgn_t pgn;
+	struct j1939_addr addr;
 	priority_t priority;
-	u8 srcaddr;
-	u8 dstaddr;
-	name_t srcname;
-	name_t dstname;
 
 	/* Flags for quick lookups during skb processing
 	 * These are set in the receive path only
@@ -230,7 +226,7 @@ static inline struct j1939_sk_buff_cb *j1939_get_cb(struct sk_buff *skb)
 
 static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
 {
-	return (!skcb->dstname && (skcb->dstaddr == 0xff));
+	return (!skcb->addr.dst_name && (skcb->addr.da == 0xff));
 }
 
 int j1939_send(struct sk_buff *);
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 4bb9428..bfa42d7 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -75,36 +75,36 @@ static void j1939_can_recv(struct sk_buff *iskb, void *data)
 	/* save incoming socket, without assigning the skb to it */
 	skcb->insock = iskb->sk;
 	skcb->priority = (cf->can_id & 0x1c000000) >> 26;
-	skcb->srcaddr = cf->can_id;
-	skcb->pgn = (cf->can_id & 0x3ffff00) >> 8;
-	if (pgn_is_pdu1(skcb->pgn)) {
+	skcb->addr.sa = cf->can_id;
+	skcb->addr.pgn = (cf->can_id & 0x3ffff00) >> 8;
+	if (pgn_is_pdu1(skcb->addr.pgn)) {
 		/* Type 1: with destination address */
-		skcb->dstaddr = skcb->pgn;
+		skcb->addr.da = skcb->addr.pgn;
 		/* normalize pgn: strip dst address */
-		skcb->pgn &= 0x3ff00;
+		skcb->addr.pgn &= 0x3ff00;
 	} else {
 		/* set broadcast address */
-		skcb->dstaddr = J1939_NO_ADDR;
+		skcb->addr.da = J1939_NO_ADDR;
 	}
 
 	/* update local rxtime cache */
 	write_lock_bh(&priv->lock);
-	if (j1939_address_is_unicast(skcb->srcaddr)) {
-		paddr = &priv->ents[skcb->srcaddr];
+	if (j1939_address_is_unicast(skcb->addr.sa)) {
+		paddr = &priv->ents[skcb->addr.sa];
 		paddr->rxtime = ktime_get();
-		if (paddr->ecu && skcb->pgn != PGN_ADDRESS_CLAIMED)
+		if (paddr->ecu && skcb->addr.pgn != PGN_ADDRESS_CLAIMED)
 			paddr->ecu->rxtime = paddr->rxtime;
 	}
 	write_unlock_bh(&priv->lock);
 
 	/* update localflags */
 	read_lock_bh(&priv->lock);
-	if (j1939_address_is_unicast(skcb->srcaddr) &&
-	    priv->ents[skcb->srcaddr].nusers)
+	if (j1939_address_is_unicast(skcb->addr.sa) &&
+	    priv->ents[skcb->addr.sa].nusers)
 		skcb->srcflags |= ECU_LOCAL;
-	if (j1939_address_is_valid(skcb->dstaddr) ||
-	    (j1939_address_is_unicast(skcb->dstaddr) &&
-	     priv->ents[skcb->dstaddr].nusers))
+	if (j1939_address_is_valid(skcb->addr.da) ||
+	    (j1939_address_is_unicast(skcb->addr.da) &&
+	     priv->ents[skcb->addr.da].nusers))
 		skcb->dstflags |= ECU_LOCAL;
 	read_unlock_bh(&priv->lock);
 
@@ -131,7 +131,7 @@ int j1939_send(struct sk_buff *skb)
 		return j1939_send_transport(skb);
 
 	/* apply sanity checks */
-	skcb->pgn &= (pgn_is_pdu1(skcb->pgn)) ? 0x3ff00 : 0x3ffff;
+	skcb->addr.pgn &= (pgn_is_pdu1(skcb->addr.pgn)) ? 0x3ff00 : 0x3ffff;
 	if (skcb->priority > 7)
 		skcb->priority = 6;
 
@@ -151,13 +151,13 @@ int j1939_send(struct sk_buff *skb)
 	skb_put(skb, CAN_FTR + (8 - dlc));
 
 	canid = CAN_EFF_FLAG |
-		(skcb->srcaddr) |
+		(skcb->addr.sa) |
 		((skcb->priority & 0x7) << 26);
-	if (pgn_is_pdu1(skcb->pgn))
-		canid |= ((skcb->pgn & 0x3ff00) << 8) |
-			(skcb->dstaddr << 8);
+	if (pgn_is_pdu1(skcb->addr.pgn))
+		canid |= ((skcb->addr.pgn & 0x3ff00) << 8) |
+			(skcb->addr.da << 8);
 	else
-		canid |= ((skcb->pgn & 0x3ffff) << 8);
+		canid |= ((skcb->addr.pgn & 0x3ffff) << 8);
 
 	cf->can_id = canid;
 	cf->can_dlc = dlc;
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 913a594..3eac80f 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -113,11 +113,11 @@ static inline bool packet_match(const struct j1939_sk_buff_cb *skcb,
 	 * Sockets using dynamic addressing in their filters should not set it.
 	 */
 	for (; nfilter; ++f, --nfilter) {
-		if ((skcb->pgn & f->pgn_mask) != (f->pgn & f->pgn_mask))
+		if ((skcb->addr.pgn & f->pgn_mask) != (f->pgn & f->pgn_mask))
 			continue;
-		if ((skcb->srcaddr & f->addr_mask) != (f->addr & f->addr_mask))
+		if ((skcb->addr.sa & f->addr_mask) != (f->addr & f->addr_mask))
 			continue;
-		if ((skcb->srcname & f->name_mask) != (f->name & f->name_mask))
+		if ((skcb->addr.src_name & f->name_mask) != (f->name & f->name_mask))
 			continue;
 		return true;
 	}
@@ -139,16 +139,16 @@ static void j1939sk_recv_skb(struct sk_buff *oskb, struct j1939_sock *jsk)
 	if (!(jsk->state & J1939_SOCK_PROMISC)) {
 		if (jsk->addr.src_name) {
 			/* reject message for other destinations */
-			if (skcb->dstname &&
-			    (skcb->dstname != jsk->addr.src_name))
+			if (skcb->addr.dst_name &&
+			    (skcb->addr.dst_name != jsk->addr.src_name))
 				/* the msg is not destined for the name
 				 * that the socket is bound to
 				 */
 				return;
 		} else {
 			/* reject messages for other destination addresses */
-			if (j1939_address_is_unicast(skcb->dstaddr) &&
-			    (skcb->dstaddr != jsk->addr.sa))
+			if (j1939_address_is_unicast(skcb->addr.da) &&
+			    (skcb->addr.da != jsk->addr.sa))
 				/* the msg is not destined for the name
 				 * that the socket is bound to
 				 */
@@ -606,13 +606,13 @@ static int j1939sk_recvmsg(struct socket *sock, struct msghdr *msg,
 	}
 
 	skcb = j1939_get_cb(skb);
-	if (j1939_address_is_valid(skcb->dstaddr))
+	if (j1939_address_is_valid(skcb->addr.da))
 		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_ADDR,
-			 sizeof(skcb->dstaddr), &skcb->dstaddr);
+			 sizeof(skcb->addr.da), &skcb->addr.da);
 
-	if (skcb->dstname)
+	if (skcb->addr.dst_name)
 		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_NAME,
-			 sizeof(skcb->dstname), &skcb->dstname);
+			 sizeof(skcb->addr.dst_name), &skcb->addr.dst_name);
 
 	put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_PRIO,
 		 sizeof(skcb->priority), &skcb->priority);
@@ -624,9 +624,9 @@ static int j1939sk_recvmsg(struct socket *sock, struct msghdr *msg,
 		memset(msg->msg_name, 0, msg->msg_namelen);
 		paddr->can_family = AF_CAN;
 		paddr->can_ifindex = skb->skb_iif;
-		paddr->can_addr.j1939.name = skcb->srcname;
-		paddr->can_addr.j1939.addr = skcb->srcaddr;
-		paddr->can_addr.j1939.pgn = skcb->pgn;
+		paddr->can_addr.j1939.name = skcb->addr.src_name;
+		paddr->can_addr.j1939.addr = skcb->addr.sa;
+		paddr->can_addr.j1939.pgn = skcb->addr.pgn;
 	}
 
 	sock_recv_ts_and_drops(msg, sk, skb);
@@ -696,25 +696,25 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	skcb = j1939_get_cb(skb);
 	memset(skcb, 0, sizeof(*skcb));
 	skcb->msg_flags = msg->msg_flags;
-	skcb->srcname = jsk->addr.src_name;
-	skcb->dstname = jsk->addr.dst_name;
-	skcb->pgn = jsk->addr.pgn;
+	skcb->addr.src_name = jsk->addr.src_name;
+	skcb->addr.dst_name = jsk->addr.dst_name;
+	skcb->addr.pgn = jsk->addr.pgn;
 	skcb->priority = j1939_prio(jsk->sk.sk_priority);
-	skcb->srcaddr = jsk->addr.sa;
-	skcb->dstaddr = jsk->addr.da;
+	skcb->addr.sa = jsk->addr.sa;
+	skcb->addr.da = jsk->addr.da;
 
 	if (msg->msg_name) {
 		struct sockaddr_can *addr = msg->msg_name;
 
 		if (addr->can_addr.j1939.name ||
 		    (addr->can_addr.j1939.addr != J1939_NO_ADDR)) {
-			skcb->dstname = addr->can_addr.j1939.name;
-			skcb->dstaddr = addr->can_addr.j1939.addr;
+			skcb->addr.dst_name = addr->can_addr.j1939.name;
+			skcb->addr.da = addr->can_addr.j1939.addr;
 		}
 		if (pgn_is_valid(addr->can_addr.j1939.pgn))
-			skcb->pgn = addr->can_addr.j1939.pgn;
+			skcb->addr.pgn = addr->can_addr.j1939.pgn;
 	}
-	if (!pgn_is_valid(skcb->pgn)) {
+	if (!pgn_is_valid(skcb->addr.pgn)) {
 		ret = -EINVAL;
 		goto free_skb;
 	}
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 86bd49f..74d0408 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -282,31 +282,31 @@ static int j1939tp_match(struct session *session, struct sk_buff *skb,
 	if (session->skb_iif != skb->skb_iif)
 		return 0;
 	if (!reverse) {
-		if (session->cb->srcname) {
-			if (session->cb->srcname != cb->srcname)
+		if (session->cb->addr.src_name) {
+			if (session->cb->addr.src_name != cb->addr.src_name)
 				return 0;
-		} else if (session->cb->srcaddr != cb->srcaddr) {
+		} else if (session->cb->addr.sa != cb->addr.sa) {
 			return 0;
 		}
 
-		if (session->cb->dstname) {
-			if (session->cb->dstname != cb->dstname)
+		if (session->cb->addr.dst_name) {
+			if (session->cb->addr.dst_name != cb->addr.dst_name)
 				return 0;
-		} else if (session->cb->dstaddr != cb->dstaddr) {
+		} else if (session->cb->addr.da != cb->addr.da) {
 			return 0;
 		}
 	} else {
-		if (session->cb->srcname) {
-			if (session->cb->srcname != cb->dstname)
+		if (session->cb->addr.src_name) {
+			if (session->cb->addr.src_name != cb->addr.dst_name)
 				return 0;
-		} else if (session->cb->srcaddr != cb->dstaddr) {
+		} else if (session->cb->addr.sa != cb->addr.da) {
 			return 0;
 		}
 
-		if (session->cb->dstname) {
-			if (session->cb->dstname != cb->srcname)
+		if (session->cb->addr.dst_name) {
+			if (session->cb->addr.dst_name != cb->addr.src_name)
 				return 0;
-		} else if (session->cb->dstaddr != cb->srcaddr) {
+		} else if (session->cb->addr.da != cb->addr.sa) {
 			return 0;
 		}
 	}
@@ -343,8 +343,8 @@ static struct session *j1939tp_find(struct list_head *root,
 
 static void j1939_skbcb_swap(struct j1939_sk_buff_cb *cb)
 {
-	swap(cb->dstname, cb->srcname);
-	swap(cb->dstaddr, cb->srcaddr);
+	swap(cb->addr.dst_name, cb->addr.src_name);
+	swap(cb->addr.da, cb->addr.sa);
 	swap(cb->dstflags, cb->srcflags);
 }
 
@@ -376,7 +376,7 @@ static int j1939tp_tx_dat(struct sk_buff *related, int extd,
 	skb_cb = j1939_get_cb(skb);
 	fix_cb(skb_cb);
 	/* fix pgn */
-	skb_cb->pgn = extd ? etp_pgn_dat : tp_pgn_dat;
+	skb_cb->addr.pgn = extd ? etp_pgn_dat : tp_pgn_dat;
 
 	skdat = skb_put(skb, len);
 	memcpy(skdat, dat, len);
@@ -415,7 +415,7 @@ static int j1939xtp_do_tx_ctl(struct sk_buff *related, int extd,
 	fix_cb(skb_cb);
 	if (swap_src_dst)
 		j1939_skbcb_swap(skb_cb);
-	skb_cb->pgn = extd ? etp_pgn_ctl : tp_pgn_ctl;
+	skb_cb->addr.pgn = extd ? etp_pgn_ctl : tp_pgn_ctl;
 
 	skdat = skb_put(skb, 8);
 	memcpy(skdat, dat, 5);
@@ -430,7 +430,7 @@ static inline int j1939tp_tx_ctl(struct session *session,
 				 int swap_src_dst, const u8 *dat)
 {
 	return j1939xtp_do_tx_ctl(session->skb, session->extd, swap_src_dst,
-				  session->cb->pgn, dat);
+				  session->cb->addr.pgn, dat);
 }
 
 static int j1939xtp_tx_abort(struct sk_buff *related, int extd,
@@ -511,7 +511,7 @@ static void j1939session_cancel(struct session *session, int err)
 			/* do not send aborts on incoming broadcasts */
 			j1939xtp_tx_abort(session->skb, session->extd,
 					  !(session->cb->srcflags & ECU_LOCAL),
-					  err, session->cb->pgn);
+					  err, session->cb->addr.pgn);
 		}
 	}
 	j1939session_drop(session);
@@ -544,7 +544,7 @@ static void _j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
 
 	pgn = j1939xtp_ctl_to_pgn(skb->data);
 	session = j1939tp_find(sessionq(extd), skb, 0);
-	if (session /*&& (session->cb->pgn == pgn)*/) {
+	if (session /*&& (session->cb->addr.pgn == pgn)*/) {
 		/* do not allow TP control messages on 2 pgn's */
 		j1939session_cancel(session, ABORT_FAULT);
 		put_session(session); /* ~j1939tp_find */
@@ -585,7 +585,7 @@ static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd)
 		 * do not drop session when a transmit session did not
 		 * start yet
 		 */
-	} else if (session->cb->pgn == pgn) {
+	} else if (session->cb->addr.pgn == pgn) {
 		j1939session_drop(session);
 	}
 
@@ -626,7 +626,7 @@ static void j1939xtp_rx_eof(struct sk_buff *skb, int extd)
 		return;
 	}
 
-	if (session->cb->pgn != pgn) {
+	if (session->cb->addr.pgn != pgn) {
 		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
 		j1939session_cancel(session, ABORT_BUSY);
 	} else {
@@ -651,7 +651,7 @@ static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
 		return;
 	}
 
-	if (session->cb->pgn != pgn) {
+	if (session->cb->addr.pgn != pgn) {
 		/* what to do? */
 		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
 		j1939session_cancel(session, ABORT_BUSY);
@@ -709,7 +709,7 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 
 	if ((tp_cmd_rts == dat[0]) && j1939cb_is_broadcast(cb)) {
 		pr_alert("%s: rts without destination (%i %02x)\n", __func__,
-			 skb->skb_iif, cb->srcaddr);
+			 skb->skb_iif, cb->addr.sa);
 		return;
 	}
 
@@ -720,19 +720,19 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 	if (session && !j1939tp_im_transmitter(skb)) {
 		/* RTS on pending connection */
 		j1939session_cancel(session, ABORT_BUSY);
-		if ((pgn != session->cb->pgn) && (tp_cmd_bam != dat[0]))
+		if ((pgn != session->cb->addr.pgn) && (tp_cmd_bam != dat[0]))
 			j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
 		put_session(session); /* ~j1939tp_find */
 		return;
 	} else if (!session && j1939tp_im_transmitter(skb)) {
 		pr_alert("%s: I should tx (%i %02x %02x)\n", __func__,
-			 skb->skb_iif, cb->srcaddr, cb->dstaddr);
+			 skb->skb_iif, cb->addr.sa, cb->addr.da);
 		return;
 	}
 	if (session && (session->last_cmd != 0)) {
 		/* we received a second rts on the same connection */
 		pr_alert("%s: connection exists (%i %02x %02x)\n", __func__,
-			 skb->skb_iif, cb->srcaddr, cb->dstaddr);
+			 skb->skb_iif, cb->addr.sa, cb->addr.da);
 		j1939session_cancel(session, ABORT_BUSY);
 		put_session(session); /* ~j1939tp_find */
 		return;
@@ -742,8 +742,8 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 		 * They may be 'not filled in yet' for sending
 		 * skb's, since they did not pass the Address Claim ever.
 		 */
-		session->cb->srcaddr = cb->srcaddr;
-		session->cb->dstaddr = cb->dstaddr;
+		session->cb->addr.sa = cb->addr.sa;
+		session->cb->addr.da = cb->addr.da;
 	} else {
 		int abort = 0;
 
@@ -821,7 +821,7 @@ static void j1939xtp_rx_dpo(struct sk_buff *skb, int extd)
 		return;
 	}
 
-	if (session->cb->pgn != pgn) {
+	if (session->cb->addr.pgn != pgn) {
 		pr_info("%s: different pgn\n", __func__);
 		j1939xtp_tx_abort(skb, 1, 1, ABORT_BUSY, pgn);
 		j1939session_cancel(session, ABORT_BUSY);
@@ -1143,8 +1143,8 @@ int j1939_send_transport(struct sk_buff *skb)
 	int ret;
 	struct j1939_priv *priv;
 
-	if ((tp_pgn_dat == cb->pgn) || (tp_pgn_ctl == cb->pgn) ||
-	    (etp_pgn_dat == cb->pgn) || (etp_pgn_ctl == cb->pgn))
+	if ((tp_pgn_dat == cb->addr.pgn) || (tp_pgn_ctl == cb->addr.pgn) ||
+	    (etp_pgn_dat == cb->addr.pgn) || (etp_pgn_ctl == cb->addr.pgn))
 		/* avoid conflict */
 		return -EDOM;
 	else if ((skb->len > MAX_ETP_PACKET_SIZE) ||
@@ -1165,9 +1165,9 @@ int j1939_send_transport(struct sk_buff *skb)
 	priv = j1939_priv_get_by_ifindex(can_skb_prv(skb)->ifindex);
 	if (!priv)
 		return -EINVAL;
-	if (!j1939_address_is_valid(cb->dstaddr) ||
-	    (j1939_address_is_unicast(cb->dstaddr) &&
-	     priv->ents[cb->dstaddr].nusers))
+	if (!j1939_address_is_valid(cb->addr.da) ||
+	    (j1939_address_is_unicast(cb->addr.da) &&
+	     priv->ents[cb->addr.da].nusers))
 		cb->dstflags |= ECU_LOCAL;
 	j1939_priv_put(priv);
 	/* src is always local, I'm sending ... */
@@ -1218,7 +1218,7 @@ int j1939_recv_transport(struct sk_buff *skb)
 	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
 	const u8 *dat;
 
-	switch (cb->pgn) {
+	switch (cb->addr.pgn) {
 	case etp_pgn_dat:
 		j1939xtp_rx_dat(skb, EXTENDED);
 		break;
@@ -1302,7 +1302,7 @@ static struct session *j1939session_fresh_new(int size,
 	cb = j1939_get_cb(skb);
 	memcpy(cb, rel_skb->cb, sizeof(*cb));
 	fix_cb(cb);
-	cb->pgn = pgn;
+	cb->addr.pgn = pgn;
 
 	session = j1939session_new(skb);
 	if (!session) {
@@ -1364,17 +1364,17 @@ static int j1939tp_proc_show_session(struct seq_file *sqf,
 				     struct session *session)
 {
 	seq_printf(sqf, "%i", session->skb_iif);
-	if (session->cb->srcname)
-		seq_printf(sqf, "\t%016llx", session->cb->srcname);
+	if (session->cb->addr.src_name)
+		seq_printf(sqf, "\t%016llx", session->cb->addr.src_name);
 	else
-		seq_printf(sqf, "\t%02x", session->cb->srcaddr);
-	if (session->cb->dstname)
-		seq_printf(sqf, "\t%016llx", session->cb->dstname);
-	else if (j1939_address_is_unicast(session->cb->dstaddr))
-		seq_printf(sqf, "\t%02x", session->cb->dstaddr);
+		seq_printf(sqf, "\t%02x", session->cb->addr.sa);
+	if (session->cb->addr.dst_name)
+		seq_printf(sqf, "\t%016llx", session->cb->addr.dst_name);
+	else if (j1939_address_is_unicast(session->cb->addr.da))
+		seq_printf(sqf, "\t%02x", session->cb->addr.da);
 	else
 		seq_puts(sqf, "\t-");
-	seq_printf(sqf, "\t%05x\t%u/%u\n", session->cb->pgn,
+	seq_printf(sqf, "\t%05x\t%u/%u\n", session->cb->addr.pgn,
 		   session->pkt.done * 7, session->skb->len);
 	return 0;
 }
-- 
1.9.1


From 0f6609340a0a1f637754af79896fdb08f80ebd8d Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Wed, 16 Aug 2017 17:14:31 +0200
Subject: [PATCH 086/113] j1939: transport: use common prefix
 j1939_session{,list}_ for all session{,list} related functions

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/transport.c | 200 +++++++++++++++++++++++-----------------------
 1 file changed, 100 insertions(+), 100 deletions(-)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 74d0408..29dcc6d 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -103,8 +103,8 @@ struct session {
 };
 
 /* forward declarations */
-static struct session *j1939session_new(struct sk_buff *skb);
-static struct session *j1939session_fresh_new(int size,
+static struct session *j1939_session_new(struct sk_buff *skb);
+static struct session *j1939_session_fresh_new(int size,
 					      struct sk_buff *rel_skb,
 					      pgn_t pgn);
 static void j1939tp_del_work(struct work_struct *work);
@@ -129,7 +129,7 @@ static inline struct list_head *sessionq(int extd)
 	return extd ? &tp_extsessionq : &tp_sessionq;
 }
 
-static inline void j1939session_destroy(struct session *session)
+static inline void j1939_session_destroy(struct session *session)
 {
 	kfree_skb(session->skb);
 	hrtimer_cancel(&session->rxtimer);
@@ -155,17 +155,17 @@ static void j1939tp_del_work(struct work_struct *work)
 					   struct session, list);
 		list_del_init(&session->list);
 		spin_unlock_bh(&tp_dellock);
-		j1939session_destroy(session);
+		j1939_session_destroy(session);
 	} while (1);
 }
 
 /* reference counter */
-static inline void get_session(struct session *session)
+static inline void j1939_session_get(struct session *session)
 {
 	atomic_inc(&session->refs);
 }
 
-static void put_session(struct session *session)
+static void j1939_session_put(struct session *session)
 {
 	if (atomic_add_return(-1, &session->refs) >= 0)
 		/* not the last one */
@@ -183,29 +183,29 @@ static void put_session(struct session *session)
 		schedule_work(&tp_delwork);
 	} else {
 		/* destroy session right here */
-		j1939session_destroy(session);
+		j1939_session_destroy(session);
 	}
 }
 
 /* transport status locking */
-static inline void session_lock(struct session *session)
+static inline void j1939_session_lock(struct session *session)
 {
-	get_session(session); /* safety measure */
+	j1939_session_get(session); /* safety measure */
 	spin_lock_bh(&session->lock);
 }
 
-static inline void session_unlock(struct session *session)
+static inline void j1939_session_unlock(struct session *session)
 {
 	spin_unlock_bh(&session->lock);
-	put_session(session);
+	j1939_session_put(session);
 }
 
-static inline void sessionlist_lock(void)
+static inline void j1939_sessionlist_lock(void)
 {
 	spin_lock_bh(&tp_lock);
 }
 
-static inline void sessionlist_unlock(void)
+static inline void j1939_sessionlist_unlock(void)
 {
 	spin_unlock_bh(&tp_lock);
 }
@@ -320,10 +320,10 @@ static struct session *_j1939tp_find(struct list_head *root,
 	struct session *session;
 
 	list_for_each_entry(session, root, list) {
-		get_session(session);
+		j1939_session_get(session);
 		if (j1939tp_match(session, skb, reverse))
 			return session;
-		put_session(session);
+		j1939_session_put(session);
 	}
 
 	return NULL;
@@ -334,9 +334,9 @@ static struct session *j1939tp_find(struct list_head *root,
 {
 	struct session *session;
 
-	sessionlist_lock();
+	j1939_sessionlist_lock();
 	session = _j1939tp_find(root, skb, reverse);
-	sessionlist_unlock();
+	j1939_sessionlist_unlock();
 
 	return session;
 }
@@ -449,7 +449,7 @@ static int j1939xtp_tx_abort(struct sk_buff *related, int extd,
 }
 
 /* timer & scheduler functions */
-static inline void j1939session_schedule_txnow(struct session *session)
+static inline void j1939_session_schedule_txnow(struct session *session)
 {
 	tasklet_schedule(&session->txtask);
 }
@@ -459,7 +459,7 @@ static enum hrtimer_restart j1939tp_txtimer(struct hrtimer *hrtimer)
 	struct session *session;
 
 	session = container_of(hrtimer, struct session, txtimer);
-	j1939session_schedule_txnow(session);
+	j1939_session_schedule_txnow(session);
 
 	return HRTIMER_NORESTART;
 }
@@ -480,31 +480,31 @@ static inline void j1939tp_set_rxtimeout(struct session *session, int msec)
 
 /* session completion functions */
 
-/* j1939session_drop
+/* j1939_session_drop
  * removes a session from open session list
  */
-static inline void j1939session_drop(struct session *session)
+static inline void j1939_session_drop(struct session *session)
 {
-	sessionlist_lock();
+	j1939_sessionlist_lock();
 	list_del_init(&session->list);
-	sessionlist_unlock();
+	j1939_sessionlist_unlock();
 
 	if (session->transmission) {
 		if (session->skb && session->skb->sk)
 			j1939_sock_pending_del(session->skb->sk);
 		wake_up_all(&tp_wait);
 	}
-	put_session(session);
+	j1939_session_put(session);
 }
 
-static inline void j1939session_completed(struct session *session)
+static inline void j1939_session_completed(struct session *session)
 {
 	/* distribute among j1939 receivers */
 	j1939_recv(session->skb);
-	j1939session_drop(session);
+	j1939_session_drop(session);
 }
 
-static void j1939session_cancel(struct session *session, int err)
+static void j1939_session_cancel(struct session *session, int err)
 {
 	if ((err >= 0) && j1939tp_im_involved_anydir(session->skb)) {
 		if (!j1939cb_is_broadcast(session->cb)) {
@@ -514,7 +514,7 @@ static void j1939session_cancel(struct session *session, int err)
 					  err, session->cb->addr.pgn);
 		}
 	}
-	j1939session_drop(session);
+	j1939_session_drop(session);
 }
 
 static enum hrtimer_restart j1939tp_rxtimer(struct hrtimer *hrtimer)
@@ -530,10 +530,10 @@ static void j1939tp_rxtask(unsigned long val)
 {
 	struct session *session = (void *)val;
 
-	get_session(session);
+	j1939_session_get(session);
 	pr_alert("%s: timeout on %i\n", __func__, session->skb_iif);
-	j1939session_cancel(session, ABORT_TIMEOUT);
-	put_session(session);
+	j1939_session_cancel(session, ABORT_TIMEOUT);
+	j1939_session_put(session);
 }
 
 /* receive packet functions */
@@ -546,14 +546,14 @@ static void _j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
 	session = j1939tp_find(sessionq(extd), skb, 0);
 	if (session /*&& (session->cb->addr.pgn == pgn)*/) {
 		/* do not allow TP control messages on 2 pgn's */
-		j1939session_cancel(session, ABORT_FAULT);
-		put_session(session); /* ~j1939tp_find */
+		j1939_session_cancel(session, ABORT_FAULT);
+		j1939_session_put(session); /* ~j1939tp_find */
 		return;
 	}
 	j1939xtp_tx_abort(skb, extd, 0, ABORT_FAULT, pgn);
 	if (!session)
 		return;
-	put_session(session); /* ~j1939tp_find */
+	j1939_session_put(session); /* ~j1939tp_find */
 }
 
 /* abort packets may come in 2 directions */
@@ -586,13 +586,13 @@ static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd)
 		 * start yet
 		 */
 	} else if (session->cb->addr.pgn == pgn) {
-		j1939session_drop(session);
+		j1939_session_drop(session);
 	}
 
 	/* TODO: maybe cancel current connection
 	 * as another pgn was communicated
 	 */
-	put_session(session); /* ~j1939tp_find */
+	j1939_session_put(session); /* ~j1939tp_find */
 }
 
 /* abort packets may come in 2 directions */
@@ -628,12 +628,12 @@ static void j1939xtp_rx_eof(struct sk_buff *skb, int extd)
 
 	if (session->cb->addr.pgn != pgn) {
 		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
-		j1939session_cancel(session, ABORT_BUSY);
+		j1939_session_cancel(session, ABORT_BUSY);
 	} else {
 		/* transmitted without problems */
-		j1939session_completed(session);
+		j1939_session_completed(session);
 	}
-	put_session(session); /* ~j1939tp_find */
+	j1939_session_put(session); /* ~j1939tp_find */
 }
 
 static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
@@ -654,12 +654,12 @@ static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
 	if (session->cb->addr.pgn != pgn) {
 		/* what to do? */
 		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
-		j1939session_cancel(session, ABORT_BUSY);
-		put_session(session); /* ~j1939tp_find */
+		j1939_session_cancel(session, ABORT_BUSY);
+		j1939_session_put(session); /* ~j1939tp_find */
 		return;
 	}
 
-	session_lock(session);
+	j1939_session_lock(session);
 	pkt = extd ? j1939etp_ctl_to_packet(dat) : dat[2];
 	if (!dat[0]) {
 		hrtimer_cancel(&session->txtimer);
@@ -679,21 +679,21 @@ static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
 	}
 
 	session->last_cmd = dat[0];
-	session_unlock(session);
+	j1939_session_unlock(session);
 	if (dat[1]) {
 		j1939tp_set_rxtimeout(session, 1250);
 		if (j1939tp_im_transmitter(session->skb))
-			j1939session_schedule_txnow(session);
+			j1939_session_schedule_txnow(session);
 	} else {
 		/* CTS(0) */
 		j1939tp_set_rxtimeout(session, 550);
 	}
-	put_session(session); /* ~j1939tp_find */
+	j1939_session_put(session); /* ~j1939tp_find */
 	return;
  bad_fmt:
-	session_unlock(session);
-	j1939session_cancel(session, ABORT_FAULT);
-	put_session(session); /* ~j1939tp_find */
+	j1939_session_unlock(session);
+	j1939_session_cancel(session, ABORT_FAULT);
+	j1939_session_put(session); /* ~j1939tp_find */
 }
 
 static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
@@ -719,10 +719,10 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 	session = j1939tp_find(sessionq(extd), skb, 0);
 	if (session && !j1939tp_im_transmitter(skb)) {
 		/* RTS on pending connection */
-		j1939session_cancel(session, ABORT_BUSY);
+		j1939_session_cancel(session, ABORT_BUSY);
 		if ((pgn != session->cb->addr.pgn) && (tp_cmd_bam != dat[0]))
 			j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
-		put_session(session); /* ~j1939tp_find */
+		j1939_session_put(session); /* ~j1939tp_find */
 		return;
 	} else if (!session && j1939tp_im_transmitter(skb)) {
 		pr_alert("%s: I should tx (%i %02x %02x)\n", __func__,
@@ -733,8 +733,8 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 		/* we received a second rts on the same connection */
 		pr_alert("%s: connection exists (%i %02x %02x)\n", __func__,
 			 skb->skb_iif, cb->addr.sa, cb->addr.da);
-		j1939session_cancel(session, ABORT_BUSY);
-		put_session(session); /* ~j1939tp_find */
+		j1939_session_cancel(session, ABORT_BUSY);
+		j1939_session_put(session); /* ~j1939tp_find */
 		return;
 	}
 	if (session) {
@@ -766,7 +766,7 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 			j1939xtp_tx_abort(skb, extd, 1, abort, pgn);
 			return;
 		}
-		session = j1939session_fresh_new(len, skb, pgn);
+		session = j1939_session_fresh_new(len, skb, pgn);
 		if (!session) {
 			j1939xtp_tx_abort(skb, extd, 1, ABORT_RESOURCE, pgn);
 			return;
@@ -786,10 +786,10 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 		}
 		session->pkt.done = 0;
 		session->pkt.tx = 0;
-		get_session(session); /* equivalent to j1939tp_find() */
-		sessionlist_lock();
+		j1939_session_get(session); /* equivalent to j1939tp_find() */
+		j1939_sessionlist_lock();
 		list_add_tail(&session->list, sessionq(extd));
-		sessionlist_unlock();
+		j1939_sessionlist_unlock();
 	}
 	session->last_cmd = dat[0];
 
@@ -797,7 +797,7 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 
 	if (j1939tp_im_receiver(session->skb)) {
 		if (extd || (tp_cmd_bam != dat[0]))
-			j1939session_schedule_txnow(session);
+			j1939_session_schedule_txnow(session);
 	}
 
 	/* as soon as it's inserted, things can go fast
@@ -805,7 +805,7 @@ static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
 	 * between spin_unlock & next statement
 	 * so, only release here, at the end
 	 */
-	put_session(session); /* ~j1939tp_find */
+	j1939_session_put(session); /* ~j1939tp_find */
 }
 
 static void j1939xtp_rx_dpo(struct sk_buff *skb, int extd)
@@ -824,8 +824,8 @@ static void j1939xtp_rx_dpo(struct sk_buff *skb, int extd)
 	if (session->cb->addr.pgn != pgn) {
 		pr_info("%s: different pgn\n", __func__);
 		j1939xtp_tx_abort(skb, 1, 1, ABORT_BUSY, pgn);
-		j1939session_cancel(session, ABORT_BUSY);
-		put_session(session); /* ~j1939tp_find */
+		j1939_session_cancel(session, ABORT_BUSY);
+		j1939_session_put(session); /* ~j1939tp_find */
 		return;
 	}
 
@@ -833,7 +833,7 @@ static void j1939xtp_rx_dpo(struct sk_buff *skb, int extd)
 	session->pkt.dpo = j1939etp_ctl_to_packet(skb->data);
 	session->last_cmd = dat[0];
 	j1939tp_set_rxtimeout(session, 750);
-	put_session(session); /* ~j1939tp_find */
+	j1939_session_put(session); /* ~j1939tp_find */
 }
 
 static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
@@ -857,7 +857,7 @@ static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
 		/* makes no sense */
 		goto strange_packet_unlocked;
 
-	session_lock(session);
+	j1939_session_lock(session);
 
 	switch (session->last_cmd) {
 	case 0xff:
@@ -902,26 +902,26 @@ static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
 		final = 0; /* never final, an EOF must follow */
 		do_cts_eof = (session->pkt.done >= session->pkt.last);
 	}
-	session_unlock(session);
+	j1939_session_unlock(session);
 	if (final) {
-		j1939session_completed(session);
+		j1939_session_completed(session);
 	} else if (do_cts_eof) {
 		j1939tp_set_rxtimeout(session, 1250);
 		if (j1939tp_im_receiver(session->skb))
-			j1939session_schedule_txnow(session);
+			j1939_session_schedule_txnow(session);
 	} else {
 		j1939tp_set_rxtimeout(session, 250);
 	}
 	session->last_cmd = 0xff;
-	put_session(session); /* ~j1939tp_find */
+	j1939_session_put(session); /* ~j1939tp_find */
 	return;
 
  strange_packet:
 	/* unlock session (spinlock) before trying to send */
-	session_unlock(session);
+	j1939_session_unlock(session);
  strange_packet_unlocked:
-	j1939session_cancel(session, ABORT_FAULT);
-	put_session(session); /* ~j1939tp_find */
+	j1939_session_cancel(session, ABORT_FAULT);
+	j1939_session_put(session); /* ~j1939tp_find */
 }
 
 /* transmit function */
@@ -933,7 +933,7 @@ static int j1939tp_txnext(struct session *session)
 	unsigned int pkt, len, pdelay;
 
 	memset(dat, 0xff, sizeof(dat));
-	get_session(session); /* do not loose it */
+	j1939_session_get(session); /* do not loose it */
 
 	switch (session->last_cmd) {
 	case 0:
@@ -1088,10 +1088,10 @@ static int j1939tp_txnext(struct session *session)
 			goto failed;
 		break;
 	}
-	put_session(session);
+	j1939_session_put(session);
 	return 0;
  failed:
-	put_session(session);
+	j1939_session_put(session);
 	return ret;
 }
 
@@ -1100,38 +1100,38 @@ static void j1939tp_txtask(unsigned long val)
 	struct session *session = (void *)val;
 	int ret;
 
-	get_session(session);
+	j1939_session_get(session);
 	ret = j1939tp_txnext(session);
 	if (ret < 0)
 		j1939tp_schedule_txtimer(session, retry_ms ?: 20);
-	put_session(session);
+	j1939_session_put(session);
 }
 
 static inline int j1939tp_tx_initial(struct session *session)
 {
 	int ret;
 
-	get_session(session);
+	j1939_session_get(session);
 	ret = j1939tp_txnext(session);
 	/* set nonblocking for further packets */
 	session->cb->msg_flags |= MSG_DONTWAIT;
-	put_session(session);
+	j1939_session_put(session);
 	return ret;
 }
 
 /* this call is to be used as probe within wait_event_xxx() */
-static int j1939session_insert(struct session *session)
+static int j1939_session_insert(struct session *session)
 {
 	struct session *pending;
 
-	sessionlist_lock();
+	j1939_sessionlist_lock();
 	pending = _j1939tp_find(sessionq(session->extd), session->skb, 0);
 	if (pending)
 		/* revert the effect of find() */
-		put_session(pending);
+		j1939_session_put(pending);
 	else
 		list_add_tail(&session->list, sessionq(session->extd));
-	sessionlist_unlock();
+	j1939_sessionlist_unlock();
 	return pending ? 0 : 1;
 }
 
@@ -1174,7 +1174,7 @@ int j1939_send_transport(struct sk_buff *skb)
 	cb->srcflags |= ECU_LOCAL;
 
 	/* prepare new session */
-	session = j1939session_new(skb);
+	session = j1939_session_new(skb);
 	if (!session)
 		return -ENOMEM;
 
@@ -1190,10 +1190,10 @@ int j1939_send_transport(struct sk_buff *skb)
 
 	/* insert into queue, but avoid collision with pending session */
 	if (session->cb->msg_flags & MSG_DONTWAIT)
-		ret = j1939session_insert(session) ? 0 : -EAGAIN;
+		ret = j1939_session_insert(session) ? 0 : -EAGAIN;
 	else
 		ret = wait_event_interruptible(tp_wait,
-					       j1939session_insert(session));
+					       j1939_session_insert(session));
 	if (ret < 0)
 		goto failed;
 
@@ -1201,15 +1201,15 @@ int j1939_send_transport(struct sk_buff *skb)
 	if (!ret)
 		/* transmission started */
 		return ret;
-	sessionlist_lock();
+	j1939_sessionlist_lock();
 	list_del_init(&session->list);
-	sessionlist_unlock();
+	j1939_sessionlist_unlock();
  failed:
-	/* hide the skb from j1939session_drop, as it would
+	/* hide the skb from j1939_session_drop, as it would
 	 * kfree_skb, but our caller will kfree_skb(skb) too.
 	 */
 	session->skb = NULL;
-	j1939session_drop(session);
+	j1939_session_drop(session);
 	return ret;
 }
 
@@ -1283,7 +1283,7 @@ int j1939_recv_transport(struct sk_buff *skb)
 	return 1; /* "I processed the message" */
 }
 
-static struct session *j1939session_fresh_new(int size,
+static struct session *j1939_session_fresh_new(int size,
 					      struct sk_buff *rel_skb,
 					      pgn_t pgn)
 {
@@ -1304,7 +1304,7 @@ static struct session *j1939session_fresh_new(int size,
 	fix_cb(cb);
 	cb->addr.pgn = pgn;
 
-	session = j1939session_new(skb);
+	session = j1939_session_new(skb);
 	if (!session) {
 		kfree(skb);
 		return NULL;
@@ -1317,7 +1317,7 @@ static struct session *j1939session_fresh_new(int size,
 	return session;
 }
 
-static struct session *j1939session_new(struct sk_buff *skb)
+static struct session *j1939_session_new(struct sk_buff *skb)
 {
 	struct session *session;
 
@@ -1342,20 +1342,20 @@ int j1939tp_rmdev_notifier(struct net_device *netdev)
 {
 	struct session *session, *saved;
 
-	sessionlist_lock();
+	j1939_sessionlist_lock();
 	list_for_each_entry_safe(session, saved, &tp_sessionq, list) {
 		if (session->skb_iif != netdev->ifindex)
 			continue;
 		list_del_init(&session->list);
-		put_session(session);
+		j1939_session_put(session);
 	}
 	list_for_each_entry_safe(session, saved, &tp_extsessionq, list) {
 		if (session->skb_iif != netdev->ifindex)
 			continue;
 		list_del_init(&session->list);
-		put_session(session);
+		j1939_session_put(session);
 	}
-	sessionlist_unlock();
+	j1939_sessionlist_unlock();
 	return NOTIFY_DONE;
 }
 
@@ -1384,12 +1384,12 @@ static int j1939tp_proc_show(struct seq_file *sqf, void *v)
 	struct session *session;
 
 	seq_puts(sqf, "iface\tsrc\tdst\tpgn\tdone/total\n");
-	sessionlist_lock();
+	j1939_sessionlist_lock();
 	list_for_each_entry(session, &tp_sessionq, list)
 		j1939tp_proc_show_session(sqf, session);
 	list_for_each_entry(session, &tp_extsessionq, list)
 		j1939tp_proc_show_session(sqf, session);
-	sessionlist_unlock();
+	j1939_sessionlist_unlock();
 	return 0;
 }
 
@@ -1480,15 +1480,15 @@ void j1939tp_module_exit(void)
 
 	unregister_net_sysctl_table(sysctl_hdr);
 	remove_proc_entry("transport", j1939_procdir);
-	sessionlist_lock();
+	j1939_sessionlist_lock();
 	list_for_each_entry_safe(session, saved, &tp_extsessionq, list) {
 		list_del_init(&session->list);
-		put_session(session);
+		j1939_session_put(session);
 	}
 	list_for_each_entry_safe(session, saved, &tp_sessionq, list) {
 		list_del_init(&session->list);
-		put_session(session);
+		j1939_session_put(session);
 	}
-	sessionlist_unlock();
+	j1939_sessionlist_unlock();
 	flush_scheduled_work();
 }
-- 
1.9.1


From f66134da4dc6f8587f9a9ed5d33b51595d3eec50 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 11:23:46 +0200
Subject: [PATCH 087/113] j1939: uapi: remove unused netlink enums

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 include/uapi/linux/can/j1939.h | 14 --------------
 1 file changed, 14 deletions(-)

diff --git a/include/uapi/linux/can/j1939.h b/include/uapi/linux/can/j1939.h
index 6382f15..cd4661a 100644
--- a/include/uapi/linux/can/j1939.h
+++ b/include/uapi/linux/can/j1939.h
@@ -78,18 +78,4 @@ struct j1939_filter {
 
 #define J1939_FILTER_MAX 512 /* maximum number of j1939_filter set via setsockopt() */
 
-/* RTNETLINK */
-enum {
-	IFLA_J1939_UNSPEC,
-	IFLA_J1939_ENABLE,
-	IFLA_J1939_MAX,
-};
-
-enum {
-	IFA_J1939_UNSPEC,
-	IFA_J1939_ADDR,
-	IFA_J1939_NAME,
-	IFA_J1939_MAX,
-};
-
 #endif /* !_UAPI_CAN_J1939_H_ */
-- 
1.9.1


From 4465772905937fdbd2919deb97e4e6740be770e2 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 11:37:27 +0200
Subject: [PATCH 088/113] j1939: bus: j1939_name_local_get: add TODO item

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/bus.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index 3f6a5ec..0d9cdf2 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -214,6 +214,7 @@ void j1939_name_local_get(struct j1939_priv *priv, name_t name)
 
 	write_lock_bh(&priv->lock);
 	ecu = _j1939_ecu_get_register(priv, name, 1);
+	/* TODO: do proper error handling and pass error down the callstack */
 	if (!IS_ERR(ecu)) {
 		get_j1939_ecu(ecu);
 		++ecu->nusers;
-- 
1.9.1


From 88dc318fa49acb29854af6e36aa2b3d4975d5ac4 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 11:32:26 +0200
Subject: [PATCH 089/113] j1939: socket: bind() cleanups

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 97 +++++++++++++++++++++++++-------------------------
 1 file changed, 48 insertions(+), 49 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 3eac80f..58bda98 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -240,81 +240,80 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 {
 	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
 	struct j1939_sock *jsk = j1939_sk(sock->sk);
-	int ret, bound_dev_if;
+	struct net_device *netdev;
 	struct j1939_priv *priv;
+	int ret = 0;
 
+	if (!uaddr)
+		return -EDESTADDRREQ;
 	if (len < J1939_MIN_NAMELEN)
 		return -EINVAL;
 	if (addr->can_family != AF_CAN)
 		return -EINVAL;
+	if (!addr->can_ifindex)
+		return -ENODEV;
 
 	lock_sock(sock->sk);
 
-	/* bind to device ... */
-	bound_dev_if = jsk->sk.sk_bound_dev_if;
-	/* copy netdev info */
-	if (!bound_dev_if && addr->can_ifindex) {
-		bound_dev_if = addr->can_ifindex;
-	} else if (bound_dev_if && addr->can_ifindex) {
-		/* do netdev */
-		if (bound_dev_if != addr->can_ifindex) {
-			ret = -EBUSY;
-			goto fail_locked;
-		}
-	}
-	/* start j1939 */
-	if (bound_dev_if && bound_dev_if != jsk->ifindex_started) {
-		if (jsk->ifindex_started) {
-			ret = -EBUSY;
-			goto fail_locked;
-		}
-		ret = j1939_ifindex_start(bound_dev_if);
-		if (ret < 0)
-			goto fail_locked;
-		jsk->ifindex_started = bound_dev_if;
-		priv = j1939_priv_get_by_ifindex(jsk->ifindex_started);
-		j1939_name_local_get(priv, jsk->addr.src_name);
-		j1939_addr_local_get(priv, jsk->addr.sa);
-		j1939_priv_put(priv);
+	netdev = dev_get_by_index(&init_net, addr->can_ifindex);
+	if (!netdev) {
+		ret = -ENODEV;
+		goto out_release_sock;
 	}
 
-	jsk->sk.sk_bound_dev_if = bound_dev_if;
+	/* Already bound to an interface? */
+	if (jsk->state & J1939_SOCK_BOUND) {
+		/* A re-bind() to a different interface is not
+		 * supported.
+		 */
+		if (jsk->sk.sk_bound_dev_if != addr->can_ifindex) {
+			ret = -EINVAL;
+			goto out_dev_put;
+		}
 
-	/* set addr + name */
-	if (jsk->ifindex_started) {
-		priv = j1939_priv_get_by_ifindex(jsk->ifindex_started);
-		/* priv should be set when ifindex_started is nonzero */
+		/* drop old references */
+		priv = j1939_priv_get(netdev);
 		j1939_name_local_put(priv, jsk->addr.src_name);
-		j1939_name_local_get(priv, addr->can_addr.j1939.name);
 		j1939_addr_local_put(priv, jsk->addr.sa);
-		j1939_addr_local_get(priv, addr->can_addr.j1939.addr);
-		j1939_priv_put(priv);
+	} else {
+		if (netdev->type != ARPHRD_CAN) {
+			ret = -ENODEV;
+			goto out_dev_put;
+		}
+
+		ret = j1939_netdev_start(netdev);
+		if (ret < 0)
+			goto out_dev_put;
+
+		jsk->sk.sk_bound_dev_if = addr->can_ifindex;
+		jsk->ifindex_started = addr->can_ifindex;	/* TODO: remove */
+		priv = j1939_priv_get(netdev);
 	}
-	jsk->addr.src_name = addr->can_addr.j1939.name;
-	jsk->addr.sa = addr->can_addr.j1939.addr;
 
 	/* set default transmit pgn */
 	if (pgn_is_valid(addr->can_addr.j1939.pgn))
 		jsk->addr.pgn = addr->can_addr.j1939.pgn;
+	jsk->addr.src_name = addr->can_addr.j1939.name;
+	jsk->addr.sa = addr->can_addr.j1939.addr;
 
-	if (!(jsk->state & (J1939_SOCK_BOUND | J1939_SOCK_CONNECTED))) {
+	/* get new references */
+	j1939_name_local_get(priv, jsk->addr.src_name);
+	j1939_addr_local_get(priv, jsk->addr.sa);
+	j1939_priv_put(priv);
+
+	if (!(jsk->state & J1939_SOCK_BOUND)) {
 		spin_lock_bh(&j1939_socks_lock);
 		list_add_tail(&jsk->list, &j1939_socks);
 		spin_unlock_bh(&j1939_socks_lock);
-	}
-	jsk->state |= J1939_SOCK_BOUND;
-
-	ret = 0;
 
- fail_locked:
-	if (!jsk->sk.sk_bound_dev_if && jsk->ifindex_started) {
-		/* started j1939 on this netdev during this call,
-		 * so we revert that
-		 */
-		j1939_ifindex_stop(jsk->ifindex_started);
-		jsk->ifindex_started = 0;
+		jsk->state |= J1939_SOCK_BOUND;
 	}
+
+ out_dev_put:	/* fallthrough */
+	dev_put(netdev);
+ out_release_sock:
 	release_sock(sock->sk);
+
 	return ret;
 }
 
-- 
1.9.1


From 463d35f0fbbebec5ef85b256f3c0d410f52d3bb2 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 11:32:34 +0200
Subject: [PATCH 090/113] j1939: socket: connect() cleanups

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 54 +++++++++++---------------------------------------
 1 file changed, 12 insertions(+), 42 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 58bda98..6270fad 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -320,72 +320,42 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
 			   int len, int flags)
 {
-	int ret;
 	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
 	struct j1939_sock *jsk = j1939_sk(sock->sk);
-	struct j1939_priv *priv;
-	int bound_dev_if;
+	int ret = 0;
 
 	if (!uaddr)
 		return -EDESTADDRREQ;
-
 	if (len < J1939_MIN_NAMELEN)
 		return -EINVAL;
 	if (addr->can_family != AF_CAN)
 		return -EINVAL;
+	if (!addr->can_ifindex)
+		return -ENODEV;
 
 	lock_sock(sock->sk);
 
-	/* bind to device ... */
-	bound_dev_if = jsk->sk.sk_bound_dev_if;
-
-	/* copy netdev info */
-	if (!bound_dev_if && addr->can_ifindex) {
-		bound_dev_if = addr->can_ifindex;
-	} else if (bound_dev_if && addr->can_ifindex) {
-		/* do netdev */
-		if (bound_dev_if != addr->can_ifindex) {
-			ret = -EBUSY;
-			goto fail_locked;
-		}
+	/* bind() before connect() is mandatory */
+	if (!(jsk->state & J1939_SOCK_BOUND)) {
+		ret = -EINVAL;
+		goto out_release_sock;
 	}
 
-	/* start j1939 */
-	if (bound_dev_if && bound_dev_if != jsk->ifindex_started) {
-		if (jsk->ifindex_started) {
-			ret = -EBUSY;
-			goto fail_locked;
-		}
-		ret = j1939_ifindex_start(bound_dev_if);
-		if (ret < 0)
-			goto fail_locked;
-		jsk->ifindex_started = bound_dev_if;
-		/* make sure that this is in sync */
-		priv = j1939_priv_get_by_ifindex(jsk->ifindex_started);
-		j1939_name_local_get(priv, jsk->addr.src_name);
-		j1939_addr_local_get(priv, jsk->addr.sa);
-		j1939_priv_put(priv);
+	/* A re-connect() is not supported */
+	if (!(jsk->state & J1939_SOCK_CONNECTED)) {
+		ret = -EBUSY;
+		goto out_release_sock;
 	}
 
-	/* lookup destination */
 	jsk->addr.dst_name = addr->can_addr.j1939.name;
 	jsk->addr.da = addr->can_addr.j1939.addr;
 
-	/* start assigning, no problem can occur at this point anymore */
-	jsk->sk.sk_bound_dev_if = bound_dev_if;
-
 	if (pgn_is_valid(addr->can_addr.j1939.pgn))
 		jsk->addr.pgn = addr->can_addr.j1939.pgn;
 
-	if (!(jsk->state & (J1939_SOCK_BOUND | J1939_SOCK_CONNECTED))) {
-		spin_lock_bh(&j1939_socks_lock);
-		list_add_tail(&jsk->list, &j1939_socks);
-		spin_unlock_bh(&j1939_socks_lock);
-	}
 	jsk->state |= J1939_SOCK_CONNECTED;
-	ret = 0;
 
- fail_locked:
+ out_release_sock: /* fallthrough */
 	release_sock(sock->sk);
 	return ret;
 }
-- 
1.9.1


From c4a83d57cd851f6f43741c8820e186bb67834240 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Wed, 16 Aug 2017 12:15:23 +0200
Subject: [PATCH 091/113] j1939: socket: release(): cleanup

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 29 ++++++++++++++++++-----------
 1 file changed, 18 insertions(+), 11 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 6270fad..b1e33ef 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -402,21 +402,28 @@ static int j1939sk_release(struct socket *sock)
 
 	if (!sk)
 		return 0;
-	lock_sock(sk);
+
 	jsk = j1939_sk(sk);
-	spin_lock_bh(&j1939_socks_lock);
-	list_del_init(&jsk->list);
-	spin_unlock_bh(&j1939_socks_lock);
+	lock_sock(sk);
 
-	if (jsk->ifindex_started) {
-		priv = j1939_priv_get_by_ifindex(jsk->ifindex_started);
-		j1939_addr_local_put(priv, jsk->addr.sa);
-		j1939_name_local_put(priv, jsk->addr.src_name);
-		j1939_priv_put(priv);
+	if (jsk->state & J1939_SOCK_BOUND) {
+		struct net_device *netdev;
+
+		spin_lock_bh(&j1939_socks_lock);
+		list_del_init(&jsk->list);
+		spin_unlock_bh(&j1939_socks_lock);
+
+		netdev = dev_get_by_index(&init_net, jsk->sk.sk_bound_dev_if);
+		if (netdev) {
+			priv = j1939_priv_get(netdev);
+			j1939_addr_local_put(priv, jsk->addr.sa);
+			j1939_name_local_put(priv, jsk->addr.src_name);
+			j1939_priv_put(priv);
 
-		j1939_ifindex_stop(jsk->ifindex_started);
+			j1939_netdev_stop(netdev);
+			dev_put(netdev);
+		}
 	}
-	jsk->ifindex_started = 0;
 
 	sock_orphan(sk);
 	sock->sk = NULL;
-- 
1.9.1


From c5e283587effcea9c5f33df98638321a80554281 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 11:36:36 +0200
Subject: [PATCH 092/113] j1939: main: j1939_netdev_start(): remove check for
 ARPHRD_CAN, it's now done in the calling function

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/main.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index bfa42d7..853160c 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -206,9 +206,6 @@ int j1939_netdev_start(struct net_device *netdev)
 	struct j1939_priv *priv;
 	struct can_ml_priv *can_ml_priv;
 
-	if (netdev->type != ARPHRD_CAN)
-		return -EAFNOSUPPORT;
-
 	mutex_lock(&j1939_netdev_lock);
 	can_ml_priv = netdev->ml_priv;
 	priv = can_ml_priv->j1939_priv;
-- 
1.9.1


From 8d9c84f8a0bc57ab4fc5f3f78909651cc283114d Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 11:31:18 +0200
Subject: [PATCH 093/113] j1939: socket: remove j1939_ifindex_{start,stop}() -
 not used anymore

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 30 ------------------------------
 1 file changed, 30 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index b1e33ef..07f08e5 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -206,36 +206,6 @@ static int j1939sk_init(struct sock *sk)
 	return 0;
 }
 
-/* helper: return <0 for error, >0 for error to notify */
-static int j1939_ifindex_start(int ifindex)
-{
-	int ret;
-	struct net_device *netdev;
-
-	netdev = dev_get_by_index(&init_net, ifindex);
-	if (!netdev)
-		return -ENODEV;
-
-	/* no need to test for CAN device,
-	 * done by j1939_netdev_start
-	 */
-	ret = j1939_netdev_start(netdev);
-
-	dev_put(netdev);
-	return ret;
-}
-
-static void j1939_ifindex_stop(int ifindex)
-{
-	struct net_device *netdev;
-
-	netdev = dev_get_by_index(&init_net, ifindex);
-	if (netdev) {
-		j1939_netdev_stop(netdev);
-		dev_put(netdev);
-	}
-}
-
 static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 {
 	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
-- 
1.9.1


From 3c774e425ee11383d784c1c13f3fc6a8cc53c7f1 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 11:47:17 +0200
Subject: [PATCH 094/113] j1939: socket: j1939sk_sock2sockaddr_can() cleanups

Replace the trinary ? operator by a normal if...else construct.

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 07f08e5..910e201 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -335,9 +335,14 @@ static void j1939sk_sock2sockaddr_can(struct sockaddr_can *addr,
 {
 	addr->can_family = AF_CAN;
 	addr->can_ifindex = jsk->sk.sk_bound_dev_if;
-	addr->can_addr.j1939.name = peer ? jsk->addr.dst_name : jsk->addr.src_name;
 	addr->can_addr.j1939.pgn = jsk->addr.pgn;
-	addr->can_addr.j1939.addr = peer ? jsk->addr.da : jsk->addr.sa;
+	if (peer) {
+		addr->can_addr.j1939.name = jsk->addr.dst_name;
+		addr->can_addr.j1939.addr = jsk->addr.da;
+	} else {
+		addr->can_addr.j1939.name = jsk->addr.src_name;
+		addr->can_addr.j1939.addr = jsk->addr.sa;
+	}
 }
 
 static int j1939sk_getname(struct socket *sock, struct sockaddr *uaddr,
-- 
1.9.1


From fddf9cf78321dd959b9e3f1d7f4fafe407242be7 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 13:02:06 +0200
Subject: [PATCH 095/113] j1939: struct j1939_sk_buff_cb: use <name>_flags for
 *_flags variables

Rename struct j1939_sk_buff_cb {src,dst}flags -> {src,dst}_flags.

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h |  4 ++--
 net/can/j1939/main.c       |  4 ++--
 net/can/j1939/transport.c  | 16 ++++++++--------
 3 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 4e89d00..ff5f8d2 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -199,8 +199,8 @@ struct j1939_sk_buff_cb {
 	/* Flags for quick lookups during skb processing
 	 * These are set in the receive path only
 	 */
-	int srcflags;
-	int dstflags;
+	int src_flags;
+	int dst_flags;
 
 #define ECU_LOCAL 1
 
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 853160c..6b6ecae 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -101,11 +101,11 @@ static void j1939_can_recv(struct sk_buff *iskb, void *data)
 	read_lock_bh(&priv->lock);
 	if (j1939_address_is_unicast(skcb->addr.sa) &&
 	    priv->ents[skcb->addr.sa].nusers)
-		skcb->srcflags |= ECU_LOCAL;
+		skcb->src_flags |= ECU_LOCAL;
 	if (j1939_address_is_valid(skcb->addr.da) ||
 	    (j1939_address_is_unicast(skcb->addr.da) &&
 	     priv->ents[skcb->addr.da].nusers))
-		skcb->dstflags |= ECU_LOCAL;
+		skcb->dst_flags |= ECU_LOCAL;
 	read_unlock_bh(&priv->lock);
 
 	/* deliver into the j1939 stack ... */
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 29dcc6d..e551b3a 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -217,7 +217,7 @@ static inline int j1939tp_im_receiver(struct sk_buff *skb)
 {
 	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
 
-	return cb->dstflags & ECU_LOCAL;
+	return cb->dst_flags & ECU_LOCAL;
 }
 
 /* see if we are sender */
@@ -225,7 +225,7 @@ static inline int j1939tp_im_transmitter(struct sk_buff *skb)
 {
 	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
 
-	return cb->srcflags & ECU_LOCAL;
+	return cb->src_flags & ECU_LOCAL;
 }
 
 /* see if we are involved as either receiver or transmitter */
@@ -238,7 +238,7 @@ static int j1939tp_im_involved_anydir(struct sk_buff *skb)
 {
 	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
 
-	return (cb->srcflags | cb->dstflags) & ECU_LOCAL;
+	return (cb->src_flags | cb->dst_flags) & ECU_LOCAL;
 }
 
 /* extract pgn from flow-ctl message */
@@ -345,7 +345,7 @@ static void j1939_skbcb_swap(struct j1939_sk_buff_cb *cb)
 {
 	swap(cb->addr.dst_name, cb->addr.src_name);
 	swap(cb->addr.da, cb->addr.sa);
-	swap(cb->dstflags, cb->srcflags);
+	swap(cb->dst_flags, cb->src_flags);
 }
 
 /* TP transmit packet functions */
@@ -510,7 +510,7 @@ static void j1939_session_cancel(struct session *session, int err)
 		if (!j1939cb_is_broadcast(session->cb)) {
 			/* do not send aborts on incoming broadcasts */
 			j1939xtp_tx_abort(session->skb, session->extd,
-					  !(session->cb->srcflags & ECU_LOCAL),
+					  !(session->cb->src_flags & ECU_LOCAL),
 					  err, session->cb->addr.pgn);
 		}
 	}
@@ -1161,17 +1161,17 @@ int j1939_send_transport(struct sk_buff *skb)
 	if (unlikely(ret))
 		return ret;
 
-	/* fix dstflags, it may be used there soon */
+	/* fix dst_flags, it may be used there soon */
 	priv = j1939_priv_get_by_ifindex(can_skb_prv(skb)->ifindex);
 	if (!priv)
 		return -EINVAL;
 	if (!j1939_address_is_valid(cb->addr.da) ||
 	    (j1939_address_is_unicast(cb->addr.da) &&
 	     priv->ents[cb->addr.da].nusers))
-		cb->dstflags |= ECU_LOCAL;
+		cb->dst_flags |= ECU_LOCAL;
 	j1939_priv_put(priv);
 	/* src is always local, I'm sending ... */
-	cb->srcflags |= ECU_LOCAL;
+	cb->src_flags |= ECU_LOCAL;
 
 	/* prepare new session */
 	session = j1939_session_new(skb);
-- 
1.9.1


From 84e67cc9984265faacee624488ca24653c7c6f65 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 13:14:49 +0200
Subject: [PATCH 096/113] j1939: remove define J1939_MSG_{SYNC,RESERVED} and
 replace it by MSG_SYN

Makes no sense to use a differenct name for an already existing
userspace API define.

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 3 ---
 net/can/j1939/socket.c     | 2 +-
 net/can/j1939/transport.c  | 2 +-
 3 files changed, 2 insertions(+), 5 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index ff5f8d2..a6108a8 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -221,9 +221,6 @@ static inline struct j1939_sk_buff_cb *j1939_get_cb(struct sk_buff *skb)
 	return (struct j1939_sk_buff_cb *)skb->cb;
 }
 
-#define J1939_MSG_RESERVED MSG_SYN
-#define J1939_MSG_SYNC MSG_SYN
-
 static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
 {
 	return (!skcb->addr.dst_name && (skcb->addr.da == 0xff));
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 910e201..1fb639c 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -670,7 +670,7 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 		goto free_skb;
 	}
 
-	if (skcb->msg_flags & J1939_MSG_SYNC) {
+	if (skcb->msg_flags & MSG_SYN) {
 		if (skcb->msg_flags & MSG_DONTWAIT) {
 			ret = j1939_sock_pending_add_first(&jsk->sk);
 			if (ret > 0)
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index e551b3a..ea8495a 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -121,7 +121,7 @@ static struct session *j1939_session_fresh_new(int size,
 /* helpers */
 static inline void fix_cb(struct j1939_sk_buff_cb *cb)
 {
-	cb->msg_flags &= ~J1939_MSG_RESERVED;
+	cb->msg_flags &= ~MSG_SYN;
 }
 
 static inline struct list_head *sessionq(int extd)
-- 
1.9.1


From f87f749c2be9ccdf9a28fc9126434c10e8b5bf62 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 11:58:14 +0200
Subject: [PATCH 097/113] j1939: socket: j1939sk_sendmsg: assign

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 1fb639c..7c33c35 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -646,13 +646,9 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 
 	skcb = j1939_get_cb(skb);
 	memset(skcb, 0, sizeof(*skcb));
+	skcb->addr = jsk->addr;
+	skcb->priority = j1939_prio(sk->sk_priority);
 	skcb->msg_flags = msg->msg_flags;
-	skcb->addr.src_name = jsk->addr.src_name;
-	skcb->addr.dst_name = jsk->addr.dst_name;
-	skcb->addr.pgn = jsk->addr.pgn;
-	skcb->priority = j1939_prio(jsk->sk.sk_priority);
-	skcb->addr.sa = jsk->addr.sa;
-	skcb->addr.da = jsk->addr.da;
 
 	if (msg->msg_name) {
 		struct sockaddr_can *addr = msg->msg_name;
-- 
1.9.1


From 8af3a8dd894b97727f2a632804ec02914c55ca3d Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 13:36:33 +0200
Subject: [PATCH 098/113] j1939: bus: _j1939_ecu_get_register() make
 create_if_necessary argument bool

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/bus.c        | 6 +++---
 net/can/j1939/j1939-priv.h | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index 0d9cdf2..02b285c 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -52,7 +52,7 @@ void put_j1939_ecu(struct j1939_ecu *ecu)
 }
 
 struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv, name_t name,
-					  int create_if_necessary)
+					  bool create_if_necessary)
 {
 	struct j1939_ecu *ecu, *dut;
 
@@ -213,7 +213,7 @@ void j1939_name_local_get(struct j1939_priv *priv, name_t name)
 		return;
 
 	write_lock_bh(&priv->lock);
-	ecu = _j1939_ecu_get_register(priv, name, 1);
+	ecu = _j1939_ecu_get_register(priv, name, true);
 	/* TODO: do proper error handling and pass error down the callstack */
 	if (!IS_ERR(ecu)) {
 		get_j1939_ecu(ecu);
@@ -233,7 +233,7 @@ void j1939_name_local_put(struct j1939_priv *priv, name_t name)
 		return;
 
 	write_lock_bh(&priv->lock);
-	ecu = _j1939_ecu_get_register(priv, name, 0);
+	ecu = _j1939_ecu_get_register(priv, name, false);
 	if (!IS_ERR(ecu)) {
 		--ecu->nusers;
 		if (priv->ents[ecu->sa].ecu == ecu)
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index a6108a8..7df13cb 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -242,7 +242,7 @@ static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
  * when a matching ecu already exists, then that is returned
  */
 struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv,
-					  name_t name, int create_if_necessary);
+					  name_t name, bool create_if_necessary);
 
 /* unregister must be called with lock held */
 void _j1939_ecu_unregister(struct j1939_ecu *);
-- 
1.9.1


From 6b8e77bdb163c57ccd1346d1c17f79cb2cdd3b68 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 14:21:26 +0200
Subject: [PATCH 099/113] j1939: bus: j1939_ecu_find_by_addr(): make parameter
 "sa" a u8

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/bus.c        | 2 +-
 net/can/j1939/j1939-priv.h | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index 02b285c..45dcf37 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -99,7 +99,7 @@ void _j1939_ecu_unregister(struct j1939_ecu *ecu)
 	put_j1939_ecu(ecu);
 }
 
-struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex)
+struct j1939_ecu *j1939_ecu_find_by_addr(u8 sa, int ifindex)
 {
 	struct j1939_ecu *ecu;
 	struct j1939_priv *priv;
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 7df13cb..dd7e848 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -175,7 +175,7 @@ static inline void j1939_ecu_remove_sa(struct j1939_ecu *ecu)
 }
 
 int j1939_name_to_sa(name_t name, int ifindex);
-struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex);
+struct j1939_ecu *j1939_ecu_find_by_addr(u8 sa, int ifindex);
 struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex);
 /* find_by_name, with kref & read_lock taken */
 struct j1939_ecu *j1939_ecu_find_priv_default_tx(int ifindex, name_t *pname,
-- 
1.9.1


From c607b08b1e40b937f897875d765909d4de401cc9 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 14:22:06 +0200
Subject: [PATCH 100/113] j1939: bus: let j1939_name_to_sa return a u8

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/address-claim.c | 3 ++-
 net/can/j1939/bus.c           | 2 +-
 net/can/j1939/j1939-priv.h    | 2 +-
 3 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
index d136b26..2318602 100644
--- a/net/can/j1939/address-claim.c
+++ b/net/can/j1939/address-claim.c
@@ -77,7 +77,8 @@ static int j1939_verify_outgoing_address_claim(struct sk_buff *skb)
 
 int j1939_fixup_address_claim(struct sk_buff *skb)
 {
-	int ret, sa;
+	int ret;
+	u8 sa;
 	struct j1939_sk_buff_cb *skcb = j1939_get_cb(skb);
 
 	/* network mgmt: address claiming msgs */
diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index 45dcf37..0585d65 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -118,7 +118,7 @@ struct j1939_ecu *j1939_ecu_find_by_addr(u8 sa, int ifindex)
 	return ecu;
 }
 
-int j1939_name_to_sa(name_t name, int ifindex)
+u8 j1939_name_to_sa(name_t name, int ifindex)
 {
 	struct j1939_ecu *ecu;
 	struct j1939_priv *priv;
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index dd7e848..7b22dd3 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -174,7 +174,7 @@ static inline void j1939_ecu_remove_sa(struct j1939_ecu *ecu)
 	write_unlock_bh(&ecu->priv->lock);
 }
 
-int j1939_name_to_sa(name_t name, int ifindex);
+u8 j1939_name_to_sa(name_t name, int ifindex);
 struct j1939_ecu *j1939_ecu_find_by_addr(u8 sa, int ifindex);
 struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex);
 /* find_by_name, with kref & read_lock taken */
-- 
1.9.1


From 12829c465211694087ba322bea936d58193ad962 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 14:32:34 +0200
Subject: [PATCH 101/113] j1939: priv: let j1939_prio() return a priority_t
 instead of int

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 7b22dd3..056f4a9 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -118,7 +118,7 @@ static inline void get_j1939_ecu(struct j1939_ecu *dut)
 /* conversion function between (struct sock | struct sk_buff)->sk_priority
  * from linux and j1939 priority field
  */
-static inline int j1939_prio(int sk_priority)
+static inline priority_t j1939_prio(int sk_priority)
 {
 	if (sk_priority < 0)
 		return 6; /* default */
-- 
1.9.1


From e883c6c2f660c7cc14d8b3caba104b0e1d4b44b4 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 14:33:07 +0200
Subject: [PATCH 102/113] j1939: priv: j1939_to_sk_priority(): change priority
 argument from int to priority_t

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 056f4a9..a66b5df 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -128,7 +128,7 @@ static inline priority_t j1939_prio(int sk_priority)
 		return 7 - sk_priority;
 }
 
-static inline int j1939_to_sk_priority(int j1939_prio)
+static inline int j1939_to_sk_priority(priority_t j1939_prio)
 {
 	return 7 - j1939_prio;
 }
-- 
1.9.1


From bde609040844f149a084daef4bee2dfe6bb0db2c Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Thu, 17 Aug 2017 15:41:31 +0200
Subject: [PATCH 103/113] j1939: socket: finally get rid of struct
 j1939_sock::ifindex_started

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 7 +------
 1 file changed, 1 insertion(+), 6 deletions(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 7c33c35..32d8aaa 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -41,8 +41,6 @@ struct j1939_sock {
 #define J1939_SOCK_PROMISC BIT(2)
 #define J1939_SOCK_RECV_OWN BIT(3)
 
-	int ifindex_started; /* ifindex of netdev */
-
 	struct j1939_addr addr;
 	struct j1939_filter *filters;
 	int nfilters;
@@ -256,7 +254,6 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 			goto out_dev_put;
 
 		jsk->sk.sk_bound_dev_if = addr->can_ifindex;
-		jsk->ifindex_started = addr->can_ifindex;	/* TODO: remove */
 		priv = j1939_priv_get(netdev);
 	}
 
@@ -602,9 +599,7 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	if (!(jsk->state & J1939_SOCK_BOUND))
 		return -EBADFD;
 
-	ifindex = jsk->ifindex_started;
-	if (!ifindex)
-		return -EBADFD;
+	ifindex = sk->sk_bound_dev_if;
 
 	if (jsk->addr.sa == J1939_NO_ADDR && !jsk->addr.src_name)
 		/* no address assigned yet */
-- 
1.9.1


From 24a2c51e6f40e837ae2b7ba8154dbc29200ed34b Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Wed, 23 Aug 2017 15:59:42 +0200
Subject: [PATCH 104/113] j1939: j1939_priv_*(): put more complex functions
 into main.c others as static inlines into j1939-priv.h

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 37 ++++++++++++++-----------------------
 net/can/j1939/main.c       | 32 +++++++++++++++++++++++++++++---
 2 files changed, 43 insertions(+), 26 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index a66b5df..051e31d 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -102,7 +102,6 @@ struct j1939_priv {
 };
 
 void put_j1939_ecu(struct j1939_ecu *ecu);
-void j1939_priv_put(struct j1939_priv *segment);
 
 static inline void get_j1939_ecu(struct j1939_ecu *dut)
 {
@@ -250,36 +249,28 @@ struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv,
 int j1939_netdev_start(struct net_device *);
 void j1939_netdev_stop(struct net_device *);
 
-static inline struct j1939_priv *j1939_priv_get(struct net_device *dev)
-{
-	struct can_ml_priv *can_ml_priv;
-	struct j1939_priv *priv;
-
-	if (dev->type != ARPHRD_CAN)
-		return NULL;
+void __j1939_priv_release(struct kref *kref);
+struct j1939_priv *j1939_priv_get(struct net_device *dev);
+struct j1939_priv *j1939_priv_get_by_ifindex(int ifindex);
 
-	can_ml_priv = dev->ml_priv;
-	priv = can_ml_priv->j1939_priv;
 
-	if (priv)
-		kref_get(&priv->kref);
+static inline void j1939_priv_set(struct net_device *dev, struct j1939_priv *priv)
+{
+	struct can_ml_priv *can_ml_priv = dev->ml_priv;
 
-	return priv;
+	can_ml_priv->j1939_priv = priv;
 }
 
-static inline struct j1939_priv *j1939_priv_get_by_ifindex(int ifindex)
+static inline struct j1939_priv *__j1939_priv_get(struct net_device *dev)
 {
-	struct j1939_priv *priv;
-	struct net_device *netdev;
-
-	netdev = dev_get_by_index(&init_net, ifindex);
-	if (!netdev)
-		return NULL;
+	struct can_ml_priv *can_ml_priv = dev->ml_priv;
 
-	priv = j1939_priv_get(netdev);
-	dev_put(netdev);
+	return can_ml_priv->j1939_priv;
+}
 
-	return priv;
+static inline void j1939_priv_put(struct j1939_priv *priv)
+{
+	kref_put(&priv->kref, __j1939_priv_release);
 }
 
 /* notify/alert all j1939 sockets bound to ifindex */
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 6b6ecae..5390330 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -281,7 +281,7 @@ void j1939_netdev_stop(struct net_device *netdev)
 }
 
 /* device interface */
-static void on_put_j1939_priv(struct kref *kref)
+void __j1939_priv_release(struct kref *kref)
 {
 	struct j1939_priv *priv = container_of(kref, struct j1939_priv, kref);
 	struct j1939_ecu *ecu;
@@ -298,9 +298,35 @@ static void on_put_j1939_priv(struct kref *kref)
 	kfree(priv);
 }
 
-void j1939_priv_put(struct j1939_priv *segment)
+struct j1939_priv *j1939_priv_get(struct net_device *dev)
 {
-	kref_put(&segment->kref, on_put_j1939_priv);
+	struct j1939_priv *priv;
+
+	if (dev->type != ARPHRD_CAN)
+		return NULL;
+
+	priv = __j1939_priv_get(dev);
+	if (priv)
+		kref_get(&priv->kref);
+
+	return priv;
+}
+
+struct j1939_priv *j1939_priv_get_by_ifindex(int ifindex)
+{
+	struct j1939_priv *priv;
+	struct net_device *netdev;
+
+	printk("%s: ifindex=%d\n", __func__, ifindex);
+
+	netdev = dev_get_by_index(&init_net, ifindex);
+	if (!netdev)
+		return NULL;
+
+	priv = j1939_priv_get(netdev);
+	dev_put(netdev);
+
+	return priv;
 }
 
 static int j1939_netdev_notify(struct notifier_block *nb,
-- 
1.9.1


From aca3282c21cc2ab1ab8c5c43b9c5e0361a00335c Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Wed, 23 Aug 2017 12:41:00 +0200
Subject: [PATCH 105/113] j1939: socket: j1939_netdev_{start,stop}: use
 spinlock instead of mutexed, so that it can be called from a netdev notifier

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h |  5 ---
 net/can/j1939/main.c       | 94 ++++++++++++++++++++++------------------------
 2 files changed, 44 insertions(+), 55 deletions(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 051e31d..755bb83 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -94,11 +94,6 @@ struct j1939_priv {
 	struct tasklet_struct ac_task;
 
 	struct kref kref;
-
-	/* ref counter that hold the number of active listeners.
-	 * This number itself is protected with a mutex
-	 */
-	int nusers;
 };
 
 void put_j1939_ecu(struct j1939_ecu *ecu);
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 5390330..f455980 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -198,86 +198,68 @@ static void j1939_priv_ac_task(unsigned long val)
 #define J1939_CAN_ID CAN_EFF_FLAG
 #define J1939_CAN_MASK (CAN_EFF_FLAG | CAN_RTR_FLAG)
 
-static DEFINE_MUTEX(j1939_netdev_lock);
+static DEFINE_SPINLOCK(j1939_netdev_lock);
 
 int j1939_netdev_start(struct net_device *netdev)
 {
-	int ret;
 	struct j1939_priv *priv;
-	struct can_ml_priv *can_ml_priv;
+	int ret;
 
-	mutex_lock(&j1939_netdev_lock);
-	can_ml_priv = netdev->ml_priv;
-	priv = can_ml_priv->j1939_priv;
-	if (priv) {
-		++priv->nusers;
-		goto done;
-	}
+	spin_lock(&j1939_netdev_lock);
+	priv = j1939_priv_get(netdev);
+	spin_unlock(&j1939_netdev_lock);
+	if (priv)
+		return 0;
 
-	/* create/stuff j1939_priv */
+	/* create j1939_priv */
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
-		ret = -ENOMEM;
-		goto fail_mem;
-	}
+	if (!priv)
+		return -ENOMEM;
+
 	tasklet_init(&priv->ac_task, j1939_priv_ac_task, (unsigned long)priv);
 	rwlock_init(&priv->lock);
 	INIT_LIST_HEAD(&priv->ecus);
 	priv->netdev = netdev;
 	priv->ifindex = netdev->ifindex;
 	kref_init(&priv->kref);
-	priv->nusers = 1;
+	dev_hold(netdev);
 
 	/* add CAN handler */
 	ret = can_rx_register(&init_net, netdev, J1939_CAN_ID, J1939_CAN_MASK,
 			      j1939_can_recv, priv, "j1939", NULL);
 	if (ret < 0)
-		goto fail_can;
+		goto out_dev_put;
+
+	spin_lock(&j1939_netdev_lock);
+	if (j1939_priv_get(netdev)) {
+		/* Someone was faster than us, use their priv and roll
+		 * back our's. */
+		spin_unlock(&j1939_netdev_lock);
+		goto out_rx_unregister;
+	}
+	j1939_priv_set(netdev, priv);
+	spin_unlock(&j1939_netdev_lock);
 
-	can_ml_priv->j1939_priv = priv;
-	dev_hold(netdev);
- done:
-	mutex_unlock(&j1939_netdev_lock);
 	return 0;
 
- fail_can:
+ out_rx_unregister:
+	can_rx_unregister(&init_net, netdev, J1939_CAN_ID, J1939_CAN_MASK,
+			  j1939_can_recv, priv);
+ out_dev_put:
+	dev_put(netdev);
 	kfree(priv);
- fail_mem:
-	mutex_unlock(&j1939_netdev_lock);
+
 	return ret;
 }
 
 void j1939_netdev_stop(struct net_device *netdev)
 {
-	struct can_ml_priv *can_ml_priv;
 	struct j1939_priv *priv;
 
-	if (netdev->type != ARPHRD_CAN)
-		return;
-	can_ml_priv = netdev->ml_priv;
-
-	mutex_lock(&j1939_netdev_lock);
-	priv = can_ml_priv->j1939_priv;
-	--priv->nusers;
-	if (priv->nusers) {
-		mutex_unlock(&j1939_netdev_lock);
-		return;
-	}
-	/* no users left, start breakdown */
-
-	/* unlink from netdev */
-	can_ml_priv->j1939_priv = NULL;
-	mutex_unlock(&j1939_netdev_lock);
-
-	can_rx_unregister(&init_net, netdev, J1939_CAN_ID, J1939_CAN_MASK,
-			  j1939_can_recv, priv);
-
-	/* remove pending transport protocol sessions */
-	j1939tp_rmdev_notifier(netdev);
-
-	/* final put */
+	spin_lock(&j1939_netdev_lock);
+	priv = __j1939_priv_get(netdev);
 	j1939_priv_put(priv);
-	dev_put(netdev);
+	spin_unlock(&j1939_netdev_lock);
 }
 
 /* device interface */
@@ -286,15 +268,27 @@ void __j1939_priv_release(struct kref *kref)
 	struct j1939_priv *priv = container_of(kref, struct j1939_priv, kref);
 	struct j1939_ecu *ecu;
 
+	can_rx_unregister(&init_net, priv->netdev, J1939_CAN_ID, J1939_CAN_MASK,
+			  j1939_can_recv, priv);
+
 	tasklet_disable_nosync(&priv->ac_task);
 
+	/* remove pending transport protocol sessions */
+	j1939tp_rmdev_notifier(priv->netdev);
+
 	/* cleanup priv */
 	write_lock_bh(&priv->lock);
+	/* TODO: list_for_each() */
 	while (!list_empty(&priv->ecus)) {
 		ecu = list_first_entry(&priv->ecus, struct j1939_ecu, list);
 		_j1939_ecu_unregister(ecu);
 	}
 	write_unlock_bh(&priv->lock);
+
+	/* unlink from netdev */
+	j1939_priv_set(priv->netdev, NULL);
+
+	dev_put(priv->netdev);
 	kfree(priv);
 }
 
-- 
1.9.1


From 89b45fdafe8c7edbff6c2bd9bb51460732410e21 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Wed, 23 Aug 2017 17:00:42 +0200
Subject: [PATCH 106/113] j1939: socket: j1939sk_netdev_event(): fix ENETDOWN
 handling: tear down socket if netdev is suddenly unplugged

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/socket.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 32d8aaa..fdb1977 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -698,9 +698,23 @@ void j1939sk_netdev_event(int ifindex, int error_code)
 	list_for_each_entry(jsk, &j1939_socks, list) {
 		if (jsk->sk.sk_bound_dev_if != ifindex)
 			continue;
+
 		jsk->sk.sk_err = error_code;
 		if (!sock_flag(&jsk->sk, SOCK_DEAD))
 			jsk->sk.sk_error_report(&jsk->sk);
+
+		if (error_code == ENETDOWN) {
+			struct j1939_priv *priv;
+			struct net_device *netdev;
+
+			priv = j1939_priv_get_by_ifindex(ifindex);
+			netdev = priv->netdev;
+			j1939_addr_local_put(priv, jsk->addr.sa);
+			j1939_name_local_put(priv, jsk->addr.src_name);
+			j1939_priv_put(priv);
+			j1939_netdev_stop(netdev);
+		}
+
 		/* do not remove filters here */
 	}
 	spin_unlock_bh(&j1939_socks_lock);
-- 
1.9.1


From e060874e16fda40d822d631bba49933f868d7266 Mon Sep 17 00:00:00 2001
From: Marc Kleine-Budde <mkl@pengutronix.de>
Date: Tue, 22 Aug 2017 13:03:00 +0200
Subject: [PATCH 107/113] j1939: add TODO items

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
---
 net/can/j1939/j1939-priv.h | 2 +-
 net/can/j1939/main.c       | 1 +
 net/can/j1939/socket.c     | 1 +
 3 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 755bb83..ef9aa98 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -72,7 +72,7 @@ struct j1939_priv {
 	/* segments need a lock to protect the above list */
 	rwlock_t lock;
 
-	int ifindex;
+	int ifindex;			/* TODO: redundant with netdev? */
 	struct net_device *netdev;
 
 	/* list of 256 ecu ptrs, that cache the claimed addresses.
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index f455980..e5078b7 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -216,6 +216,7 @@ int j1939_netdev_start(struct net_device *netdev)
 	if (!priv)
 		return -ENOMEM;
 
+	/* TODO: use tasklet_hrtimer_init() instead */
 	tasklet_init(&priv->ac_task, j1939_priv_ac_task, (unsigned long)priv);
 	rwlock_init(&priv->lock);
 	INIT_LIST_HEAD(&priv->ecus);
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index fdb1977..3040c6d 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -611,6 +611,7 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 			return -EINVAL;
 		if (addr->can_family != AF_CAN)
 			return -EINVAL;
+		/* TODO: always check if ifindex is correct? */
 		if (addr->can_ifindex && (ifindex != addr->can_ifindex))
 			return -EBADFD;
 	}
-- 
1.9.1


From b3304f9e4e3ae0966a81dc031f2517852b952db8 Mon Sep 17 00:00:00 2001
From: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Date: Tue, 10 Oct 2017 00:12:17 +0200
Subject: [PATCH 108/113] can-j1939: proper device removal

ENETDOWN does not indicate device removal, but ENODEV does.
The subsequent operations are valid upon device removal.

Signed-off-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
---
 net/can/j1939/socket.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 3040c6d..e7e2dad 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -704,7 +704,7 @@ void j1939sk_netdev_event(int ifindex, int error_code)
 		if (!sock_flag(&jsk->sk, SOCK_DEAD))
 			jsk->sk.sk_error_report(&jsk->sk);
 
-		if (error_code == ENETDOWN) {
+		if (error_code == ENODEV) {
 			struct j1939_priv *priv;
 			struct net_device *netdev;
 
-- 
1.9.1


From be4580bee71684769d732c318150c784480fb21e Mon Sep 17 00:00:00 2001
From: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Date: Tue, 16 May 2017 14:42:15 +0200
Subject: [PATCH 109/113] can-j1939: leave skb->cb untouched

Swapping src & dst just for reverse direction lookup is
not enough justification for touching.
This commit propagates the intended direction to j1939xtp_rx_abort
and avoids touching the skb->cb

Signed-off-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
---
 net/can/j1939/transport.c | 28 ++++++++--------------------
 1 file changed, 8 insertions(+), 20 deletions(-)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index ea8495a..7b838c5 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -537,13 +537,13 @@ static void j1939tp_rxtask(unsigned long val)
 }
 
 /* receive packet functions */
-static void _j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
+static void _j1939xtp_rx_bad_message(struct sk_buff *skb, int extd, int reverse)
 {
 	struct session *session;
 	pgn_t pgn;
 
 	pgn = j1939xtp_ctl_to_pgn(skb->data);
-	session = j1939tp_find(sessionq(extd), skb, 0);
+	session = j1939tp_find(sessionq(extd), skb, reverse);
 	if (session /*&& (session->cb->addr.pgn == pgn)*/) {
 		/* do not allow TP control messages on 2 pgn's */
 		j1939_session_cancel(session, ABORT_FAULT);
@@ -559,25 +559,19 @@ static void _j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
 /* abort packets may come in 2 directions */
 static void j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
 {
-	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
-
 	pr_info("%s, pgn %05x\n", __func__, j1939xtp_ctl_to_pgn(skb->data));
 
-	_j1939xtp_rx_bad_message(skb, extd);
-	j1939_skbcb_swap(cb);
-	_j1939xtp_rx_bad_message(skb, extd);
-
-	/* restore skb */
-	j1939_skbcb_swap(cb);
+	_j1939xtp_rx_bad_message(skb, extd, 0);
+	_j1939xtp_rx_bad_message(skb, extd, 1);
 }
 
-static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd)
+static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd, int reverse)
 {
 	struct session *session;
 	pgn_t pgn;
 
 	pgn = j1939xtp_ctl_to_pgn(skb->data);
-	session = j1939tp_find(sessionq(extd), skb, 0);
+	session = j1939tp_find(sessionq(extd), skb, reverse);
 	if (!session)
 		return;
 	if (session->transmission && !session->last_txcmd) {
@@ -598,17 +592,11 @@ static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd)
 /* abort packets may come in 2 directions */
 static inline void j1939xtp_rx_abort(struct sk_buff *skb, int extd)
 {
-	struct j1939_sk_buff_cb *cb = j1939_get_cb(skb);
-
 	pr_info("%s %i, %05x\n", __func__, skb->skb_iif,
 		j1939xtp_ctl_to_pgn(skb->data));
 
-	_j1939xtp_rx_abort(skb, extd);
-	j1939_skbcb_swap(cb);
-	_j1939xtp_rx_abort(skb, extd);
-
-	/* restore skb */
-	j1939_skbcb_swap(cb);
+	_j1939xtp_rx_abort(skb, extd, 0);
+	_j1939xtp_rx_abort(skb, extd, 1);
 }
 
 static void j1939xtp_rx_eof(struct sk_buff *skb, int extd)
-- 
1.9.1


From bfe4e57a037fbe7e9df0c84d9c46e5ca08c1fede Mon Sep 17 00:00:00 2001
From: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Date: Wed, 4 Oct 2017 22:39:17 +0200
Subject: [PATCH 110/113] can-j1939: fix ifindex compare for incoming packets

Signed-off-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Acked-by: Elenita Hinds <ecathinds@gmail.com>
---
 net/can/j1939/transport.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 7b838c5..195cdd6 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -1298,6 +1298,7 @@ static struct session *j1939_session_fresh_new(int size,
 		return NULL;
 	}
 	session->skb_iif = rel_skb->skb_iif;
+	skb->skb_iif = rel_skb->skb_iif;
 	skb->dev = rel_skb->dev;
 
 	/* alloc data area */
-- 
1.9.1


From fbfeea330b034889682bf752ba42ae73399ea1a2 Mon Sep 17 00:00:00 2001
From: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Date: Sun, 8 Oct 2017 14:55:37 +0200
Subject: [PATCH 111/113] can-j1939: avoid pdu1 pgn's with non-zero bits

PDU1 pgn's will have their lowest 8 bits filled with the DA.
The interface seperates DA from PGN, so the PGN's lowest 8 bits
are ignored.
This commit ensures that these 8 bits are zero, as the remaining code
implies that.

Signed-off-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
---
 net/can/j1939/j1939-priv.h | 8 ++++++++
 net/can/j1939/socket.c     | 9 +++++++++
 2 files changed, 17 insertions(+)

diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index ef9aa98..a80bc92 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -143,11 +143,19 @@ static inline bool pgn_is_pdu1(pgn_t pgn)
 	return (pgn & 0xff00) < 0xf000;
 }
 
+/* function to see if pgn is to be evaluated */
 static inline bool pgn_is_valid(pgn_t pgn)
 {
 	return pgn <= PGN_MAX;
 }
 
+/* test function to avoid non-zero DA placeholder
+ * for pdu1 pgn's */
+static inline bool pgn_is_clean_pdu(pgn_t pgn)
+{
+	return pgn_is_pdu1(pgn) ? !(pgn & 0xff) : 1;
+}
+
 /* utility to correctly unregister a SA */
 static inline void _j1939_ecu_remove_sa(struct j1939_ecu *ecu)
 {
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index e7e2dad..b03bcff 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -220,6 +220,9 @@ static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 		return -EINVAL;
 	if (!addr->can_ifindex)
 		return -ENODEV;
+	if (pgn_is_valid(addr->can_addr.j1939.pgn) &&
+			!pgn_is_clean_pdu(addr->can_addr.j1939.pgn))
+		return -EINVAL;
 
 	lock_sock(sock->sk);
 
@@ -299,6 +302,9 @@ static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
 		return -EINVAL;
 	if (!addr->can_ifindex)
 		return -ENODEV;
+	if (pgn_is_valid(addr->can_addr.j1939.pgn) &&
+			!pgn_is_clean_pdu(addr->can_addr.j1939.pgn))
+		return -EINVAL;
 
 	lock_sock(sock->sk);
 
@@ -611,6 +617,9 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 			return -EINVAL;
 		if (addr->can_family != AF_CAN)
 			return -EINVAL;
+		if (pgn_is_valid(addr->can_addr.j1939.pgn) &&
+				!pgn_is_clean_pdu(addr->can_addr.j1939.pgn))
+			return -EINVAL;
 		/* TODO: always check if ifindex is correct? */
 		if (addr->can_ifindex && (ifindex != addr->can_ifindex))
 			return -EBADFD;
-- 
1.9.1


From fcf4cac976591187fad4696dc0552721cc8929c3 Mon Sep 17 00:00:00 2001
From: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Date: Sun, 8 Oct 2017 14:57:09 +0200
Subject: [PATCH 112/113] can-j1939: reduce ifindex-to-netdev lookups

Signed-off-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
---
 net/can/j1939/address-claim.c | 14 ++++----------
 net/can/j1939/bus.c           |  7 +------
 net/can/j1939/j1939-priv.h    |  4 ++--
 net/can/j1939/main.c          |  4 ++--
 net/can/j1939/socket.c        | 10 ++++------
 5 files changed, 13 insertions(+), 26 deletions(-)

diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
index 2318602..ab538e1 100644
--- a/net/can/j1939/address-claim.c
+++ b/net/can/j1939/address-claim.c
@@ -123,11 +123,10 @@ int j1939_fixup_address_claim(struct sk_buff *skb)
 	return 0;
 }
 
-static void j1939_process_address_claim(struct sk_buff *skb)
+static void j1939_process_address_claim(struct sk_buff *skb, struct j1939_priv *priv)
 {
 	struct j1939_sk_buff_cb *skcb = j1939_get_cb(skb);
 	struct j1939_ecu *ecu, *prev;
-	struct j1939_priv *priv;
 	name_t name;
 
 	if (skb->len != 8) {
@@ -147,10 +146,6 @@ static void j1939_process_address_claim(struct sk_buff *skb)
 		return;
 	}
 
-	priv = j1939_priv_get_by_ifindex(skb->skb_iif);
-	if (!priv)
-		return;
-
 	write_lock_bh(&priv->lock);
 
 	ecu = _j1939_ecu_get_register(priv, name,
@@ -188,7 +183,6 @@ static void j1939_process_address_claim(struct sk_buff *skb)
 	ecu->rxtime = ktime_get();
  done:
 	write_unlock_bh(&priv->lock);
-	j1939_priv_put(priv);
 }
 
 void j1939_recv_address_claim(struct sk_buff *skb, struct j1939_priv *priv)
@@ -198,9 +192,9 @@ void j1939_recv_address_claim(struct sk_buff *skb, struct j1939_priv *priv)
 
 	/* network mgmt */
 	if (skcb->addr.pgn == PGN_ADDRESS_CLAIMED) {
-		j1939_process_address_claim(skb);
+		j1939_process_address_claim(skb, priv);
 	} else if (j1939_address_is_unicast(skcb->addr.sa)) {
-		ecu = j1939_ecu_find_by_addr(skcb->addr.sa, skb->skb_iif);
+		ecu = _j1939_ecu_find_by_addr(skcb->addr.sa, priv);
 		if (ecu) {
 			/* source administration */
 			ecu->rxtime = ktime_get();
@@ -210,7 +204,7 @@ void j1939_recv_address_claim(struct sk_buff *skb, struct j1939_priv *priv)
 	}
 
 	/* assign destination stuff */
-	ecu = j1939_ecu_find_by_addr(skcb->addr.da, skb->skb_iif);
+	ecu = _j1939_ecu_find_by_addr(skcb->addr.da, priv);
 	if (ecu) {
 		skcb->addr.dst_name = ecu->name;
 		put_j1939_ecu(ecu);
diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index 0585d65..fb6b701 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -99,22 +99,17 @@ void _j1939_ecu_unregister(struct j1939_ecu *ecu)
 	put_j1939_ecu(ecu);
 }
 
-struct j1939_ecu *j1939_ecu_find_by_addr(u8 sa, int ifindex)
+struct j1939_ecu *_j1939_ecu_find_by_addr(u8 sa, struct j1939_priv *priv)
 {
 	struct j1939_ecu *ecu;
-	struct j1939_priv *priv;
 
 	if (!j1939_address_is_unicast(sa))
 		return NULL;
-	priv = j1939_priv_get_by_ifindex(ifindex);
-	if (!priv)
-		return NULL;
 	read_lock_bh(&priv->lock);
 	ecu = priv->ents[sa].ecu;
 	if (ecu)
 		get_j1939_ecu(ecu);
 	read_unlock_bh(&priv->lock);
-	j1939_priv_put(priv);
 	return ecu;
 }
 
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index a80bc92..da37056 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -177,7 +177,7 @@ static inline void j1939_ecu_remove_sa(struct j1939_ecu *ecu)
 }
 
 u8 j1939_name_to_sa(name_t name, int ifindex);
-struct j1939_ecu *j1939_ecu_find_by_addr(u8 sa, int ifindex);
+struct j1939_ecu *_j1939_ecu_find_by_addr(u8 sa, struct j1939_priv *priv);
 struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex);
 /* find_by_name, with kref & read_lock taken */
 struct j1939_ecu *j1939_ecu_find_priv_default_tx(int ifindex, name_t *pname,
@@ -277,7 +277,7 @@ static inline void j1939_priv_put(struct j1939_priv *priv)
 }
 
 /* notify/alert all j1939 sockets bound to ifindex */
-void j1939sk_netdev_event(int ifindex, int error_code);
+void j1939sk_netdev_event(struct net_device *netdev, int error_code);
 int j1939tp_rmdev_notifier(struct net_device *netdev);
 
 /* decrement pending skb for a j1939 socket */
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index e5078b7..cb8b1c8 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -338,11 +338,11 @@ static int j1939_netdev_notify(struct notifier_block *nb,
 	switch (msg) {
 	case NETDEV_UNREGISTER:
 		j1939tp_rmdev_notifier(netdev);
-		j1939sk_netdev_event(netdev->ifindex, ENODEV);
+		j1939sk_netdev_event(netdev, ENODEV);
 		break;
 
 	case NETDEV_DOWN:
-		j1939sk_netdev_event(netdev->ifindex, ENETDOWN);
+		j1939sk_netdev_event(netdev, ENETDOWN);
 		break;
 	}
 
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index b03bcff..e04c171 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -700,13 +700,13 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	return ret;
 }
 
-void j1939sk_netdev_event(int ifindex, int error_code)
+void j1939sk_netdev_event(struct net_device *netdev, int error_code)
 {
 	struct j1939_sock *jsk;
 
 	spin_lock_bh(&j1939_socks_lock);
 	list_for_each_entry(jsk, &j1939_socks, list) {
-		if (jsk->sk.sk_bound_dev_if != ifindex)
+		if (jsk->sk.sk_bound_dev_if != netdev->ifindex)
 			continue;
 
 		jsk->sk.sk_err = error_code;
@@ -715,16 +715,14 @@ void j1939sk_netdev_event(int ifindex, int error_code)
 
 		if (error_code == ENODEV) {
 			struct j1939_priv *priv;
-			struct net_device *netdev;
 
-			priv = j1939_priv_get_by_ifindex(ifindex);
-			netdev = priv->netdev;
+			priv = j1939_priv_get(netdev);
 			j1939_addr_local_put(priv, jsk->addr.sa);
 			j1939_name_local_put(priv, jsk->addr.src_name);
 			j1939_priv_put(priv);
+
 			j1939_netdev_stop(netdev);
 		}
-
 		/* do not remove filters here */
 	}
 	spin_unlock_bh(&j1939_socks_lock);
-- 
1.9.1


From a9ca675d555da93afd3ca4e8e0dd9dad70841d00 Mon Sep 17 00:00:00 2001
From: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Date: Tue, 14 Nov 2017 09:57:54 +0100
Subject: [PATCH 113/113] can-j1939: fix foreign transport protocol sessions

This commit fixes the behaviour on reception of foreign transport protocol sessions.
Before, the such sessions were wrongly marked with 'local destination' and the stack
participated in the flow control.

Signed-off-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
---
 net/can/j1939/main.c      | 5 ++---
 net/can/j1939/transport.c | 5 ++---
 2 files changed, 4 insertions(+), 6 deletions(-)

diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index cb8b1c8..86cdcc1 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -102,9 +102,8 @@ static void j1939_can_recv(struct sk_buff *iskb, void *data)
 	if (j1939_address_is_unicast(skcb->addr.sa) &&
 	    priv->ents[skcb->addr.sa].nusers)
 		skcb->src_flags |= ECU_LOCAL;
-	if (j1939_address_is_valid(skcb->addr.da) ||
-	    (j1939_address_is_unicast(skcb->addr.da) &&
-	     priv->ents[skcb->addr.da].nusers))
+	if (j1939_address_is_unicast(skcb->addr.da) &&
+			priv->ents[skcb->addr.da].nusers)
 		skcb->dst_flags |= ECU_LOCAL;
 	read_unlock_bh(&priv->lock);
 
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 195cdd6..587eb04 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -1153,9 +1153,8 @@ int j1939_send_transport(struct sk_buff *skb)
 	priv = j1939_priv_get_by_ifindex(can_skb_prv(skb)->ifindex);
 	if (!priv)
 		return -EINVAL;
-	if (!j1939_address_is_valid(cb->addr.da) ||
-	    (j1939_address_is_unicast(cb->addr.da) &&
-	     priv->ents[cb->addr.da].nusers))
+	if (j1939_address_is_unicast(cb->addr.da) &&
+			priv->ents[cb->addr.da].nusers)
 		cb->dst_flags |= ECU_LOCAL;
 	j1939_priv_put(priv);
 	/* src is always local, I'm sending ... */
-- 
1.9.1

